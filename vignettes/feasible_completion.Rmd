---
title: "Filter for program completion feasibility"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Filter for program completion feasibility}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/chicago-author-date.csl
link-citations: yes
resource_files:
  - ../man/figures/feasible-completion-relationships-1.png
---

```{r setup, echo = FALSE}
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(
  echo = TRUE,
  error = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center",
  fig.path = "../man/figures/vign-feasible-completion-"
)
```


## Introduction

Persistence metrics often include a criterion that students complete their programs within $x$ years (typically 6 years, based on 150% of the "normal" time to completion). See, for example, [@ipeds2018]. 

In longitudinal research, this completion criterion requires special care. For student records near the upper limit of an institution's data range, a student's completion status can be ambiguous. Consider a case in which:

- a student matriculates in 2012 and graduates in 2017
- their institution's data range ends in 2016  

The student satisfies the completion criterion, but their recorded degree status is NA because their degree term exceeds the data range. 

Without special care, such students would add to the count of non-graduates, adversely and unfairly affecting the value of a persistence metric. Therefore, if completing their program is not feasible given the range of data available, students with a degree status of NA are excluded from the analysis.

Feasible completion terminology is illustrated in the figure. Definitions are given below. 

<br>

```{r relationships, echo = FALSE, fig.asp = 5/10}
yyyyt <- c(1988, 2005, 2010)
df <- data.frame(yyyyt = yyyyt, y = 1)

library("ggplot2")
callout_color <- "gray60"
callout_line_size <- 0.3
anno_size <- 3.5 # 3.5 approx 10 point
vert_baseline <- 1.07

ggplot(df, aes(x = yyyyt, y = y)) +

  # vertical dimension lines
  geom_segment(aes(x = 1988, xend = 1988, y = vert_baseline, yend = 1.55),
    color = callout_color, size = callout_line_size
  ) +
  annotate("text",
    x = 1988, y = 0.89, size = anno_size,
    label = "first record", hjust = 1, vjust = 0
  ) +
  annotate("text",
    x = 2005, y = 0.89, size = anno_size,
    label = "matriculation limit", hjust = 1, vjust = 0
  ) +
  geom_segment(aes(x = 2005, xend = 2005, y = vert_baseline, yend = 1.3),
    color = callout_color, size = callout_line_size
  ) +
  annotate("text",
    x = 2010, y = 0.89, size = anno_size,
    label = "data limit", hjust = 0, vjust = 0
  ) +
  geom_segment(aes(x = 2010, xend = 2010, y = vert_baseline, yend = 1.55),
    color = callout_color, size = callout_line_size
  ) +

  # horiz arrows
  annotate("text",
    x = 2000,
    y = 1.55,
    size = anno_size,
    label = "range of institution's data"
  ) +
  geom_segment(aes(x = 1988, xend = 2010, y = 1.5, yend = 1.5),
    color = callout_color,
    size = callout_line_size,
    arrow = arrow(
      type = "closed",
      ends = "both",
      length = unit(2, "mm")
    ),
    arrow.fill = callout_color
  ) +
  annotate("text",
    x = 1992.5,
    y = 1.26,
    size = anno_size,
    # label = "entry terms for feasibility"
    label = "matriculate with\ncompletion feasible",
    hjust = 0,
    vjust = 0.5
  ) +
  geom_segment(aes(x = 1988, xend = 2005, y = 1.25, yend = 1.25),
    color = callout_color,
    size = callout_line_size,
    arrow = arrow(
      type = "closed",
      ends = "both",
      length = unit(2, "mm")
    ),
    arrow.fill = callout_color
  ) +
  annotate("text",
    x = 2007.5,
    y = 1.26,
    size = anno_size,
    label = "x\nyears",
    hjust = 0.5,
    vjust = 0.5
  ) +
  geom_segment(aes(x = 2005, xend = 2010, y = 1.25, yend = 1.25),
    color = callout_color,
    size = callout_line_size,
    arrow = arrow(
      type = "closed",
      ends = "both",
      length = unit(2, "mm")
    ),
    arrow.fill = callout_color
  ) +

  # geom_line(color = callout_color, size = callout_line_size) +
  geom_point(size = 2) +
  scale_x_continuous(limits = c(1980, 2020), breaks = seq(1980, 2020, 10)) +
  scale_y_continuous(limits = c(0.7, 1.7)) +
  labs(
    y = "",
    x = "Start of academic year",
    title = "A representative timeline for feasible completion"
  ) +
  theme_light() +
  theme(
    axis.text.y = element_blank(),
    axis.ticks.y = element_blank(),
    panel.grid.major = element_blank(),
    panel.grid.minor = element_blank()
  )
```

<br>

term encoding
: midfielddata terms are encoded numerically  `YYYYT`, where `YYYY` is the year that starts the academic year and `T` is the term index: 1 (Fall), 2 (Winter, quarter systems), 3 (Spring), or 4-6 (summer sessions).

data range
: The span of terms for which student-record data are available, from the "first record" term to the "data limit" term. Varies by institution.

completion feasibility
: A student may complete their program within the data limit. 
  
matriculation limit 
: The last term a student can matriculate and feasibly complete their program. Defined as $x$ years (typically 6 years) before the data limit. Can be advanced by transfer credit hours.





<br>
<a href="#top">&#9650; top of page</a> 





## How to use `completion_feasible()`

```{r message = FALSE}
# packages used in the vignette
library(midfieldr)
library(midfielddata)
```

A vector of student IDs is required to begin the feasible completion analysis. We choose the set of students ever enrolled in the study programs as the largest possible pool.  

From earlier work in the case study, we have a built-in data set `exa_ever` of the `r length(exa_ever)` student IDs ever enrolled in our case study programs. 

```{r}
# identify the group of students
enrollees_id <- exa_ever

# examine the result
str(enrollees_id)
```

This vector of IDs is the input to `completion_feasible()`, which performs the subsetting for completion feasibility in one call. 

```{r}
# filter IDs for feasible program completion within data limit
enrollees_fc <- completion_feasible(id = enrollees_id)

# examine the result
str(enrollees_fc)
```

In this instance, we started with `r length(enrollees_id)` enrollees. After applying the criteria for feasible completion, we retain `r length(exa_ever_fc)` students. These students either graduated (demonstrating the feasibility of completing their programs before the data limit) or they matriculated no later than their matriculation limits. 

For continuing work with this case study, these IDs are saved as a data set in midfieldr called `exa_ever_fc`. 




<br>
<a href="#top">&#9650; top of page</a> 





## How `completion_feasible()` works

The remainder of the vignette describes the inner workings of  `completion_feasible()`. Its operation can be divided into 5 basic steps: 

1. Subset students with and without degrees 
2. Gather transfer data 
3. Gather institution variables 
4. Advance the matriculation limit 
5. Return the completion-feasible subset of student IDs





### 1. Subset students with and without degrees

We obtain the degree data for the enrollees using `get_status_degrees()` to subset the student degree data (`midfielddegrees` or equivalent) and return the student degree keyed by ID. The values of `degree` are character, e.g., "Bachelor of Science",  or NA for no degree. 

```{r}
# gather student degree data
enrollees_id <- exa_ever
degree_data <- get_status_degrees(midfielddegrees, keep_id = enrollees_id)

# examine the result
str(degree_data)
```

Students with degrees have demonstrated that completing their programs before the data limits was feasible. We can extract their IDs (to be used later) and continue the completion feasibility study with the smaller non-graduate student subset. 

```{r}
# subset students with degrees and without
grad_rows <- !is.na(degree_data$degree)
grads <- degree_data[grad_rows]
nongrads <- degree_data[!grad_rows]

# extract the IDs
grads_id <- grads$id
nongrads_id <- nongrads$id

# examine the result
str(grads_id)
str(nongrads_id)
```



 


### 2. Gather transfer data

If the vector of non-grad IDs is empty, the rest of the algorithm is skipped and we return the vector of grad IDs as the complete set of IDs for feasible completion. 

Otherwise, we continue by calling `get_status_transfers()` for the non-graduates to subset the student attributes data (`midfieldstudents` or equivalent) and return the student matriculation term and transfer credit hours keyed by ID. The values of 
`hours_transfer` are numerical or NA for no transfer hours. 

```{r}
# gather transfer data for non-grads
transfer_data <- get_status_transfers(midfieldstudents, keep_id = nongrads_id)

# examine the result
str(transfer_data)
```

Joining `transfer_data` to `nongrads` (by `id`) yields the complete student information we need. 

```{r}
# join transfer data to non-grads
nongrads <- merge(nongrads, transfer_data, by = "id", all.x = TRUE)

# examine the result
str(nongrads)
```









### 3. Gather institution variables

`get_institution_limits()` provides the following information we need for feasible completion analysis:

- determines upper data limits from the term-attributes data (default is `midfieldterms`)
- calculates `matriculation limit = data limit - span` (default `span`  is 6 years) 

Some data limits are "rounded down" before computing matriculation limits. Summer term data limits are rounded to the preceding Spring; Winter term data limits (institutions on quarter systems) are rounded to the preceding Fall. 

```{r}
# gather data limits and matriculation limits
institution_limits <- get_institution_limits(midfieldterms)

# examine the result
institution_limits
```

We determine the median number of credit-hours per term by institution. We use only students with degrees.  

```{r}
# find median hours per term of students with degrees
hr_per_term <- get_institution_hours_term(midfieldterms, keep_id = grads_id)

# examine the result
hr_per_term
```

And we join `hr_per_term` to `institution_limits` (by `institution`) to conclude our institution data gathering. 

```{r}
# join the two sets of institution data
institutions <- merge(institution_limits,
  hr_per_term,
  by = "institution",
  all.x = TRUE
)

# examine the result
institutions
```

Next we join `nongrads` and `institution_limits` (by `institution`).  

```{r}
# join student and institution data
fc_data <- merge(nongrads, institutions, by = "institution", all.x = TRUE)

# examine the result
str(fc_data)
```

We set NA values of `hours_transfer` to zero so that later, term addition avoids sums with NA. 

```{r}
# set NA transfer hours to zero
rows_to_zero <- is.na(fc_data$hours_transfer)
fc_data[rows_to_zero, hours_transfer := 0]

# examine the result
str(fc_data)
```

Now we're ready to advance the matriculation limit for transfer students where needed. 


 



### 4. Advance the matriculation limit

We convert transfer-credit hours to their equivalent transfer-credit terms.  

```{r}
# estimate the term-equivalent of transfer credit hours
fc_data[, terms_transfer := floor(hours_transfer / median_hr_per_term)]

# examine the result
str(fc_data)
```

There are several columns we can drop to make the other variables easier to review as he analysis proceeds. 

```{r}
# omit columns no longer necessary
fc_data$degree <- NULL
fc_data$data_limit <- NULL
fc_data$institution <- NULL
fc_data$hours_transfer <- NULL
fc_data$median_hr_per_term <- NULL

# examine the result
head(fc_data)
```

Students are typically required to complete at least the final 30-60 credits (about 2 years) in residence at their new institution to earn a degree. Thus for the feasible completion analysis, we limit the transfer terms to 4 or less. 

```{r}
# transfer terms limited to a maximum of 4
rows_to_limit <- fc_data$terms_transfer > 4
fc_data[rows_to_limit, terms_transfer := 4]
```

Next we perform some "term arithmetic" to advance the matriculation limit by the number of terms of credit hours transferred. `term_addition()` adds the number of terms T in the `add_col` argument to the terms YYYYT in the `term_col` argument. 

```{r}
# advance the matriculation limit
fc_data <- term_addition(fc_data,
  term_col = "matric_limit",
  add_col = "terms_transfer"
)

# examine the result
str(fc_data)
```




### 5. Return the completion-feasible subset of student IDs

Finally, we subset the non-graduates, retaining those whose matriculation term is no later than the matriculation limit.  

```{r}
# completion is feasible if the entry term does not exceed
# the matriculation limit
rows_we_want <- fc_data$term_enter <= fc_data$matric_limit
nongrad_fc <- fc_data[rows_we_want]

# examine the result
str(nongrad_fc)
```

If the non-grad ID vector is not empty, we combine it with the grads ID vector we set aside earlier. The result is the vector of IDs of students from the original pool for whom program completion is feasible. 

```{r}
# gather the IDs of all students with completion feasible
nongrad_fc_id <- nongrad_fc$id

# concatenate
feasible_id <- c(grads_id, nongrad_fc_id)
feasible_id <- sort(unique(feasible_id))

# examine the result
str(feasible_id)
```

This result is identical to the result obtained earlier using `completion_feasible()`. 









## References

<div id="refs"></div>







## Appendix

The vignette code chunks are collected below in a condensed script---in this case, in two parts. 

### Script: how to use `completion_feasible()` 

```{r eval = FALSE}
# packages used in the vignette
library("midfieldr")

# filter IDs for feasible program completion within data limit
enrollees_id <- exa_ever
enrollees_fc <- completion_feasible(id = enrollees_id)
```






### Script: how `completion_feasible()` works

The rest of the script shows the details of what happens inside `completion_feasible()`. 

```{r}
library(midfieldr)
library(midfielddata)

# subset students with and without degrees
enrollees_id <- exa_ever
degree_data <- get_status_degrees(midfielddegrees, keep_id = enrollees_id)
grad_rows <- !is.na(degree_data$degree)
grads <- degree_data[grad_rows]
nongrads <- degree_data[!grad_rows]
grads_id <- grads$id
nongrads_id <- nongrads$id

# gather transfer data
transfer_data <- get_status_transfers(midfieldstudents, keep_id = nongrads_id)
nongrads <- merge(nongrads, transfer_data, by = "id", all.x = TRUE)

# gather institution variables
inst_limits <- get_institution_limits(midfieldterms)
hr_per_term <- get_institution_hours_term(midfieldterms, keep_id = grads_id)
institutions <- merge(inst_limits,
  hr_per_term,
  by = "institution",
  all.x = TRUE
)
fc_data <- merge(nongrads,
  institutions,
  by = "institution",
  all.x = TRUE
)
rows_to_zero <- is.na(fc_data$hours_transfer)
fc_data[rows_to_zero, hours_transfer := 0]

# advance the matriculation limit
fc_data[, terms_transfer := floor(hours_transfer / median_hr_per_term)]
rows_to_limit <- fc_data$terms_transfer > 4
fc_data[rows_to_limit, terms_transfer := 4]
fc_data <- term_addition(fc_data,
  term_col = "matric_limit",
  add_col = "terms_transfer"
)

# return the completion-feasible subset of student IDs
rows_we_want <- fc_data$term_enter <= fc_data$matric_limit
nongrad_fc <- fc_data[rows_we_want]
nongrad_fc_id <- nongrad_fc$id
feasible_id <- sort(unique(c(grads_id, nongrad_fc_id)))
```



<br>
<a href="#top"         >&#9650;     top of page </a>     
<a href="../index.html">&#9665;       main page </a> 



