---
title: "Impute FYE starting majors"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Impute FYE starting majors}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
resource_files:
  - ../man/figures/fye-mice-in-1.png
  - ../man/figures/fye-mice-out-1.png
---

```{r setup, echo = FALSE, message = FALSE, purl = FALSE}
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(
  echo = TRUE, # varies from one Rmd to another
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = TRUE,
  purl = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center",
  fig.path = "../man/figures/fye-"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
options(tibble.print_min = 8L, tibble.print_max = 8L)

# normally, purl is FALSE. But in some code chunks, I want purl = TRUE so that the code in the vignette is executed to pass R CMD check. These next few lines set that up. In the code chunk header, add opts.label = 'dopurl'
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_template$set(dopurl = list(purl = TRUE, error = FALSE))
```

Packages used in this article: 

```{r}
library("dplyr")
library("knitr")
library("midfieldr")
library("midfielddata")
library("seplyr")
library("stringr")
```

If you also wish to run the imputation, you will also require:  

```{r}
library("mice")
library("visdat")
```


```{r echo=FALSE}
# used by my_session() 
pkg_names <- c("dplyr", "knitr", "midfieldr", "midfielddata", "seplyr", "stringr", "mice", "visdat")
```

## The need to predict a starting major

Some US institutions have first year engineering (FYE) programs---typically a common first year curriculum that is a prerequisite for declaring an engineering major. For these FYE students, some persistence metrics require us to predict their "starting major." 

**Starting major**: The degree-granting engineering program---Civil Engineering, Electrical Engineering, Mechanical Engineering, etc.---that we predict the student would have declared had they not been required to enroll in FYE. 

 
Predicting the starting major of FYE students takes one of two forms. 

1. In the first instance, we have students who complete an FYE and declare an engineering major. This is the easy case--at the student's first opportunity, they enrolled in an engineering major of their choosing. We use that major as our predicted  starting major. 

2. In the second instance, we have students who, after FYE, do not declare an engineering major. This is the more complicated case---the data provide no information regarding what engineering major the student would have declared originally had the institution not required them to enroll in FYE. For these students, we treat the starting major as missing data and impute a predicted value. 

Note that FYE students are neither undecided nor undeclared. Their institutions admitted them as engineering students. We just don't know their preferred major. We have to predict the starting majors of FYE students to make fair comparisons across programs and institutions. 

## We provide an imputed data set 

We impute these missing values using multiple imputation as 
implemented in the [mice](https://stefvanbuuren.github.io/mice/) package (multivariate imputation via chained equations). The variables used to predict the missing values are institution, race, and sex.  

The process is described in detail starting in the subsequent section. The process does take time---about 30 seconds for imputing the missing values in our FYE data with 5992 observations, 5 variables, and 5 imputations. 

You can skip doing the imputation yourself if you wish. We've done it for you and saved the results. We provide a replacement data set `case_fye` with the ID and predicted starting major of all FYE students in the midfieldr data sets.  

We use these data in the package vignettes whenever an engineering starting major is required. You can do the same.

To access the case data, just load midfieldr and assign `case_fye` to a variable. To distinguish the starting major from other 6-digit CIP codes used in this work, the imputed variable is `start` instead of `cip6`. 

```{r}
# if midfieldr is loaded, assign the bundled data set to a variable
df <- case_fye

# examine the result
glimpse(df)
```

## Preparing the FYE data for imputation

You may skip the rest of the vignette and simply incorporate the imputed data `case_fye` in your analysis if the details of imputation are not important to you at this time. 

If the details are of interest to you, we start by conditioning the data to prepare it for imputation. 

**Step 1.** Extract from `midfieldstudents` the IDs of all students whose matriculation major is FYE.  

```{r}
fye_id <- midfieldstudents %>%
  filter(cip6 %in% c("14XXXX", "14YYYY")) %>%
  select(id) %>%
  unique() %>%
  glimpse()
```

Extract from `midfieldterms` all the term data for these students. `semi_join(x, y)` returns all rows from x where there are matching values in y, keeping just columns from x.

```{r}
all_fye_terms <- semi_join(midfieldterms, fye_id, by = "id") %>%
  select(id, cip6, term) %>%
  glimpse()
```

**Step 2.** Subset the students who declare an engineering major after FYE.

Keeping those terms in which FYE is the declared major, we arrange the rows by ID and *descending* term. Then, grouped by ID, each first row is a student's final FYE term, denoted `end_fye`. 

```{r}
last_fye_terms <- all_fye_terms %>%
  filter(cip6 %in% c("14XXXX", "14YYYY")) %>%
  arrange(id, desc(term)) %>%
  group_by(id) %>%
  filter(row_number() == 1) %>%
  ungroup() %>%
  select(id, end_fye = term) %>%
  glimpse()
```

We join the column `end_fye` to the `all_fye_terms` data frame. `left_join(x, y)` returns all rows from x, and all columns from x and y. All multiple matches between x and y are returned.

```{r}
fye_to_engr <- left_join(all_fye_terms, last_fye_terms, by = "id")
```

Arranging by ID and *ascending*  term and grouped by ID, each first row is a student's first term after FYE. 

```{r}
fye_to_engr <- fye_to_engr %>%
  filter(term > end_fye) %>%
  arrange(id, term) %>%
  group_by(id) %>%
  filter(row_number() == 1) %>%
  ungroup()
```

Because this data frame denotes students transitioning to an engineering major, we filter to keep only those whose CIP starts with "14." For these students, the predicted starting major is their declared engineering major after FYE. 

```{r}
fye_to_engr <- fye_to_engr %>%
  filter(str_detect(cip6, "^14")) %>%
  select(id, cip6) %>%
  glimpse()
```

**Step 3.** The remaining FYE students have an unknown starting major. 

Starting with the IDs of all students in FYE and removing the IDs of students who have declared an engineering major after FYE yields the IDs of students whose starting major will have to be imputed. `anti_join(x, y)` returns all rows from x where there are not matching values in y, keeping just columns from x.

For these students, the predicted starting major after FYE is assumed missing (NA). 

```{r}
fye_to_nonengr <- anti_join(fye_id, fye_to_engr, by = "id") %>%
  mutate(cip6 = NA_character_) %>%
  glimpse()
```

**Step 4.** Combine the two data frames and finish the data preparation.  

Bind the two data frames. 

```{r}
fye_start <- bind_rows(fye_to_engr, fye_to_nonengr) %>%
  glimpse()
```

Extract from `midfieldstudents` the institution names by student ID. `semi_join(x, y)` returns all rows from x where there are matching values in y, keeping just columns from x.

```{r}
inst_id <- semi_join(midfieldstudents, fye_start, by = "id") %>%
  select(id, institution) %>%
  unique() %>%
  glimpse()
```

Join the institutions to the FYE starters data frame and add race and sex using `race_sex_join()`. We assume that these variables are appropriate predictors. 

```{r}
fye_start <- left_join(fye_start, inst_id, by = "id") %>%
  race_sex_join() %>%
  select(id, institution, race, sex, cip6) %>%
  unique() %>%
  glimpse()
```

Convert the character variables to factors to use with mice. The resulting data frame `mi_input` is ready to be operated on by mice. 

```{r}
mi_input <- fye_start %>%
  arrange(institution, race, sex, cip6) %>%
  mutate(institution = as.factor(institution),
    race = as.factor(race),
    sex = as.factor(sex),
    cip6 = as.factor(cip6)) %>%
  glimpse()
```

## Imputing missing data

The mice package [@vanbuuren2011] implements multivariate imputation by chained equations (MICE). MICE is also known as "fully conditional specification" or "sequential regression multiple imputation" and is suitable for categorical variables such as ours [@azur2011]. Our computational procedure follows the approach suggested  by Dhana [-@dhana2017].

The procedure assumes the missing data are "missing at random" (MAR), that is, independent of the variables used to impute the missing values. This is the rationale for using data only from FYE institutions to impute the missing values---the existence if the missing data does depend on the institution type, FYE or non-FYE. Within the FYE data itself, however, we assume that the imputed starting majors are missing at random.  

Use `visdat::vis_miss()` to see the pattern of missing data. As expected, all the missing values are in the `start` column. 

```{r echo = FALSE, eval = FALSE}
# using mice
# md.pattern(mi_input, plot = TRUE)
```

```{r mice-in}
vis_miss(mi_input, cluster = TRUE, sort_miss = TRUE)
```

Initialize parameters. 

```{r}
init  <- mice(mi_input, maxit = 0)
meth  <- init$method
predM <- init$predictorMatrix
```

Identify variables not used as predictors. 

```{r}
predM[, c("id")] <- 0
```

Assign variables not imputed. (In this case, this step could be skipped because a mice default is to not impute variables with zero missing values.) 

```{r}
meth[c("id", "institution", "race", "sex")] <- ""
```

Assign the imputation method. For unordered categorical data with more than two levels, the suggested method is "polyreg" (polytomous regression). 

```{r}
meth[c("cip6")] <- "polyreg"
```

Run the multiple (m = 5) imputations. The seed is set for reproducible results.  On my Windows machine, this imputation takes about 30 seconds. 

```{r warning = FALSE, eval = FALSE}
mi_output <- mice(
  mi_input,
  method = meth,
  predictorMatrix = predM,
  m = 5,
  printFlag = TRUE,
  seed = 20180624
)
```

```{r echo = FALSE}
# load the saved mi_input to avoid running mice() repeatedly
load("R/sysdata.rda")
mi_output <- mi_output
```

## Data set: `case_fye`

Construct the data set after imputation, keeping ID and starting major only. Reformat the start major as a character. The data frame, `case_fye`, is the data mentioned previously provided with the midfieldr package if you prefer not to do your own imputation.

```{r}
case_fye <- mice::complete(mi_output) %>%
  select(id, cip6) %>%
  mutate(cip6 = as.character(cip6)) %>%
  unique() %>%
  glimpse()
```

Total number of FYE students in `midfieldstudents` is `r dim(case_fye)[1]`. 

## Assessing the imputation. 

Confirm there are no missing values using `vis_dat::vis_dat()`. The result shows that all variables are characters and there are no missing values. 

```{r echo = FALSE, eval = FALSE}
# using mice
# md.pattern(case_fye, plot = TRUE)
```

```{r mice-out, message = FALSE}
vis_dat(case_fye, palette = "cb_safe")
```

Examine to what majors and in what numbers the FYE students were assigned. 

```{r results = "hide"}
case_fye %>%
  group_summarise(., "cip6", N = n()) %>%
  arrange(desc(N)) %>%
  left_join(., cip, by = "cip6") %>%
  select(cip4, cip4name, N) %>%
  kable()
```


```{r echo = FALSE}
# internal function to print to html using kable, control font size
library(knitr)
library(kableExtra)
kable2html <- function(...) {
  kable(..., "html") %>%
    kable_styling(font_size = 12)
}
# using kable_styling() for output but conceal from novice user
case_fye %>%
  group_summarise(., "cip6", N = n()) %>%
  arrange(desc(N)) %>%
  left_join(., cip, by = "cip6") %>%
  select(cip4, cip4name, N) %>%
  kable2html()
```






## Session information 

```{r echo = FALSE, comment = NA}
# internal function for session information
my_session(pkg_names)
```

<br>
<a href="#top">&#9650; top of page</a>   

## References

<div id="refs"></div>

<br>
<a href="#top"         >&#9650;     top of page </a>     
<a href="../index.html">&#9665;       main page </a> 

