---
title: "Degree seeking (inner joins)"
date: "`r Sys.Date()`"
link-citations: yes
bibliography: ../inst/REFERENCES.bib
output: rmarkdown::html_vignette
csl: ../inst/information-science-and-technology.csl
vignette: >
  %\VignetteIndexEntry{Degree seeking (inner joins)}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
nocite: |
  @Dowle+Srinivasan:2021:data.table
resource_files: |
---

```{r setup}
#| include: false

# code chunks
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = FALSE,
  comment = "#>",
  error = FALSE
)

# figures
knitr::opts_chunk$set(
  fig.path = "../man/figures/art-020-degree-seeking-",
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)

# inline numbers
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})

# accented text
accent <- function (text_string){
    kableExtra::text_spec(text_string, color = "#b35806", bold = TRUE)
}
```

Student Unit Record data is typically filtered to retain degree-seeking students only. 



## Method

Because the `student` data table contains degree-seeking students only, an inner join between `student` and our working data frame `DT` is in effect a degree-seeking filter on `DT`. 

This vignette in the MIDFIELD workflow.  

1. Planning  
1. Initial processing    
    - Data sufficiency  
    - `r accent("Degree seeking")` 
    - Identify programs  
1. Blocs  
1. Grouping variables  
1. Metrics  
1. Results   

*Caveat:* The Student Unit Records included with midfieldr and midfielddata are practice data, not research data, suitable for practice working with SURs but not for drawing inferences about program attributes or student experiences.




## Load practice data

*Start a script*. If you are writing your own script to follow along, we use these packages in this vignette:

```{r}
# Degree seeking (inner joins)
# midfieldr vignette

# Packages
library("midfieldr")
library("midfielddata")
suppressPackageStartupMessages(library("data.table"))

# Printing options for data.table
options(
  datatable.print.nrows = 55,
  datatable.print.topn = 5,
  datatable.print.class = TRUE
)
```

*Load source data.* MIDFIELD practice data tables as described in [Getting started](art-000-getting-started.html). 

```{r}
# Load practice data sets
data(student, term, package = "midfielddata")
```






## Initial processing

*Optional.* Reduce the dimensions of MIDFIELD data tables. Code reproduced from [Data sufficiency](art-010-data-sufficiency.html). 

```{r}
#| collapse: true

# Optional. Set aside the source files in case they are needed
source_student <- copy(student)
source_term <- copy(term)

# Work with required midfieldr variables only
student <- select_required(student)
term <- select_required(term)

# View top few rows of the result
head(student, n = 3L)

head(term, n = 3L)
```

*Copying.* Prevents operations on `DT` from affecting `term` by reference  [@data.table-reference-semantics].

```{r}
# Working data frame
DT <- copy(term)
```

*Data sufficiency.* Obtain the IDs of all students for whom the data sufficiency criteria are satisfied. Code reproduced from [Data sufficiency](art-010-data-sufficiency.html#case-study).

```{r}
# Filter for data sufficiency
DT <- add_timely_term(DT, term)
DT <- add_data_sufficiency(DT, term)
DT <- DT[data_sufficiency == "include"]

# Drop unnecessary variables
DT <- DT[, .(mcid)]
DT <- unique(DT)
DT[]
```

The result has `r length(unique(DT$mcid))` unique IDs.  








## Inner joins

An *inner join* is a merge operation between two data frame which returns only those records that match on selected variables between the two data frames.

We use inner joins regularly to subset observations of our working data frames by shared columns in another data frame. To illustrate, we will filter our `DT` data by the IDs in the “toy” (exercise) data sets included with midfieldr. Using data.table syntax, we have two approaches: `merge()` and the `X[Y, j]` syntax. 

### Using `merge()`

Using the data.table `merge()` syntax, the `all = FALSE` argument creates the inner join. We first isolate the ID column in `toy_student`. Otherwise, all columns from both data frames would be returned. 

```{r}
# Isolate the IDs of the second data frame
toy_select <- toy_student[, .(mcid)]

# Inner join to filter the observations of the first data frame
merge(DT, toy_select, by = c("mcid"), all = FALSE)
```


```{r}
#| echo: false
x <- merge(DT, toy_select, by = c("mcid"), all = FALSE)
```

The result has `r nrow(x)` observations of `r length(unique(x$mcid))` unique IDs.  

Alternatively, one can include the ID selection within the merge operation.

```{r}
# Isolating the IDs inside the merge function
merge(DT, toy_student[, .(mcid)], by = c("mcid"), all = FALSE)
```



### Using `X[Y, j]`

The second approach---computationally more efficient---uses the data.table `X[Y, j]` syntax. 

```{r}
# A more computationally efficient approach
DT[toy_student, .(mcid), on = c("mcid"), nomatch = NULL]
```

The `nomatch = NULL` argument makes the merge an inner join, the `on` argument defines the shared column to use in matching, and the `j` argument,`.(mcid, cip6)`, defines the columns from both data frames to return. 

The way to read this code out loud is: "Take `DT`, retain rows where  `toy_student$mcid == DT$mcid`, then select columns `mcid` and `cip6`."

For inner joins, `X[Y, j]` and  `Y[X, j]` produce the same result. 

```{r}
# Swap the roles of the two data frames
toy_student[DT, .(mcid), on = c("mcid"), nomatch = NULL]
```

*Confirm results.* We nullify the key automatically assigned by `merge()` and then compare the equality of results. 

```{r}
#| collapse: true

# Three equivalent inner joins
x <- merge(DT, toy_student[, .(mcid)], by = c("mcid"), all = FALSE)
setkey(x, NULL)
y <- DT[toy_student, .(mcid), on = c("mcid"), nomatch = NULL]
z <- toy_student[DT, .(mcid), on = c("mcid"), nomatch = NULL]

# Check equality
all.equal(x, y)
all.equal(x, z)
```


### Selecting columns

In either method, we can select columns from both data frames. The difference being that with `merge()` we select the columns by explicitly subsetting the two data frames.  

```{r}
# Selecting columns from both data frames using merge()
x <- merge(DT[, .(mcid)], toy_student[, .(mcid, institution)], by = c("mcid"), all = FALSE)
setkey(x, NULL)

# Display the result
x[]
```

In the `X[Y, j]` syntax, however, we can list the columns to be returned from both data frames in the `j` list, that is, `.(var1, var2, etc.)`, without subsetting the original two data frames.  

```{r}
#| collapse: true

# Repeat using X[Y, j] syntax
y <- DT[toy_student, .(mcid, institution), on = c("mcid"), nomatch = NULL]

# Check equality
all.equal(x, y)
```





## Case study

Assuming that the working data frame has been filtered for data sufficiency, we filter for degree seeking using an inner join with `student` and retain the ID variable only.  

```{r}
# Filter for degree seeking with an inner join 
DT <- DT[student, .(mcid), on = c("mcid"), nomatch = NULL]

# Display the result
DT[]
```









## Closing

Using data.table syntax, we demonstrate inner joins to add columns from midfielddata tables to a working data frame. 
 






## References

<div id="refs"></div>






## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.  

```{r}
#| eval: false

# Packages
library("midfieldr")
library("midfielddata")
suppressPackageStartupMessages(library("data.table"))

# Printing options for data.table
options(
  datatable.print.nrows = 55,
  datatable.print.topn = 5,
  datatable.print.class = TRUE
)

# Load data sets from midfielddata
data(student, term, package = "midfielddata")

# Filter for data sufficiency
DT <- copy(term)
DT <- add_timely_term(DT, term)
DT <- add_data_sufficiency(DT, term)
DT <- DT[data_sufficiency == "include"]
DT <- DT[, .(mcid, cip6)]
DT <- unique(DT)

# Three equivalent inner joins
x <- merge(DT, toy_student[, .(mcid)], by = c("mcid"), all = FALSE)
setkey(x, NULL)
y <- DT[toy_student, .(mcid, cip6), on = c("mcid"), nomatch = NULL]
z <- toy_student[DT, .(mcid, cip6), on = c("mcid"), nomatch = NULL]
all.equal(x, y)
all.equal(x, z)

# Selecting columns
x <- merge(DT[, .(mcid)], toy_student[, .(mcid, institution)], by = c("mcid"), all = FALSE)
setkey(x, NULL)
y <- DT[toy_student, .(mcid, institution), on = c("mcid"), nomatch = NULL]
all.equal(x, y)

# Degree seeking
DT <- DT[, .(mcid)]
DT <- unique(DT)
DT <- student[DT, .(mcid), on = c("mcid"), nomatch = NULL]
```


```{r}
#| echo: false

# to change the CSS file
# per https://github.com/rstudio/rmarkdown/issues/732
knitr::opts_chunk$set(echo = FALSE)
```

```{css}
blockquote {
    padding:     10px 20px;
    margin:      0 0 20px;
    border-left: 0px
}
caption {
    color:       #525252;
    text-align:  left;
    font-weight: normal;
    font-size:   medium;
    line-height: 1.5;
}
```

