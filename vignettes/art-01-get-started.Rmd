---
title: "Get started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
resource_files:
  - ../man/figures/art-01-get-started-fig1-1.png
nocite: | 
  @Dowle+Srinivasan:2020:data.table
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/art-01-get-started-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
asp_ratio_mw <- function(data, categories) {
  cat1 <- categories[1] # panels
  cat2 <- categories[2] # rows
  nlevel1 <- nlevels(data[, get(cat1)])
  nlevel2 <- nlevels(data[, get(cat2)])
  r <- nlevel1 * nlevel2
  q <- 32
  asp_ratio1 <- (r + 2 * nlevel1) / q
  asp_ratio2 <- (r + 2 * nlevel2) / q
  ratios <- c(asp_ratio1, asp_ratio2)
}
```

## Introduction

In the MIDFIELD practice data, the programs with the greatest numbers of students are Business and Engineering. In this vignette, we compare the number of students ever enrolled in these programs, grouped by sex and race/ethnicity.

We use midfieldr functions to access midfielddata student records. We condition, group and summarize the data, and graph a result. For data carpentry, we use base R and selected syntax from the data.table package. 

### This vignette uses

midfieldr functions 

- `filter_text()` 
- `subset_matriculant()`
- `add_race_sex()`
- `prepare_multiway()` 

midfieldr built-in data sets 

- `cip`  

packages

```{r}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)
```

```{r}
# optional code to control data.table printing
options(datatable.print.nrows = 10, datatable.print.topn = 5)
```

## Gather programs

Instructional programs are encoded by 6-digit CIP codes, included in midfieldr in the `cip` data set.  You may view its help page by running

```
? cip
```

We search `cip` for our program codes using `filter_text()`. You may view its help page by running

```
? filter_text
```

In this example, we assume we have already searched `cip` and found that the codes we want start with 14 (engineering) and 52 (business). Our next step is to pull all 6-digit codes associated with these two programs. 

```{r}
# business
business <- filter_text(cip, keep_text = "^52", keep_col = "cip6")

# add program label
business[, program := "Business"]

# examine the result
business[order(cip6)]
```

Repeat for engineering 

```{r}
# engineering
engineering <- filter_text(cip, keep_text = "^14", keep_col = "cip6")

# add program label
engineering[, program := "Engineering"]

# examine the result
engineering[order(cip6)]
```

Bind the two data frames. 

```{r}
# bind the two data frames
program_group <- rbindlist(list(business, engineering))

# examine the result
program_group[order(program, cip6)]
```

We extract the `cip6` column as a character vector to use later to extract student data by their CIP codes.  

```{r}
# extract a vector of 6-digit CIP codes
group_cip <- program_group$cip6

# examine the result
str(group_cip)
```

## Gather students 

We access the term data to obtain the IDs of all students ever enrolled in these programs.  The result, `DT`, is a data table to which we will add information as we proceed. 

```{r}
# extract unique students ever enrolled from term data
cols_we_want <- c("id", "cip6", "institution")
rows_we_want <- midfieldterms$cip6 %chin% group_cip
DT <- midfieldterms[rows_we_want, ..cols_we_want]
DT <- unique(DT)

# examine the result
DT[order(id)]
```

We update the IDs a number of times, so we extract them from the data table as a character vector.  

```{r}
# initialize an ID vector
latest_id <- DT[, unique(id)]
```

Examining the result shows a vector with `r length(DT[, unique(id)])` unique IDs.

```{r}
# examine the result
str(latest_id)
```

We use `subset_matriculant()` to limit our research to students for whom we have matriculation information. The default matriculation record is `midfieldstudents`.

```{r}
# limit study to students with matriculation data
DT <- subset_matriculant(DT)

# examine the result
DT
```

Update the ID vector.

```{r}
# update the ID vector
latest_id <- DT[, unique(id)]
                    
# examine the result
length(latest_id)
```

In this case, all our enrollees are recorded in the student data set, so the number of students remains the same.  

## Group and summarize

Our results are going to be grouped by program, race/ethnicity, and sex. Here, we join these variables to the working data frame. We use `add_race_sex()` to access the student data to obtain race/ethnicity and sex as self-reported at matriculation. 

```{r}
# join demographics
DT <- add_race_sex(DT)

# examine the result
DT
```

Next we join the program names from `program_group` to our working data frame by `cip6`. Set `all.x = TRUE` for a left-outer join, that is, keeping all the rows of `DT`. 

```{r}
# add program name 
DT <- merge(DT, program_group, by = "cip6", all.x = TRUE)

# examine the result
DT
```

Next we group by our grouping variables variables and count the number of students in each grouping. The count is assigned to the new `ever` column.

```{r}
# assign
grouping_variables <- c("program", "sex", "race")

# aggregate
DT <- DT[, .(ever = .N), keyby = grouping_variables]

# examine the result
print(DT, nrows = 32)
```

## Condition the data for display 

To prepare the results for graphing, we construct a "pre-multiway" version of the data frame. We begin by removing ambiguous levels of race/ethnicity. 

```{r}
# remove ambiguous levels of race/ethnicity
rows_we_want <- !DT$race %chin% c("Unknown", "International", "Other")
DT <- DT[rows_we_want]

# examine the result
unique(DT$race)
```

To protect confidentiality, we omit observations with 10 or fewer students ever enrolled.

```{r}
# protect confidentiality of small populations
DT <- DT[ever > 10]

# examine the result
print(DT, nrows = 20)
```

In intersectional studies, we have found combined race/ethnicity and sex to be a useful category. We unite two columns to create the `race_sex` column. 

```{r}
# create a new category
DT[, race_sex := paste(race, sex, sep = " ")]

# examine the result
DT
```

*Multiway data* are characterized by two categorical variables and one quantitative variable [@Cleveland:1993]. In this example, the two categories are program and race/ethnicity/sex and the quantitative variable is the number of students ever enrolled. 

To structure the data in multiway form, we select the three multiway variables. 

```{r}
# select the three multiway variables
cols_we_want <- c("program", "race_sex", "ever")
DT <- DT[, ..cols_we_want]

# examine the result
DT
```

The second attribute of multiway data is that the levels of the categories are ordered by the median value of the quantitative variable. `prepare_multiway()`  converts the categorical variables to factors and orders the category levels.  

```{r}
# order the category levels
DT <- prepare_multiway(DT)
```

The median values are attributes of the data frame. We can view them as follows. Note that `program` and `race_sex` are now factors ordered by the median enrolled numbers (recorded under the `scores` attribute). 

```{r}
lapply(DT, FUN = attributes)
```

## Graph the results

```{r include = FALSE}
asp_ratio <- asp_ratio_mw(DT, categories = c("program", "race_sex"))
```

We use ggplot2 to graph the multiway data. Rows and panels, from top to bottom, are ordered by decreasing medians. We use a logarithmic scale because the numbers differ by orders of magnitude. In a log base-2 scale, every grid line represents a doubling of the previous grid line.   

```{r fig1, fig.asp = 0.8}
ggplot(data = DT, mapping = aes(x = ever, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  scale_x_continuous(
    trans = "log2",
    breaks = 2^seq(4, 14),
    limits = 2^c(4, 14)
  ) +
  theme(panel.grid.minor.x = element_blank()) +
  labs(
    x = "Number of students (log-2 scale)",
    y = "",
    title = "Ever enrolled in the program",
    caption = "Source: midfielddata"
  )
```

## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval=FALSE}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# gather programs
business <- filter_text(cip, keep_text = "^52", keep_col = "cip6")
business <- business[, program := "Business"]
engineering <- filter_text(cip, keep_text = "^14", keep_col = "cip6")
engineering[, program := "Engineering"]
program_group <- rbindlist(list(engineering, business))
group_cip <- program_group$cip6

# gather students
cols_we_want <- c("id", "cip6", "institution")
rows_we_want <- midfieldterms$cip6 %chin% group_cip
DT <- midfieldterms[rows_we_want, ..cols_we_want]
DT <- unique(DT)
latest_id <- DT[, unique(id)]
DT <- subset_matriculant(DT)
latest_id <- DT[, unique(id)]

# join grouping variables
DT <- add_race_sex(DT)
DT <- merge(DT, program_group, by = "cip6", all.x = TRUE)

# group and summarize
grouping_variables <- c("program", "race", "sex")
DT <- DT[, .(ever = .N), by = grouping_variables]

# condition the data for display
rows_we_want <- !DT$race %chin% c("Unknown", "International", "Other")
DT <- DT[rows_we_want]
DT <- DT[ever > 10]
DT[, race_sex := paste(race, sex, sep = " ")]
cols_we_want <- c("program", "race_sex", "ever")
DT <- DT[, ..cols_we_want]
DT <- prepare_multiway(DT)

# graph results
ggplot(data = DT, mapping = aes(x = ever, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  scale_x_continuous(
    trans = "log2",
    breaks = 2^seq(4, 14),
    limits = 2^c(4, 14)
  ) +
  theme(panel.grid.minor.x = element_blank()) +
  labs(
    x = "Number of students (log-2 scale)",
    y = "",
    title = "Ever enrolled in the program",
    caption = "Source: midfielddata"
  )
```
