---
title: "Get started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
resource_files:
  - ../man/figures/art-01-get-started-fig1-1.png
nocite: | 
  @Dowle+Srinivasan:2020:data.table
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = here::here("man/figures", 
                                            "art-01-get-started-"))
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
asp_ratio_mw <- function(data, categories) {
  cat1 <- categories[1] # panels
  cat2 <- categories[2] # rows
  nlevel1 <- nlevels(data[, get(cat1)])
  nlevel2 <- nlevels(data[, get(cat2)])
  r <- nlevel1 * nlevel2
  q <- 32
  asp_ratio1 <- (r + 2 * nlevel1) / q
  asp_ratio2 <- (r + 2 * nlevel2) / q
  ratios <- c(asp_ratio1, asp_ratio2)
}
```

## Introduction

In the MIDFIELD practice data, the programs with the largest populations are Business and Engineering. In this vignette, we compare the number of students ever enrolled in these programs, grouped by sex and race/ethnicity. The goal is to outline a basic work flow that starts with the tables of student records and concludes with an exploratory graph. For data carpentry, we use base R and selected syntax from the data.table package. 



### This vignette uses

midfieldr functions 

- `add_race_sex()`  
- `filter_by_key()`  
- `filter_text()`  
- `prepare_multiway()`  

packages

```{r}
# packages used
library("midfieldr")
library("midfielddata")
library("data.table")
library("ggplot2")

# optional code to control data.table printing
options(datatable.print.nrows = 10, datatable.print.topn = 5)
```

## Gather programs

Instructional programs are encoded by 6-digit codes available in the `cip` data set loaded with midfieldr. In this example, we assume we have already searched `cip` and found that the codes we want start with 14 (engineering) and 52 (business).

Our next step is to pull all 6-digit codes associated with these two programs using `filter_text()`. The `keep_text` argument gives the character string to be matched, in this case the regular expression `"^52"` (starts with character string 52). The optional  `select` argument indicates columns to select from `cip`, in this case, the column of 6-digit CIP codes. 

```{r}
# business
business <- filter_text(cip, keep_text = "^52", select = "cip6")
```


We add a custom program label to be used later for grouping, summarizing, and graphing. We view the result and, as an option, order the rows by the `cip6` values. 

```{r}
# add program label
business[, program := "Business"]

# examine the result
business[order(cip6)]
```

Repeat for engineering. 

```{r}
# engineering
engineering <- filter_text(cip, keep_text = "^14", select = "cip6")

# add program label
engineering[, program := "Engineering"]

# examine the result
engineering[order(cip6)]
```

Bind the two data frames. 

```{r}
# bind the two data frames
program_group <- rbindlist(list(business, engineering))

# examine the result
program_group[order(program, cip6)]
```


## Gather students 

From the previous data frame, we extract the `cip6` column as a character vector to extract term data by CIP codes.  Syntax note: `x[, var]` is the data.table equivalent to `x$var` in base R. 

```{r}
# extract a vector of 6-digit CIP codes
group_cip <- program_group[, cip6]

# examine the result
str(group_cip)
```

We access the `term` table to obtain the IDs of all students ever enrolled in these programs.  The result, `DT`, is a data table to which we will add information as we proceed. 

```{r}
# extract unique students ever enrolled
cols_we_want <- c("mcid", "cip6", "institution")
rows_we_want <- term[, cip6] %chin% group_cip
DT <- term[rows_we_want, ..cols_we_want]
```

Note for experienced users: The construction we use above for subsetting a data table, i.e., 

```r
    cols_we_want <- ...
    rows_we_want <- ...
    DT[rows_we_want, ..cols_we_want]
```
is less concise than it might be, but it provides clarity for the less experienced R user. To continue, we omit any duplicates and view the result using the option to order the rows by the ID values. 

```{r}
# omit duplicate rows, if any
DT <- unique(DT)

# examine the result
DT[order(mcid)]
```


We update the IDs a number of times, so we extract them from the data table as a character vector.  Syntax note: `x[, unique(var)]` is the data.table equivalent to `unique(x$var)` in base R.

```{r}
# initialize an ID vector
latest_id <- DT[, unique(mcid)]
```

Examining the result shows a vector with `r length(DT[, unique(mcid)])` unique IDs.

```{r}
# examine the result
str(latest_id)
```

The IDs in our current data set `DT` originated in the `term` table, which may include non-degree-seeking students. We use  `filter_by_key()` to retain only those IDs that are also present in the  `student` table, which comprises degree-seeking students only.

```{r}
# limit study to degree-seeking students
DT <- filter_by_key(DT, 
                    match_to = student, 
                    key_col = "mcid")

# examine the result
DT
```

Update the ID vector.

```{r}
# update the ID vector
latest_id <- DT[, unique(mcid)]
                    
# examine the result
length(latest_id)
```

In this case, all our enrollees are recorded in the student data set, so the number of students remains the same.  

## Group and summarize

Our results are going to be grouped by program, race/ethnicity, and sex. Here, we join these variables to the working data frame. We use `add_race_sex()` to access the `student` table to obtain race/ethnicity and sex as self-reported upon admission.  

```{r}
# join demographics
DT <- add_race_sex(DT)

# examine the result
DT
```

Next we join the program names from `program_group` to our working data frame by `cip6`. Set `all.x = TRUE` for a left-outer join, that is, keeping all the rows of `DT`. 

```{r}
# add program name 
DT <- merge(DT, program_group, by = "cip6", all.x = TRUE)

# examine the result
DT
```

Next we group by our grouping variables and count the number of students in each grouping. The count is assigned to the new `ever` column.

```{r}
# assign
grouping_variables <- c("program", "sex", "race")

# aggregate
DT <- DT[, .(ever = .N), keyby = grouping_variables]
```

Like `by`, the `keyby` argument identifies the variables to group by, but `keyby` also orders the rows by the grouping variables. 

```{r}
# examine the result
print(DT, nrows = 32)
```

## Graph the results

To begin conditioning the data for graphing, we remove ambiguous levels of race/ethnicity. 

```{r}
# remove ambiguous levels of race/ethnicity
rows_we_want <- !DT[, race] %chin% c("Other/Unknown", "International", "Other")
DT <- DT[rows_we_want]

# examine the result
DT[, unique(race)]
```

To protect confidentiality, we omit observations with 10 or fewer students ever enrolled.

```{r}
# protect confidentiality of small populations
DT <- DT[ever > 10]

# examine the result
print(DT, nrows = 20)
```

We combine race/ethnicity and sex to form the `race_sex` categorical variable.  

```{r}
# create a new category
DT[, race_sex := paste(race, sex, sep = " ")]

# examine the result
DT
```

*Multiway data* are characterized by two categorical variables and one quantitative variable [@Cleveland:1993]. In this example, the two categories are program and race/ethnicity/sex and the quantitative variable is the number of students ever enrolled. 

Structuring the data in multiway form comprises two steps. In the first step, we select the three multiway variables, omitting all other columns. 

```{r}
# select the three multiway variables
cols_we_want <- c("program", "race_sex", "ever")
DT <- DT[, ..cols_we_want]

# examine the result
DT
```

In the second step, we convert the categorical variables to factors and order their levels by the quantitative variable medians. The midfieldr function for this step is `prepare_multiway()`.   

```{r}
# order the category levels
DT <- prepare_multiway(DT)
```

```{r include = FALSE}
asp_ratio <- asp_ratio_mw(DT, categories = c("program", "race_sex"))
```

We use ggplot2 to graph the multiway data. Rows and panels, from top to bottom, are ordered by decreasing medians. We use a logarithmic scale because the numbers differ by orders of magnitude. In a log base-2 scale, every grid line represents a doubling of the previous grid line.   

```{r fig1, fig.asp = 0.8}
ggplot(data = DT, mapping = aes(x = ever, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  scale_x_continuous(
    trans = "log2",
    breaks = 2^seq(4, 14),
    limits = 2^c(4, 14)
  ) +
  theme(panel.grid.minor.x = element_blank()) +
  labs(
    x = "Number of students (log-2 scale)",
    y = "",
    title = "Ever enrolled in the program",
    caption = "Source: midfielddata"
  )
```

## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval=FALSE}
# packages used
library("midfieldr")
library("midfielddata")
library("data.table")
library("ggplot2")

# gather programs
business <- filter_text(cip, keep_text = "^52", select = "cip6")
business <- business[, program := "Business"]
engineering <- filter_text(cip, keep_text = "^14", select = "cip6")
engineering[, program := "Engineering"]
program_group <- rbindlist(list(engineering, business))
group_cip <- program_group[, cip6]

# gather students
cols_we_want <- c("mcid", "cip6", "institution")
rows_we_want <- term[, cip6] %chin% group_cip
DT <- term[rows_we_want, ..cols_we_want]
DT <- unique(DT)
latest_id <- DT[, unique(mcid)]
DT <- filter_by_key(DT, 
                    match_to = student, 
                    key_col = "mcid")
latest_id <- DT[, unique(mcid)]

# join grouping variables
DT <- add_race_sex(DT)
DT <- merge(DT, program_group, by = "cip6", all.x = TRUE)

# group and summarize
grouping_variables <- c("program", "race", "sex")
DT <- DT[, .(ever = .N), by = grouping_variables]

# condition the data for display
rows_we_want <- !DT[, race] %chin% c("Other/Unknown", "International", "Other")
DT <- DT[rows_we_want]
DT <- DT[ever > 10]
DT[, race_sex := paste(race, sex, sep = " ")]
cols_we_want <- c("program", "race_sex", "ever")
DT <- DT[, ..cols_we_want]
DT <- prepare_multiway(DT)

# graph results
ggplot(data = DT, mapping = aes(x = ever, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  scale_x_continuous(
    trans = "log2",
    breaks = 2^seq(4, 14),
    limits = 2^c(4, 14)
  ) +
  theme(panel.grid.minor.x = element_blank()) +
  labs(
    x = "Number of students (log-2 scale)",
    y = "",
    title = "Ever enrolled in the program",
    caption = "Source: midfielddata"
  )
```
