---
title: "Basic transforms"
vignette: >
  %\VignetteIndexEntry{Basic transforms}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
    rmarkdown::html_vignette:
        highlight: "tango"
        css: ["rmarkdown-source.css", "midfieldr.css"]
bibliography: ../inst/REFERENCES.bib
link-citations: yes
always_allow_html: true
---

```{r child = "../man/rmd/common-setup.Rmd"}
```

```{r}
#| echo: false
knitr::opts_chunk$set(
  fig.path = "../man/figures/art-142-",
  message = FALSE
)
```

## Getting started

As shown in the [Preparing data three ways](art-140-preparing-data-three-ways.html) article.

```{r child = "../man/rmd/preparing-data-setup.Rmd"}
```


## Adding columns

*Task.* &nbsp; Add a column for total SAT score. 

```{r}
columns_we_want <- c("mcid", "sat_math", "sat_verbal", "act_comp")
```

```{r class.source = "base"}
# base R
result_df <- student_df[, columns_we_want, drop = FALSE]
result_df$sat_total <- with(result_df, sat_math + sat_verbal)
```

```{r class.source = "dtbl"}
# data.table
result_dt <- student_dt[, ..columns_we_want]
result_dt[, sat_total := sat_math + sat_verbal]
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- student_tbl %>%
  select(all_of(columns_we_want)) %>%
  mutate(sat_total = sat_math + sat_verbal)
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```


*Comments*

- *base R.* `df$new_column_name` creates the new column. Use `with()` to refer to column names without needing the data frame name and `$`

- *data.table.*  `:=` alters or creates columns "in place". The `data.table` at hand gets altered instead of a new one being created.  

- *dplyr.* New columns are created with `mutate()`. 





## Removing columns

We've already seen one approach to removing columns by writing out the names of the columns we want to keep, then subsetting. Here we show alternatives. The base R approach is another alternative for the data.table and dplyr systems.

*Task.* &nbsp; Using the results from the previous example, remove the SAT math and verbal columns. 

```{r class.source = "base"}
# base R
result_df$sat_math <- NULL
result_df$sat_verbal <- NULL
```

```{r class.source = "dtbl"}
# data.table
result_dt[, c("sat_math", "sat_verbal") := NULL]
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- result_tbl %>%
  select(-sat_math, -sat_verbal)
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```


*Comments*

- *base R.* 

- *data.table.*  Use a vector of column names and `:=` to remove the columns "in place". 

- *dplyr.* Use `select()` with minus signs. 








## Editing column names

*Task.* &nbsp; Using the results from the previous example, rename the columns. 

In each case, we take care to explicitly match old and new names.  

```{r class.source = "base"}
# base R
names(result_df)[names(result_df) == "mcid"] <- "Student"
names(result_df)[names(result_df) == "sat_total"] <- "SAT"
names(result_df)[names(result_df) == "act_comp"] <- "ACT"
```

```{r class.source = "dtbl"}
# data.table
setnames(result_dt,
  old = c("mcid", "sat_total", "act_comp"),
  new = c("Student", "SAT", "ACT")
)
```

```{r class.source = "dplyr"}
# dplyr
lookup <- c("Student" = "mcid", "SAT" = "sat_total", "ACT" = "act_comp")
result_tbl <- result_tbl %>%
  rename(all_of(lookup))
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```


*Comments*

- *base R.* While other approaches work too, this approach ensures that old and new names are explicitly matched. 

- *data.table.*  `setnames()` edits the column names in place. 

- *dplyr.* We construct a vector with names, `lookup`, then `rename()` substitutes the new names for the old names.  










## Split a character column

*Task.* &nbsp; In the `term` data, split the character `term` column into two columns for year and term-code.

In each system, we use the base R `substr()` function to split the `term` character value into a 4-character year in one new column and a 1-character term-code in a new second column. We also drop rows with missing values (if any). 
 
```{r}
columns_we_want <- c("mcid", "term")
```

```{r class.source = "base"}
# base R
result_df <- term_df[, columns_we_want, drop = FALSE]
result_df <- na.omit(result_df)
result_df$year <- substr(result_df$term, 1, 4)
result_df$term_code <- substr(result_df$term, 5, 5)
```

```{r class.source = "dtbl"}
# data.table
result_dt <- term_dt[, ..columns_we_want]
result_dt <- na.omit(result_dt)
result_dt[, c("year", "term_code") := .(substr(term, 1, 4), substr(term, 5, 5))]
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- term_tbl %>%
  select(mcid, term) %>%
  drop_na() %>%
  mutate(year = substr(term, 1, 4)) %>%
  mutate(term_code = substr(term, 5, 5))
```

```{r}
options(datatable.print.topn = 5)
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```

*Comments*

- *base R.* 

- *data.table.*  

- *dplyr.* 


## Convert column class

*Task.* &nbsp; Using the results from the previous example, convert character year to numerical class.

```{r class.source = "base"}
# base R
result_df$year <- as.double(result_df$year)
```

```{r class.source = "dtbl"}
# data.table
result_dt[, year := as.double(year)]
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- result_tbl %>%
  mutate(year = as.double(year))
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```


*Comments*

- *base R.* 

- *data.table.*  

- *dplyr.* 








## Recode column values

*Task.* &nbsp; Using the results from the previous example, recode the term-codes from numbers to academic terms "Fall", "Winter", etc.

"Recoding" typically entails replacing existing values in a column with new, recoded values. For the sake of clarity in this example we assign the new encodings to a new column---not strictly necessary but it makes it easier to check the results.   
 

```{r class.source = "base"}
# base R
result_df$term_name[result_df$term_code == "1"] <- "Fall"
result_df$term_name[result_df$term_code == "2"] <- "Winter"
result_df$term_name[result_df$term_code == "3"] <- "Spring"
result_df$term_name[result_df$term_code == "4"] <- "Summer 1"
result_df$term_name[result_df$term_code == "5"] <- "Summer 2"
result_df$term_name[result_df$term_code == "6"] <- "Summer 3"
```

```{r class.source = "dtbl"}
# data.table
result_dt[, term_name := fcase(
  term_code == "1", "Fall",
  term_code == "2", "Winter",
  term_code == "3", "Spring",
  term_code == "4", "Summer 1",
  term_code == "5", "Summer 2",
  term_code == "6", "Summer 3"
)]
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- result_tbl %>%
  mutate(term_name = case_match(
    term_code,
    "1" ~ "Fall",
    "2" ~ "Winter",
    "3" ~ "Spring",
    "4" ~ "Summer 1",
    "5" ~ "Summer 2",
    "6" ~ "Summer 3"
  ))
```

```{r}
options(datatable.print.topn = 5)
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```

*Comments*

- *base R.* A logical expression in `[]` assigns a recoded value 

- *data.table.* `term_name` is created using `:=` then `fcase()` assigns its  values based on logical expressions operating on `term_code`. 

- *dplyr.* `term_name` is created using `mutate()` then `case_match()` assigns its values by finding matches to the `term_code` values. 










## References

<div id="refs"></div>





```{r child = "../man/rmd/common-closing.Rmd"}
```
