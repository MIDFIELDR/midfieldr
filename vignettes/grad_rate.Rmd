---
title: "Graduation rate metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Graduation rate metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
---

```{r setup, echo = FALSE, message = FALSE, purl = FALSE}
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(
  echo = TRUE, # varies from one Rmd to another
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = TRUE,
  purl = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center",
  fig.path = "../man/figures/grad-rate-"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
# options(tibble.print_min = 8L, tibble.print_max = 8L)

# normally, purl is FALSE. But in some code chunks, I want purl = TRUE so that the code in the vignette is executed to pass R CMD check. These next few lines set that up. In the code chunk header, add opts.label = 'dopurl'
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_template$set(dopurl = list(purl = TRUE, error = FALSE))
```

In the US, the Integrated Postsecondary Education Data System (IPEDS) defines "graduation rate" as the fraction of full-time, first-time, degree/certificate-seeking undergraduate students in a particular year who complete the program in which they matriculate within 150 percent of normal time, i.e., 6 years for a 4-year program [@ipeds2018]. 

The IPEDS definition excludes students who begin college part-time, who enroll mid-year, and who transfer from one institution to another. The American Council on Education (ACE) estimates that this definition of graduation  rate may exclude up to 60% of students at 4-year institutions [@ace2011]. 

So why use the metric? As Cook and Hartle state, 

> So given their complexity, do college graduation rates really matter? In fact, they do because in the eyes of the public, policy makers, and the media, they provide a clear, simple, and logical---if often misleading---number.

So with these caveats in mind, we provide the tools for determining  program graduation rates per the IPEDS definition. 

## Getting started 

Packages used: 

```{r message = FALSE}
library(tidyverse)
library(seplyr)
library(midfieldr)
library(midfielddata)
```

In this article, we show you how to use midfieldr functions to compute program stickiness. Our workflow is: 

- select the programs 
- count the students starting in a program
- if the programs include engineering, impute starting majors for FYE students 
- count the students graduating  
- compute graduation rate 
- create a multiway graph 


## Select the programs to study

The [Selecting programs](selecting_programs.html) vignette describes the  process for obtaining the program codes and names used here. The output of that vignette is saved as a midfieldr case data set, `case_program_group`.

The programs studied in this example are all Engineering programs: Civil, Electrical, Industrial, and Mechanical. 

You may run the code in "Selecting programs" to obtain these data yourself or you can simply load the saved case data. To load the case data, first load midfieldr (we did that above) and the data frame `case_program_group` should be available. 

```{r}
# CIP information saved from an earlier vignette
data("case_program_group")
program_group <- case_program_group
```

Examine the result: there are a total of `r length(unique(program_group[["cip6"]]))` CIP codes for these programs. We have 7 columns: 6 from the `cip` dataset and the one `program` column of labels we added using `cip_label()`. 

```{r echo = -1}
options(tibble.print_min = 12L)
# check the result
program_group
```

When searching the midfielddata datasets for students in these programs, our search functions use the 6-digit CIP codes in the `cip6` variable. To confirm that the search terms are what we expect, we can extract and view the `r length(unique(program_group[["cip6"]]))` unique codes. 

```{r}
unique(program_group[["cip6"]])
```

## gather_start()  

New gather_start() prototype. Keep transfers separate. 

```{r include = FALSE}
gather_start_2 <- function(.data = NULL, series = NULL, ..., imp_data = NULL) {
  
	if (length(list(...)) > 0) {
    stop("midfieldr::gather_start(), unexpected arguments")
  }

  if (is.null(series)) {
    return(.data)
  }

  if (is.null(.data)) {
    .data <- midfielddata::midfieldstudents
  }

  if (is.null(imp_data)) {
    imp_data <- case_fye
  }

  if (isFALSE(is.atomic(series))) {
    stop("midfieldr::gather_start, series must be an atomic vector")
  }

  non_imp <- cip_filter(.data, series = series) %>%
    rename(start = cip6) %>%
    select(id, start)

  imp <- cip_filter(imp_data, series = series)

  if ("cip6" %in% names(imp)) {
    imp <- rename(imp, start = cip6)
  }

  imp <- imp %>%
    select(id, start)

  # any IDs in imputed set are omitted from non-imputed set
  starters <- anti_join(non_imp, imp, by = "id") %>%
    bind_rows(imp)
}

program_cip6 <- program_group[["cip6"]]


starters <- gather_start_2(
  midfieldstudents,
  series = program_cip6,
  imp_data = case_fye
) %>%
  glimpse()

starters <- gather_start_2(series = program_cip6) %>%
  glimpse()
```











In computing graduation rates, the IPEDS definition omits transfer students.

## Issue bin 

- This vignette is still under construction 

## References
