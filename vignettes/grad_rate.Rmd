---
title: "Computing graduation rate"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Computing graduation rate}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
resource_files:
  - ../man/figures/grad-rate-fig1-1.png
---

```{r setup, echo = FALSE, message = FALSE, purl = FALSE}
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(
  echo = TRUE, # varies from one Rmd to another
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = TRUE,
  purl = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center",
  fig.path = "../man/figures/grad-rate-"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
options(tibble.print_min = 5L, tibble.print_max = 12L)

# normally, purl is FALSE. But in some code chunks, I want purl = TRUE so that the code in the vignette is executed to pass R CMD check. These next few lines set that up. In the code chunk header, add opts.label = 'dopurl'
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_template$set(dopurl = list(purl = TRUE, error = FALSE))
```

In the US, the Integrated Postsecondary Education Data System (IPEDS) defines "graduation rate" as the fraction of full-time, first-time, degree/certificate-seeking undergraduate students in a particular year who complete the program in which they matriculate within 150 percent of normal time, i.e., 6 years for a 4-year program [@ipeds2018]. 

The IPEDS definition excludes students who begin college part-time, who enroll mid-year, and who transfer from one institution to another. The American Council on Education (ACE) estimates that this definition of graduation  rate may exclude up to 60% of students at 4-year institutions [@ace2011]. 

So why use the metric? As Cook and Hartle state, 

> So given their complexity, do college graduation rates really matter? In fact, they do because in the eyes of the public, policy makers, and the media, they provide a clear, simple, and logical---if often misleading---number.

So with these caveats in mind, we provide the tools for determining  program graduation rates per the IPEDS definition. 

## Getting started 

Packages used: 

```{r message = FALSE}
library(tidyverse)
library(seplyr)
library(midfieldr)
library(midfielddata)
```

In this article, we show you how to use midfieldr functions to compute program stickiness. Our workflow is: 

- select the programs 
- count the students starting in a program
- if the programs include engineering, impute starting majors for FYE students 
- count the students graduating  
- compute graduation rate 
- create a multiway graph 


## Choose the programs to study

The [Selecting groups of programs](selecting_programs.html) vignette describes the  process for obtaining the program codes and names for four engineering programs: Civil, Electrical, Industrial, and Mechanical. The output of that vignette is saved as a midfieldr case data set, `case_program_group`. You may 

- create the program group by running the code in the vignette 
- or load the saved case data 

The case data are loaded with midfieldr. Simply assign the data to an object  such as `program_group`.  

```{r}
# information saved from an earlier vignette
program_group <- case_program_group
```

Examine the result: there are a total of `r length(unique(program_group[["cip6"]]))` CIP codes for these programs. We have all six columns from the `cip` dataset and the `program` column we added using `cip6_select()`. 

```{r}
# check the result
program_group
```


## starter_filter() 

We use `starter_filter()` to collect all students starting in the programs we are studying. `starter_filter()` has one required argument:

- `series` atomic character vector of 6-digit CIP codes

The `series` argument in this case is an atomic vector of the 6-digit CIP codes in our `program_group`. The function uses these codes to search `midfieldstudents`, the default reference data set. 

```{r}
program_series <- program_group[["cip6"]] %.>%
  unique(.) %.>%
  sort(.) %>%
  print(.)
```

Extract all students from `midfieldstudents` starting in these programs. 

```{r}
students <- starter_filter(series = program_series) %.>%
  glimpse(.)
```

When studying engineering programs, we must account for the [imputed starting majors](https://midfieldr.github.io/midfieldr/articles/imputing_fye.html) of students at institutions with a required first year engineering (FYE) program. 
For the data in this package, the imputed values are saved in the `case_fye` data set. Use `starter_filter()` again with `case_fye` as the optional `reference` argument. 

```{r}
fye <- starter_filter(series = program_series, reference = case_fye) %.>%
  glimpse(.)
```

Then bind the two data frames. 

```{r}
started <- bind_rows(students, fye) %.>%
  glimpse(.)
```

Confirm that the CIPs are the ones we expect and that no student ID has been inadvertently duplicated. 

```{r}
# should be a subset of the program_group CIP we started with
sort(unique(started[["cip6"]]))

# should match the dimension of starters
isTRUE(nrow(started) == length(unique(started[["id"]])))
```

## grad_filter()

Next we gather the graduates in our program group, but restrict ourselves to students who graduate in the same program in which they started. 

We use `grad_filter()` to search the  `midfielddegrees` dataset using the  programs listed in `program_series`.

```{r}
# count students graduating from programs
graduated <- grad_filter(series = program_series) %.>%
  print(.)
```

Open the help page by running 

```r
?grad_filter()
```

## Graduates must be starters

Again, only students who graduate from the program in which they start are counted when computing graduation rate per the IPEDS definition. Thus we keep only those graduates whose IDs appear among the starters. 

Before joining, we first change the `cip6` variable to `start` and `grad` in their respective data frames. 

```{r}
# started <- rename(started, start = cip6)
# graduated <- rename(graduated, grad = cip6)
```

In the join, we keep all starters and we keep only those graduates whose ID is also in the starters. 

```{r}
start_series <- started[["id"]] %.>%
  glimpse(.)

collapse_series <- stringr::str_c(start_series, collapse = "|")

graduated <- dplyr::filter(
  graduated,
  stringr::str_detect(id, collapse_series)
) %.>%
  print(.)
```

Join race and sex to both data frames, and the program names.  

```{r}
# assign the variables for grouping
grouping_variables <- c("program", "race", "sex")

# count students
started <- started %.>%
  race_sex_join(.) %.>%
  left_join(., program_group, by = "cip6") %.>%
  group_summarize(., grouping_variables, "start" = n()) %.>%
  print(.)
graduated <- graduated %.>%
  race_sex_join(.) %.>%
  left_join(., program_group, by = "cip6") %.>%
  group_summarize(., grouping_variables, "grad" = n()) %.>%
  print(.)
```

And join the two data frames

```{r}
# tally stickiness, by group
grad_rate <- left_join(started, graduated, by = grouping_variables) %.>%
  filter(., start > 5) %.>%
  mutate(., rate = round(grad / start, 2)) %.>%
  print(.)
```

Graph

```{r fig1, fig.asp = 2/1.6}
# prepare data for graph
grad_rate_mw <- grad_rate %.>%
  filter(., !race %in% c("Unknown", "International", "Other")) %.>%
  filter(., !sex %in% "Unknown") %.>%
  mutate(., race_sex = str_c(race, sex, sep = " ")) %.>%
  seplyr::select_se(., c("program", "race_sex", "rate")) %.>%
  multiway_order(.)

# graph
ggplot(grad_rate_mw, aes(x = rate, y = race_sex)) +
  facet_wrap(~program, ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Graduation rate (IPEDS definition)", y = "") +
  theme_midfield()
```


## References
