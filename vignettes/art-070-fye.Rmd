---
title: "FYE programs"
date: "`r Sys.Date()`"
link-citations: yes
bibliography: ../inst/REFERENCES.bib
output: rmarkdown::html_vignette
csl: ../inst/information-science-and-technology.csl
vignette: >
  %\VignetteIndexEntry{FYE programs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
nocite: |
resource_files: |
---

```{r setup}
#| include: false

# code chunks
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = FALSE,
  comment = "#>",
  error = FALSE
)

# figures
knitr::opts_chunk$set(
  fig.path = "../man/figures/art-060-multiway-charts-",
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)

# inline numbers
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
```

At some US institutions, engineering students are required to complete a  First-Year Engineering (FYE) program as a prerequisite for declaring an engineering major. Administratively, degree-granting engineering programs such as Electrical Engineering or Mechanical Engineering treat their incoming post-FYE students as their "starting" cohorts.  However, when computing a metric that requires a count of starters---graduation rate, for example---FYE records must be treated with special care to avoid a miscount. 


## Avoiding a starter miscount

To illustrate the potential for miscounting starters, suppose we wish to calculate a graduation rate for Mechanical Engineering (ME). Students starting in ME constitute the starting pool and the fraction of the pool graduating in ME is the graduation rate. 

At FYE institutions, an ME program would typically define their starting pool as the post-FYE cohort entering their program. This may be the best information available, but it invariably undercounts starters by failing to account for FYE students who do not transition (post-FYE) to degree-granting engineering programs---students who may have left the institution or switched to other (non-engineering) majors. In either case, these students would have been starters in degree-granting engineering majors---some of them in ME---had they not been required to first complete FYE. By neglecting these students, the count of ME starters is artificially low resulting in an ME graduation rate that is artificially high. The same is true for every degree-granting engineering discipline in an FYE institution. 

Because of the special nature of FYE programs, we cannot address starter miscounts by grouping FYE students with those admitted with "undecided" or  "unknown" CIP codes---FYE students are neither. They were admitted as Engineering majors (2-digit CIP 14). We simply don't know to which degree-granting program (6-digit CIP) they intended to transition.  
 
Therefore, to avoid miscounting starters at FYE institutions, we have to predict the 6-digit CIP codes of the degree-granting engineering programs that  FYE students would have declared had they not been required to enroll in FYE. 


## Definitions

FYE

: First-Year Engineering program, a common-first-year curriculum that is a prerequisite for declaring an engineering major at some US institutions. 

switcher

: A student who changes majors. In dealing with FYE records, we are concerned with switchers into or out of Engineering at the 2-digit program level (CIP 14). 

FYE proxy

: The degree-granting engineering program we predict an FYE student would have declared had they not been required to enroll in FYE. The proxy, a 6-digit CIP code, acts as a substitute for the FYE CIP code as needed. Applies to students admitted to Engineering in their first term as well as switchers into Engineering.

multivariate imputation

: Method of imputing missing categorical data, in this case, the 6-digit CIP codes of FYE proxy programs. 





## Method

We describe two approaches for treating FYE student records: using a prepared FYE proxy data set; and creating an FYE proxy data set. 

**Using prepared FYE proxies.** The `fye_proxy` data set included with midfieldr contains predicted starting programs for all FYE students in the practice data tables. Only suitable for use with midfielddata practice data.  

**Creating FYE proxies.** We apply `prep_fye_mice()` to the `student` and `term` data tables to construct a data frame suitable for imputation using the mice R package. Applied to the midfielddata practice data, users can reproduce the `fye_proxy` data set. Applied to  MIDFIELD research data, users can construct their own FYE proxies. 

If you are writing your own script to follow along, we start with these packages:

```{r}
# Packages
library("midfieldr")
library("midfielddata")
suppressPackageStartupMessages(library("data.table"))

# Only if creating your own FYE proxies
library("mice")

# Printing options for data.table
options(
  datatable.print.nrows = 17,
  datatable.print.topn = 5,
  datatable.print.class = TRUE
)
```







## Using prepared FYE proxies

The prepared proxies can be used with the midfielddata practice data only.  

To illustrate our procedure for using the prepared FYE proxies, we start with the four engineering programs of the case study developed in earlier vignettes. As if we were *preparing* to compute graduation rates, we *identify starters* in Civil, Electrical, Industrial/Systems, and Mechanical Engineering.

In this example, the basic steps are to start with all students ever enrolled in the case study programs, filter for first-term information only, replace first-term FYE program codes with the prepared FYE proxies, and filter the result to retain starters in the case study programs.  

### Population

The data set `study_mcid` (included with midfieldr) contains the IDs of students ever enrolled in four programs (Civil, Electrical, Industrial/Systems, and Mechanical Engineering) after filtering for data sufficiency, degree seeking, and program.

```{r}
# Case study IDs of ever enrolled
study_mcid
```

The data set `study_program_labels` (included with midfieldr) contains the CIP codes and abbreviated labels for the case study programs. 

```{r}
study_program_labels
```

The `fye_proxy` data set (also included with midfieldr) contains the proxy programs for *all FYE students* (including switchers) in the practice data set. The `proxy` variable gives the predicted 6-digit CIP code.  (The code that produced the proxy data set is described in detail below in the *Creating FYE proxies* section.)

```{r}
# Predicted starting programs for practice data
fye_proxy
```

We use the midfielddata `term` table for its `term` and `cip6` variables, keyed by student ID. 

```{r}
# Load data from midfielddata
data(term)

# Display selected columns
term[, .(mcid, term, cip6)]
```

You can view the help pages (and data dictionaries) by running

```{r}
#| eval: false

# Run in Console
? study_mcid
? study_program_labels
? fye_proxy
? term
```

### Start with IDs

**Joining.** Starting with the IDs as our working data frame, we join the `term` and `cip6` columns from the `term` table, creating one row per term per student ID. 

```{r}
# Create working data frame
DT <- copy(study_mcid)

# Left-outer join, term into IDs
DT <- term[DT, .(mcid, term, cip6), on = c("mcid")]

# Display the result
DT[]
```

**Filtering.**  To identify starters for a graduation rate calculation, we are interested in the programs to which students are first admitted. Therefore, we order the rows by ID and term, then filter to retain their first term only. The resulting `cip6` column contains students' first-term CIP program codes. 

```{r}
# Retain initial term
setorderv(DT, cols = c("mcid", "term"))
DT <- DT[, .SD[1], by = c("mcid")]

# Display the result
DT[]
```

**Data set-aside.** These data are set aside under a different name for use in the section on *Summarizing FYE proxies*. 

```{r}
# Create an intermediate data set for later analysis
direct_start <- DT[cip6 != "140102", .(mcid, cip6)]
```

### Process the proxies 

**Subsetting.**  Switchers are excluded from a graduation rate metric, so we have to prevent switcher proxies (if any) from being joined to the working data frame. We extract a subset of the data containing first-term FYE students only. 

```{r}
# Create an FYE subset of first-term students
first_term_fye_mcid <- DT[cip6 == "140102", .(mcid)]

# Display the result
first_term_fye_mcid[]
```

**Joining.** We join the FYE proxies to the first-term-FYE subset. 

```{r}
# Join FYE proxies to first-term-FYE subset
fye <- fye_proxy[first_term_fye_mcid, .(mcid, proxy), on = c("mcid")]

# Display the result
fye[]
```

**Joining.** Rejoin the subset to add the `proxy` column to the working data frame. NA values in the `proxy` column indicate non-FYE students. 

```{r}
# Join the proxies to the working data frame
DT <- fye[DT, .(mcid, cip6, proxy), on = c("mcid")]

# Display the result
DT[]
```


### Identify starters

**Create a variable.**  Predicted starting programs for FYE students are in the `proxy` column. Actual, recorded starting programs for non-FYE students are in the `cip6` column. Create the `start` column to combine the two. 

```{r}
# Combine all starting CIPs
DT[, start := fcase(
  cip6 == "140102", proxy,
  cip6 != "140102", cip6
)]

# Display the result
DT[]
```

**Joining.** We join the program abbreviations for the case study. A `program` value of NA indicates a starting program other than one of the four in the case study. 

```{r}
# New memory location for labels
join_labels <- copy(study_program_labels)

# Left-outer join, match by the CIPs in start
setnames(join_labels, old = "cip6", new = "start")
DT <- join_labels[DT, .(mcid, start, program), on = c("start")]

# Display the result
DT[order(program)]
```

**Filtering.** We retain students starting in one of the four majors in the case study.

```{r}
# Keep the four programs only
DT <- DT[!is.na(program)]

# Display the result
DT[order(program)]
```

### Conclusion

This data frame is the starting pool for computing graduation rates for the case study programs. 

This step concludes the procedural outline for using FYE proxies with the midfielddata practice data. 

**Data set-aside.** These data too are set aside under a different name for use in the section on *Summarizing FYE proxies*. 

```{r}
# Create an intermediate data set for later analysis
predicted_start <- copy(DT)
```







## Creating FYE proxies

This section is optional if you are using the midfielddata practice data sets but required if you are using MIDFIELD research data.  

The procedure has two steps: 

1. Use `prep_fye_mice()` from the midfieldr package to predict some of the FYE proxy CIPs, treat the remainder as missing values, and structure the data frame for imputation. 

2. Use `mice()` from the mice package to impute the 6-digit CIP missing values. 








### Population

We start with the `student` and `term` data tables, retaining all rows from your source data. 

```{r}
# Load data sets from midfielddata
data(student, term)
```

You can view the help pages (and data dictionaries) by running

```{r}
#| eval: false

# Run in Console
? student
? term
```







### `prep_fye_mice()`

This function prepares FYE data for multivariate imputation. You can view the help page by running

```{r}
#| eval: false

# Run in Console
? prep_fye_mice
```
 
**Arguments:**

midfield_student

: Data frame of student observations, keyed by student ID. Default is `student`. Required variables are `mcid`, `race`, and `sex`. Use all rows of your source `student` data table.

midfield_term	

: Data frame of term observations keyed by student ID. Default is `term`.  Required variables are `mcid`, `institution`, `term`, and `cip6`. Use all rows of your source `term` data table. 

fye_codes

: Optional character vector of 6-digit CIP codes assigned to FYE programs.  Default is "140102". 

**Usage.** The following implementations yield identical results, 

```{r}
#| collapse: true

# Required arguments in order and explicitly named
x <- prep_fye_mice(midfield_student = student, midfield_term = term)

# Required arguments in order, but not named
y <- prep_fye_mice(student, term)

# Using the implicit defaults
z <- prep_fye_mice()

# Equality test between the data tables
all.equal(x, y)
all.equal(x, z)
```

Create the pre-processed FYE data frame. The function extracts all terms for all FYE students and sorts them into two categories:

1. Students who complete an FYE and declare an engineering major. This is the easy case---at the student's first opportunity, they enrolled in an engineering program of their choosing. The CIPs of these programs are the `cip6` values  returned by `prep_fye_mice()`. 

2. Students who, after FYE, do not declare an engineering major. This is the more complicated case---the data provide no information regarding what engineering program the student would have declared originally had the institution not required them to enroll in FYE. For these students, `prep_fye_mice()` assigns a `cip6` value of NA. 

```{r}
# Create the working data frame
fye <- prep_fye_mice(student, term)

# Display the result
fye[]
```

The NA `cip6` entries are the missing data to be imputed using `mice()`.  
 
```{r}
#| collapse: true

# Number of students ever enrolled in an FYE program
length(unique(fye$mcid))

# Number of missing values to be imputed
sum(is.na(fye$cip6))
```

**Set aside intermediate data.** These data are also set aside for use in the section on *Summarizing FYE proxies*. 

```{r}
# Create an intermediate data set for later analysis
post_fye_start <- fye[, .(mcid, cip6)]
post_fye_start <- post_fye_start[!is.na(cip6)]
```





### `mice()`

The mice package [@vanBuuren+Oudshoorn:2011] implements multivariate imputation by chained equations (MICE). MICE is also known as "fully conditional specification" or "sequential regression multiple imputation" and is suitable for categorical variables such as ours [@azur2011]. Our computational procedure follows the approach suggested  by Dhana [-@dhana2017].

The procedure assumes the missing CIP data---the NA values in the prepared data frame---are "missing at random" (MAR), that is, independent of the variables used to impute the missing values. This is the rationale for using data only from FYE institutions to impute the missing values---the existence of the missing data does depend on the institution type, FYE or non-FYE. Within the FYE data itself, however, we assume that the imputed starting majors are missing at random. 

**Framework.** Our first use of `mice()` is to examine the imputation framework by calling the function with zero iterations on the `fye` data frame. (A warning may appear in your console. It can be ignored.) `mice()` produces a "multiply-imputed data set", an R object of class "mids".

```{r}
# Imputation framework
framework <- mice(fye, maxit = 0)

# Display the results
framework
```

**Imputation methods.** We look more closely at two elements of this framework. The first is the imputation method vector. 

```{r}
# Imputation method
method_vector <- framework[["method"]]

# Display the results
method_vector
```

The "polyreg" imputation method (polytomous logistic regression) is appropriate for  data, like ours, comprising unordered categorical variables. Variable `cip6` is imputed using the polyreg method; the other variables, being predictors, are not imputed, thus their methods are empty.  

Had the method not been correctly assigned, we would assign it as follows, 

```{r}
# Manually assign the variable(s) being imputed
method_vector[c("cip6")] <- "polyreg"

# Manually assign the variable(s) not being imputed
method_vector[c("mcid", "institution", "race", "sex")] <- ""

# Display the results
method_vector
```

**Predictor matrix.** The second element to review is the predictor matrix. A row label identifies the variable being predicted; the columns indicate the predictor variables.  

```{r}
# Imputation predictor matrix
predictor_matrix <- framework[["predictorMatrix"]]

# Display the results
predictor_matrix
```

However, only those variables assigned a method are imputed. In our case, the only variable to be imputed is `cip6`, so the only row of this matrix that gets used is the last row. 

```{r}
# Predictor row for this example
predictor_matrix["cip6", ]
```

What the zeros and ones tell us is that `cip6` is going to be predicted by institution, race, and sex. 

Had the default setting been incorrect, we can set them manually. Again, note that the bottom row is the only row we need because only the `cip6` variable is being imputed. 

```{r}
# Manually assign zero columns
predictor_matrix[, c("mcid", "cip6")] <- c(0, 0, 0, 0, 0)

# Manually assign predictor columns
predictor_matrix[, c("institution", "race", "sex")] <- c(0, 0, 0, 0, 1)

# Display the result
predictor_matrix
```

**Imputing missing values.** The three essential arguments for `mice()` are the `fye` data frame, the `method_vector`, and the `predictor_matrix`. The default `seed` argument is NULL, but by setting the seed as shown the vignette results are reproducible. Setting `printFlag = TRUE` displays progress in the console. 

```{r}
#| echo: false

# load the saved fye_mids to avoid running mice() repeatedly
load(here::here("R", "sysdata.rda"))
```

```{r}
#| eval: false

# imputation
fye_mids <- mice(
  data = fye,
  method = method_vector,
  predictorMatrix = predictor_matrix,
  seed = 20180624,
  printFlag = TRUE
)
```

```{r}
# output in console with printFlag = TRUE
# >  iter imp variable
# >   1   1  cip6
# >   1   2  cip6
# >   1   3  cip6
# >   1   4  cip6
# >   1   5  cip6
# >   ---
# >   5   1  cip6
# >   5   2  cip6
# >   5   3  cip6
# >   5   4  cip6
# >   5   5  cip6
```

**Extract the result.** We apply `mice::complete()` to extract the data from the `mids` object. The missing data have been replaced by imputed values. 

```{r}
# Extract data from the mids object
fye <- mice::complete(fye_mids)

# Convert to data.table structure
setDT(fye)

# Display the result
fye <- fye[order(mcid)]
fye[]
```

**Detach `mice()`.** Because the mice package masks the base R `rbind()` and `cbind()` functions (and the tidyr `complete()` function if you are using tidyr), we unload the package now that we're done with it. 

```{r}
# Detach package
detach("package:mice", unload = TRUE)

# Revert to default random number generation
set.seed(NULL)
```







### Post-processing

**Select columns.** To use the result, we need only two columns: IDs and the the predicted starting programs..

```{r}
# Subset the data
fye <- fye[, .(mcid, cip6)]

# Display the result
fye
```

**Convert & rename.** We convert the CIP codes from factor to character and change the CIP variable name to `proxy` to distinguish it from other `cip6` variables in the data tables.

```{r}
# Convert factors
fye[, cip6 := as.character(cip6)]

# Identify the results as FYE proxies
setnames(fye, old = "cip6", new = "proxy")

# Display the result
fye
```

```{r}
#| echo: false
# fye_proxy <- copy(fye)
# usethis::use_data(fye_proxy, overwrite = TRUE)
```

This process is how the built-in data set `fye_proxy` was constructed, using the same random number seed that we used above. To confirm they are identical, 

```{r}
#| collapse: true

# Verify that result matches the built-in data set
all.equal(fye, fye_proxy)
```



### Conclusion

If we were using these results to contribute to a graduation rate calculation, we would follow the steps outlined in the *Using prepared FYE proxies* section, substituting our `fye` data frame for the `fye_proxy` data provided with midfieldr. 

For a given set of `student` and `term` data tables, the imputation has to be performed only once. The results should be saved as a data file, similar to `fye_proxy` data set used with the midfielddata practice data. In data.table format one could write, for example, 

```{r}
#| eval: false

# Write data to file
fwrite(fye, file = "data/my_fye_proxy.csv")
```







## Summarizing the FYE proxies

Here we summarize the final FYE proxy data set to see how many students our algorithm assigned to which engineering majors. Start by extracting the unique set of CIP codes from the proxy data set. 

```{r}
# Identify unique CIP codes in the proxy data
proxy_cips <- sort(unique(fye_proxy$proxy))

# Display the results
proxy_cips
```

Obtain the program names from the `cip` data set (provided with midfieldr). We use the 4-digit names that in engineering generally represent  department-level programs. 

```{r}
# Obtain the 4-digit program names corresponding to these codes
proxy_program_names <- filter_search(cip, keep_text = proxy_cips)
proxy_program_names <- proxy_program_names[, .(cip6, program = cip4name)]
proxy_program_names[]
```

Join these names to the proxy data set, summarize by program, and order the rows by descending N.  

```{r}
# Join these program names to the proxy data
proxy_programs <- proxy_program_names[fye_proxy[, .(cip6 = proxy)], .(program), on = c("cip6")]

# Count by program and order rows in descending magnitude
proxy_programs <- proxy_programs[, .N, by = c("program")]
setorderv(proxy_programs, order = -1, cols = c("N"))

# Display the result
proxy_programs[]
```

The order of these majors is consistent with our expectations. For example, the National Science Foundation (NSF) reports that the 2012 ranking of majors by enrollment in the US has Mechanical Engineering first, followed by Electrical, Civil, Chemical, Industrial, Aerospace, and Materials Engineering [@NSF:2014]. 

The NSF data table does not break out Computer Engineering as a separate observation---if we can assume that the NSF combined Computer Engineering with Electrical Engineering (a practice followed at many Engineering colleges), then combining them in our data produces the following, 

```{r}
# Combine Electrical and Computer Engineering
new_row <- data.table(
  program = "Electrical/Computer Engineering",
  N = sum(proxy_programs[program %ilike% "Electrical|Computer", N])
)

# New location in memory
rev_proxy_programs <- copy(proxy_programs)

# Drop the separate Electrical and Computer rows
rev_proxy_programs <- rev_proxy_programs[!program %ilike% "Electrical|Computer"]

# Bind the new row and order
rev_proxy_programs <- rbindlist(list(rev_proxy_programs, new_row))
setorderv(rev_proxy_programs, c("N"), -1)

# Display the result
rev_proxy_programs[1:6]
```

These are the same top six programs as the NSF list and the first four majors are in the same order. Aerospace and Industrial Engineering (rows 5 and 6) have swapped places compared to the NSF report. 

We conclude that the imputation is credible at least to the extent that the ranking of the majors is consistent with expectations. Additional work would be required to compare summaries by institution, race, or sex. 







## Quantifying starter miscounts

The main goal of predicting FYE proxies is to prevent starter miscounts. Here, we use the three "set-aside" data sets developed earlier to assess the potential for miscounts if FYE records are not treated as recommended. The three data sets are:

`direct_start`

: First-term students admitted directly into one of the four case study programs; excludes FYE students. 

`post_fye_start`

: First-term direct starters plus a subset of the proxies returned by `prep_fye_mice()`, i.e., students who transition post-FYE to one of the case study programs. 

`predicted_start`

: First-term direct starters plus proxies returned by `mice()`, i.e., all FYE students predicted as starters in one of the case study programs. 

Beginning with the `direct_start` data, we add the four program labels by matching the CIP codes, filter for the four case study programs, and summarize by program. 

```{r}
# Join the program abbreviations
direct <- study_program_labels[direct_start, .(cip6, program), on = "cip6"]

# Retain the case study programs
direct <- direct[!is.na(program)]

# Count by program
direct <- direct[, .(direct = .N), by = "program"]

# Display the result
direct[]
```

Post-FYE starters must be limited to non-switchers, that is, those with IDs in the `first_term_fye_mcid` data frame developed earlier. 

```{r}
# Inner join between post-FYE and first-term FYE IDs
post_fye <- first_term_fye_mcid[post_fye_start, .(mcid, cip6), on = c("mcid"), nomatch = NULL]

# Repeat the program abbreviation and filter steps
post_fye <- study_program_labels[post_fye, .(mcid, cip6, program), on = c("cip6")]
post_fye <- post_fye[!is.na(program)]
post_fye <- post_fye[, .(add_post_fye = .N), by = "program"]
post_fye[]
```

These students are all FYE starters. Our definition for these data includes the direct-starters in `direct`. We add the two columns to obtain the desired result. 

```{r}
# Join the two results
DT <- merge(direct, post_fye, by = "program", all.x = TRUE)

# Add the direct admissions to the post-FYE starters
DT[, add_post_fye := add_post_fye + direct]

# Display the result
DT[]
```

Lastly, summarize the predicted start data from `mice()` and join to the results. 

```{r}
# Count by program
predicted <- predicted_start[, .(add_imputed = .N), by = "program"]

# Join
DT <- merge(DT, predicted, by = "program", all.x = TRUE)

# Display the result
DT[]
```

Comparing the columns, we see that the imputed totals are identical to the direct admissions plus post-FYE starters in all but one case (ME). And in ME the difference between the two columns is only one student. That these values are practically identical is not a "research" finding---we are, after all, using practice data and only a four-program subset at that. 

To quantify the potential for miscounts, we compute the percentage of starters represented by the FYE starters.  

```{r}
# Fraction of starters from FYE
DT[, pct_fye := round(100 * (add_imputed - direct) / add_imputed, 1)]

# Display the result
DT[]
```

The results indicate (for these practice data at least) an under-count of 17% to 30% for degree-granting programs that exclude FYE proxies from their count of starters.  




















## References

<div id="refs"></div>






## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script. 

```{r}
#| eval: false

# Packages
library("midfieldr")
library("midfielddata")
suppressPackageStartupMessages(library("data.table"))

# Only if creating your own FYE proxies
library("mice")

# Printing options for data.table
options(
  datatable.print.nrows = 17,
  datatable.print.topn = 5,
  datatable.print.class = TRUE
)

# Using prepared FYE proxies
data(term)

# Start with IDs
DT <- copy(study_mcid)
DT <- term[DT, .(mcid, term, cip6), on = c("mcid")]
setorderv(DT, cols = c("mcid", "term"))
DT <- DT[, .SD[1], by = c("mcid")]
direct_start <- DT[cip6 != "140102", .(mcid, cip6)]

# Process the proxies
first_term_fye_mcid <- DT[cip6 == "140102", .(mcid)]
fye <- fye_proxy[first_term_fye_mcid, .(mcid, proxy), on = c("mcid")]
DT <- fye[DT, .(mcid, cip6, proxy), on = c("mcid")]

# Identify starters
DT[, start := fcase(
  cip6 == "140102", proxy,
  cip6 != "140102", cip6
)]
join_labels <- copy(study_program_labels)
setnames(join_labels, old = "cip6", new = "start")
DT <- join_labels[DT, .(mcid, start, program), on = c("start")]
DT <- DT[!is.na(program)]
predicted_start <- copy(DT)

# Creating FYE proxies
data(student, term)

# prep_fye_mice()
fye <- prep_fye_mice(student, term)
post_fye_start <- fye[, .(mcid, cip6)]
post_fye_start <- post_fye_start[!is.na(cip6)]

# mice() method
framework <- mice(fye, maxit = 0)
method_vector <- framework[["method"]]
method_vector[c("cip6")] <- "polyreg"
method_vector[c("mcid", "institution", "race", "sex")] <- ""

# mice() predictor
predictor_matrix <- framework[["predictorMatrix"]]
predictor_matrix[, c("mcid", "cip6")] <- c(0, 0, 0, 0, 0)
predictor_matrix[, c("institution", "race", "sex")] <- c(0, 0, 0, 0, 1)

# mice()
fye_mids <- mice(
  data = fye,
  method = method_vector,
  predictorMatrix = predictor_matrix,
  seed = 20180624,
  printFlag = TRUE
)
fye <- mice::complete(fye_mids)
setDT(fye)
detach("package:mice", unload = TRUE)
set.seed(NULL)

# Post-processing
fye <- fye[, .(mcid, cip6)]
fye[, cip6 := as.character(cip6)]
setnames(fye, old = "cip6", new = "proxy")
fwrite(fye, file = "data/my_fye_proxy.csv")

# Summarizing the FYE proxies
proxy_cips <- sort(unique(fye_proxy$proxy))
proxy_program_names <- filter_search(cip, keep_text = proxy_cips)
proxy_program_names <- proxy_program_names[, .(cip6, program = cip4name)]
proxy_programs <- proxy_program_names[fye_proxy[, .(cip6 = proxy)], .(program), on = c("cip6")]
proxy_programs <- proxy_programs[, .N, by = c("program")]
setorderv(proxy_programs, order = -1, cols = c("N"))

# Compare to NSF report
new_row <- data.table(
  program = "Electrical/Computer Engineering",
  N = sum(proxy_programs[program %ilike% "Electrical|Computer", N])
)
rev_proxy_programs <- copy(proxy_programs)
rev_proxy_programs <- rev_proxy_programs[!program %ilike% "Electrical|Computer"]
rev_proxy_programs <- rbindlist(list(rev_proxy_programs, new_row))
setorderv(rev_proxy_programs, c("N"), -1)

# Quantifying starter miscounts
direct <- study_program_labels[direct_start, .(cip6, program), on = "cip6"]
direct <- direct[!is.na(program)]
direct <- direct[, .(direct = .N), by = "program"]
post_fye <- first_term_fye_mcid[post_fye_start, .(mcid, cip6), on = c("mcid"), nomatch = NULL]
post_fye <- study_program_labels[post_fye, .(mcid, cip6, program), on = c("cip6")]
post_fye <- post_fye[!is.na(program)]
post_fye <- post_fye[, .(add_post_fye = .N), by = "program"]
predicted <- predicted_start[, .(add_imputed = .N), by = "program"]

DT <- merge(direct, post_fye, by = "program", all.x = TRUE)
DT[, add_post_fye := add_post_fye + direct]
DT <- merge(DT, predicted, by = "program", all.x = TRUE)
DT[, pct_fye := round(100 * (add_imputed - direct) / add_imputed, 1)]
```

