---
title: "Starters and FYE programs"
date: "`r Sys.Date()`"
link-citations: yes
bibliography: ../inst/REFERENCES.bib
output: rmarkdown::html_vignette
csl: ../inst/information-science-and-technology.csl
vignette: >
  %\VignetteIndexEntry{Starters and FYE programs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
nocite: |
resource_files: |
---

```{r setup}
#| include: false

# code chunks
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = FALSE,
  comment = "#>",
  error = FALSE
)

# figures
knitr::opts_chunk$set(
  fig.path = "../man/figures/art-070-fye-programs-",
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)

# inline numbers
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
```

At some US institutions, engineering students are required to complete a  First-Year Engineering (FYE) program as a prerequisite for declaring an engineering major. Administratively, degree-granting engineering programs such as Electrical Engineering or Mechanical Engineering treat their incoming post-FYE students as their "starting" cohorts.  However, when computing a metric that requires a count of starters---graduation rate, for example---FYE records must be treated with special care to avoid a miscount. 





## Avoiding a starter miscount

To illustrate the potential for miscounting starters, suppose we wish to calculate a Mechanical Engineering (ME) graduation rate. Students starting in ME constitute the starting pool and the fraction of that pool graduating in ME is the graduation rate. 

At FYE institutions, an ME program would typically define their starting pool as the post-FYE cohort entering their program. This may be the best information available, but it invariably undercounts starters by failing to account for FYE students who do not transition (post-FYE) to degree-granting engineering programs---students who may have left the institution or switched to  non-engineering majors. In the absence of the FYE requirement some of these students would have been ME starters. By neglecting these students, the count of ME starters is artificially low resulting in an ME graduation rate that is artificially high. The same is true for every degree-granting engineering discipline in an FYE institution. 

Because of the special nature of FYE programs, we cannot address starter miscounts by grouping FYE students with those admitted with "undecided" or  "unknown" CIP codes---FYE students are neither. They were admitted as Engineering majors (2-digit CIP 14). We simply don't know to which degree-granting program (6-digit CIP) they intended to transition.  
 
Therefore, to avoid miscounting starters at FYE institutions, we have to predict the 6-digit CIP codes of the degree-granting engineering programs that  FYE students would have declared had they not been required to enroll in FYE. 





## Definitions

FYE

: First-Year Engineering program, a common-first-year curriculum that is a prerequisite for declaring an engineering major at some US institutions. 

migrator

: A student who changes majors. In dealing with FYE records, we are concerned with migrators into or out of Engineering at the 2-digit program level (CIP 14). 

FYE proxy

: The degree-granting engineering program we predict an FYE student would have declared had they not been required to enroll in FYE. The proxy, a 6-digit CIP code, acts as a substitute for the FYE CIP code as needed. Applies only to students enrolled in FYE in their first term.

multivariate imputation

: Method of imputing missing categorical data, in this case, the 6-digit CIP codes of FYE proxy programs. 





## Method

We describe two approaches for treating FYE student records: using a prepared FYE proxy data set; and creating an FYE proxy data set. 

Using FYE proxies

: The `fye_proxy` data set included with midfieldr contains predicted starting programs for all first-term FYE students in the practice data tables. Only suitable for use with midfielddata practice data.  

Creating FYE proxies

: We apply `prep_fye_mice()` to the `student` and `term` data tables to construct a data frame suitable for imputation using the mice R package. Applied to the midfielddata practice data, users can reproduce the `fye_proxy` data set. Applied to  MIDFIELD research data, users can construct their own FYE proxies. 

If you are writing your own script to follow along, we start with these packages:

```{r}
# Packages
library("midfieldr")
library("midfielddata")
suppressPackageStartupMessages(library("data.table"))

# Only if creating your own FYE proxies
library("mice")

# Printing options for data.table
options(
  datatable.print.nrows = 17,
  datatable.print.topn = 5,
  datatable.print.class = TRUE
)
```




## Using FYE proxies

The prepared proxies can be used with the midfielddata practice data only.  

To illustrate our procedure for using the prepared FYE proxies, we start with the four engineering programs (Civil, Electrical, Industrial/Systems, and Mechanical Engineering) of the case study developed in earlier vignettes. Our goal is to identify starters of the case study programs as if we were preparing to compute graduation rates. 

In this example, the basic steps are to start with all students ever enrolled in the case study programs, filter for first-term information only, replace first-term FYE program codes with the prepared FYE proxies, and filter the result to retain starters in the case study programs.  

**Loading.** Data files included with with midfieldr.  

`study_mcid`

: IDs of students ever enrolled in four programs (Civil, Electrical, Industrial/Systems, and Mechanical Engineering) after filtering for data sufficiency, degree seeking, and program. (Deriving these data from the source data tables is described in [Case study: Data](art-002-case-data.html)).

```{r}
#| collapse: true
study_mcid
```

`study_programs`

: CIP codes and abbreviated labels for the case study programs. (Deriving these data from the source data tables is described in [Case study: Data](art-002-case-data.html)).

```{r}
#| collapse: true
study_programs
```

`fye_proxy`

: Proxy programs for all first-term FYE students in the practice data set. The `proxy` variable gives the predicted 6-digit CIP code. (Deriving these data from the source data tables is described below in [Creating FYE proxies].)

```{r}
#| collapse: true
fye_proxy
```

**Importing.** Load the `term` data table. We use the `term` and `cip6` variables, keyed by student ID. 

```{r}
# Load data from midfielddata
data(term)

# Display selected columns
term[, .(mcid, term, cip6)]
```

You can view the help pages (and data dictionaries) by running

```{r}
#| eval: false

# Run in Console
? study_mcid
? study_programs
? fye_proxy
? term
```

### Obtain first-term records

**Adding variables.**  Starting with the IDs as our working data frame, we join the `term` and `cip6` columns from the `term` table, creating one row per term per student ID. 

```{r}
# Create working data frame
DT <- copy(study_mcid)

# Left-outer join, term into IDs
DT <- term[DT, .(mcid, term, cip6), on = c("mcid")]

# Display the result
DT[]
```

**Filtering.**  To identify starters for a graduation rate calculation, we are interested in the programs to which students are first admitted. Therefore, we order the rows by ID and term, then filter to retain their first term only. The resulting `cip6` column contains students' first-term CIP program codes. 

```{r}
# Retain initial term
setorderv(DT, cols = c("mcid", "term"))
DT <- DT[, .SD[1], by = c("mcid")]

# Display the result
DT[]
```

**Data set-aside.** A data set of direct starters in the four programs is set aside for use in [Quantifying starter miscounts]. 

```{r}
# Create an intermediate data set for later analysis
direct_start <- DT[cip6 != "140102", .(mcid, cip6)]

# Join the program abbreviations
direct_start <- study_programs[direct_start, .(cip6, program), on = "cip6"]

# Retain the case study programs
direct_start <- direct_start[!is.na(program)]
setorderv(direct_start, c("program"))

# Display the result
direct_start
```

### Merge proxies

**Merging.** Merge `fye_proxy` with the working data frame `DT` and drop the `term` variable. Because a proxy is associated with first-term FYE students only, the left-outer join introduces NA values in the `proxy` column for all other students. 

```{r}
# Join the proxies to the working data frame
DT <- fye_proxy[DT, .(mcid, cip6, proxy), on = c("mcid")]

# Display the result
DT[]
```

### Create start variable 

**Creating a variable.**  Predicted starting programs for FYE students are in the `proxy` column. Actual, recorded starting programs for non-FYE students are in the `cip6` column. Create the `start` column to combine the two. 

```{r}
# Combine all starting CIPs
DT[, start := fcase(
  cip6 == "140102", proxy,
  cip6 != "140102", cip6
)]

# Display the result
DT[]
```

### Filter desired programs

**Adding variables.** Add the case study program labels and drop unnecessary columns. The left-outer join introduces NA values in the `program` column for students not enrolled in one of the four study programs. 

```{r}
# New memory location for labels
join_labels <- copy(study_programs)

# Left-outer join, match by the CIPs in start
setnames(join_labels, old = "cip6", new = "start")
DT <- join_labels[DT, .(mcid, start, program), on = c("start")]

# Display the result
DT[order(program)]
```

**Filtering.** We retain students starting in one of the four majors in the case study. The result is ready to be used as the starting pool for a graduation rate calculation.

```{r}
# Keep the four programs only
DT <- DT[!is.na(program)]

# Display the result
DT[order(program)]
```

For convenience, these data are included with midfieldr as `study_starters`. You can view the help page (and data dictionary) by running

```{r}
#| eval: false

# Run in Console
? study_starters
```

**Confirming results.** Verify the results agree with the data included with midfieldr.

```{r}
#| collapse: true

# Verify results
all.equal(DT, study_starters)
```

### Summary

This step concludes our procedure for using prepared proxies. When using midfielddata practice data, the `fye_proxy` data set can always be used as described above without creating your own FYE proxies. 

```{r}
#| echo: false
#| eval: false
# This is where the data set is created.

# study_starters <- copy(DT)
# usethis::use_data(study_starters, overwrite = TRUE)
```

 








## Creating FYE proxies

The goal of this procedure is to create FYE proxy data like that used above. The procedure has three steps: 

1. Use `prep_fye_mice()` from the midfieldr package to predict some of the FYE proxy CIPs, treat the remainder as missing values, and structure the data frame for imputation. 

2. Use `mice()` from the mice package to impute the 6-digit CIP missing values.

3. Post-processing to prepare the results for use. 

This section is optional if you are using the midfielddata practice data sets but required if you are using MIDFIELD research data. 

 








### Data

**Importing.** Data tables from midfielddata.

```{r}
# Load data sets from midfielddata
data(student, term)
```

You can view the help pages (and data dictionaries) by running

```{r}
#| eval: false

# Run in Console
? student
? term
```


### `prep_fye_mice()`

This function prepares FYE data for multivariate imputation. You can view the help page by running

```{r}
#| eval: false

# Run in Console
? prep_fye_mice
```
 
**Arguments:**

midfield_student

: Data frame of student observations, keyed by student ID. Default is `student`. Required variables are `mcid`, `race`, and `sex`. Use all rows of your source `student` data table. 

midfield_term	

: Data frame of term observations keyed by student ID. Default is `term`.  Required variables are `mcid`, `institution`, `term`, and `cip6`. Use all rows of your source `term` data table. 

fye_codes

: Optional character vector of 6-digit CIP codes assigned to FYE programs.  Default is "140102". 

**Usage.** The following implementations yield identical results. 

```{r}
#| collapse: true

# Required arguments in order and explicitly named
x <- prep_fye_mice(midfield_student = student, midfield_term = term)

# Required arguments in order, but not named
y <- prep_fye_mice(student, term)

# Using the implicit defaults
z <- prep_fye_mice()

# Equality test between the data tables
all.equal(x, y)
all.equal(x, z)
```

The records in the `student` data are expected to include degree-seeking students only. No other filter should be applied to the `student` or `term` arguments. Any other filter we might apply, e.g., data sufficiency, would remove information potentially useful to the prediction process without benefiting the process. 

The function extracts all terms for all FYE students, including migrators, and  returns one row per student with columns for institution, race, sex, and proxy CIP code if any. 

```{r}
# Create the working data frame
fye <- prep_fye_mice(student, term)

# Display the result
fye[]
```

The function identifies the CIP code, if any, of the first post-FYE program in which the student enrolls. This treatment yields two possible outcomes for values in the `proxy` column: 

1. The student completes FYE and enrolls in an engineering major. For this outcome, we know that at the student's first opportunity, they enrolled in an engineering program of their choosing. The CIP code of that program is returned by `prep_fye_mice()` as the student's FYE proxy. 

2. The student does not enroll post-FYE in an engineering major. Such students have no further records in the database or switched from Engineering to another program. For this outcome, the data provide no information regarding what engineering program the student would have declared originally had the institution not required them to enroll in FYE. For these students, `prep_fye_mice()` returns a proxy value of NA. These are the data treated as missing values to be imputed by `mice()`.


**Closer look.** At the numbers of post-FYE engineering students and the number of CIP codes treated as missing data to be imputed.  
 
```{r}
#| collapse: true

# Number of students ever enrolled in an FYE program
(ever_FYE <- length(unique(fye$mcid)))

# Count number of CIPs to be imputed
logical_col <- is.na(fye$proxy)
(to_impute <- sum(logical_col))

# Number of imputed as percent of total
round(100 * to_impute / ever_FYE, 1)
```




### Using `mice()`

The mice package [@vanBuuren+Oudshoorn:2011] implements multivariate imputation by chained equations (MICE). MICE is also known as "fully conditional specification" or "sequential regression multiple imputation" and is suitable for categorical variables such as ours [@azur2011]. Our computational procedure follows the approach suggested  by Dhana [-@dhana2017].

The procedure assumes the missing CIP data---the NA values in the prepared data frame---are "missing at random" (MAR), that is, independent of the variables used to impute the missing values. This is the rationale for using data only from FYE institutions to impute the missing values---the existence of the missing data does depend on the institution type, FYE or non-FYE. Within the FYE data itself, however, we assume that the imputed starting majors are missing at random. 

**Framework.** Our first use of `mice()` is to examine the imputation framework by calling the function with zero iterations on the `fye` data frame. `mice()` produces a "multiply-imputed data set", an R object of class "mids".

```{r}
# Imputation framework
framework <- mice(fye, maxit = 0)

# Display the results
framework
```

**Imputation methods.** We look more closely at two elements of this framework. The first is the imputation method vector. 

```{r}
# Imputation method
method_vector <- framework[["method"]]

# Display the results
method_vector
```

The "polyreg" imputation method (polytomous logistic regression) is appropriate for  data, like ours, comprising unordered categorical variables. Variable `proxy` is imputed using the polyreg method; the other variables, being predictors, are not imputed, thus their methods are empty.  

Had the method not been correctly assigned, we would assign it as follows, 

```{r}
# Manually assign the variable(s) being imputed
method_vector[c("proxy")] <- "polyreg"

# Manually assign the variable(s) not being imputed
method_vector[c("mcid", "institution", "race", "sex")] <- ""

# Display the results
method_vector
```

**Predictor matrix.** The second element to review is the predictor matrix. A row label identifies the variable being predicted; the columns indicate the predictor variables.  

```{r}
# Imputation predictor matrix
predictor_matrix <- framework[["predictorMatrix"]]

# Display the results
predictor_matrix
```

However, only those variables assigned a method are imputed. In our case, the only variable to be imputed is `proxy`, so the only row of this matrix that gets used is the last row. 

```{r}
# Predictor row for this example
predictor_matrix["proxy", ]
```

What the zeros and ones tell us is that `proxy` is going to be predicted by institution, race, and sex. 

Had the default setting been incorrect, we can set them manually. Again, note that the bottom row is the only row we need because only the `proxy` variable is being imputed. 

```{r}
# Manually assign zero columns
predictor_matrix[, c("mcid", "proxy")] <- c(0, 0, 0, 0, 0)

# Manually assign predictor columns
predictor_matrix[, c("institution", "race", "sex")] <- c(0, 0, 0, 0, 1)

# Display the result
predictor_matrix
```

**Imputing missing values.** The three essential arguments for `mice()` are the `fye` data frame, the `method_vector`, and the `predictor_matrix`. The default `seed` argument is NULL, but by setting the seed as shown the vignette results are reproducible. Setting `printFlag = TRUE` displays progress in the console. 

```{r}
#| echo: false

# load the saved fye_mids to avoid running mice() repeatedly
load(here::here("R", "sysdata.rda"))
```

```{r}
#| eval: false

# imputation
fye_mids <- mice(
  data = fye,
  method = method_vector,
  predictorMatrix = predictor_matrix,
  seed = 20180624,
  printFlag = TRUE
)
```

```{r}
# output in console with printFlag = TRUE
# >  iter imp variable
# >   1   1  proxy
# >   1   2  proxy
# >   1   3  proxy
# >   1   4  proxy
# >   1   5  proxy
# >   ---
# >   5   1  proxy
# >   5   2  proxy
# >   5   3  proxy
# >   5   4  proxy
# >   5   5  proxy
```

**Extracting the result.** We apply `mice::complete()` to extract the data from the `mids` object. The missing data have been replaced by imputed values. 

```{r}
# Revert to default random number generation
set.seed(NULL)

# Extract data from the mids object
fye <- mice::complete(fye_mids)

# Convert to data.table structure
setDT(fye)

# Display the result
fye <- fye[order(mcid)]
fye[]
```







### Post-processing

**Selecting columns.** To use the result, we need only two columns: IDs and the the predicted starting programs..

```{r}
# Subset the data
fye <- fye[, .(mcid, proxy)]

# Display the result
fye
```

**Recoding.**  We convert the CIP codes from factor to character.

```{r}
# Convert factors
fye[, proxy := as.character(proxy)]

# Display the result
fye
```

**Filtering.** For imputing missing values we used all students ever enrolled in FYE, including migrators. In use, however, the proxies are substitutes for students starting in FYE. Therefore, we filter to retain the proxies of first-term FYE students only. 

```{r}
# Obtain first term of all students in term data
all_start <- term[, .(mcid, term, cip6)]
setorderv(all_start, cols = c("mcid", "term"))
all_start <- all_start[, .SD[1], by = c("mcid")]

# Subset for FYE only
fye_start <- all_start[cip6 == "140102", .(mcid)]
fye_start

# Inner join to retain the FYE starters
fye <- fye_start[fye, .(mcid, proxy), on = c("mcid"), nomatch = NULL]

# Display the result
fye
```

```{r}
#| echo: false
# fye_proxy <- copy(fye)
# usethis::use_data(fye_proxy, overwrite = TRUE)
```











**Confirming results.**  This process is how the built-in data set `fye_proxy` was constructed, using the same random number seed that we used above. To confirm they are identical, 

```{r}
#| collapse: true

# Verify that result matches the built-in data set
all.equal(fye, fye_proxy)
```

### Summary

This step concludes our procedure for creating FYE proxies. 

For a given set of `student` and `term` data tables, the imputation has to be performed only once. The results should be saved as a data file, similar to `fye_proxy` data set used with the midfielddata practice data. 

If we were using these results to contribute to a graduation rate calculation, we would follow the steps outlined in [Using FYE proxies], substituting the `fye` data frame just developed for the `fye_proxy` data provided with midfieldr. 








## Assessing FYE proxies

### Starter miscounts

The main goal of predicting FYE proxies is to prevent starter miscounts. Here, we use two data sets developed earlier to assess the potential for miscounts if FYE records are not treated as recommended. The data sets are:

`direct_start`

: First-term direct starters in the case study programs. Excludes FYE students. 

`study_starters`

: All first-term starters---direct and FYE proxy---in the case study programs. 

**Data set `direct_start`**

```{r}
# Display the data set
direct_start[]
```

Summarizing by program. 

```{r}
# Count by program
direct <- direct_start[, .(direct_start = .N), by = "program"]

# Display the result
direct[]
```


**Data set `study_starters`** includes all direct starters and all FYE proxy starters in the case study. 

```{r}
# Display the data set
study_starters[]
```

Summarizing the `study_starters` data set. 

```{r}
# Count by program
predicted <- study_starters[, .(all_start = .N), by = "program"]

# Display the result
predicted[]
```

**Results.** Merging the data frames for comparison. 

```{r}
# Join
starter_subsets <- merge(direct, predicted, by = "program", all.x = TRUE)

# Display the result
starter_subsets[]
```

To quantify the potential for miscounts, we compute the percentage of starters represented by the FYE proxies.  

```{r}
# FYE percentage of all starters
starter_subsets[, FYE_pct := round(100 * (all_start - direct_start) / all_start, 1)]

# Display the result
starter_subsets[]
```

The results indicate (for these practice data at least) an under-count of 17% to 30% if FYE proxies are excluded when counting starters.  

### Credibility

Here we summarize the FYE proxy data set to see how many students our algorithm assigned to which engineering majors. Start by extracting the unique set of CIP codes from the proxy data set. 

```{r}
# Identify unique CIP codes in the proxy data
proxy_cips <- sort(unique(fye_proxy$proxy))

# Display the results
proxy_cips
```

Obtain the program names from the `cip` data set (provided with midfieldr). We use the 4-digit names that in engineering generally represent  department-level programs. 

```{r}
# Obtain the 4-digit program names corresponding to these codes
proxy_program_names <- filter_search(cip, keep_text = proxy_cips)
proxy_program_names <- proxy_program_names[, .(cip6, program = cip4name)]
proxy_program_names[]
```

Join these names to the proxy data set, summarize by program, and order the rows by descending N.  

```{r}
# Join these program names to the proxy data
proxy_programs <- proxy_program_names[fye_proxy[, .(cip6 = proxy)], .(program), on = c("cip6")]

# Count by program and order rows in descending magnitude
proxy_programs <- proxy_programs[, .N, by = c("program")]
setorderv(proxy_programs, order = -1, cols = c("N"))

# Display the result
proxy_programs[]
```

The order of these majors is consistent with our expectations. For example, the National Science Foundation (NSF) reports that the 2012 ranking of majors by enrollment in the US has Mechanical Engineering first, followed by Electrical, Civil, Chemical, Industrial, Aerospace, and Materials Engineering [@NSF:2014]. 

The NSF data table does not break out Computer Engineering as a separate observation---if we can assume that the NSF combined Computer Engineering with Electrical Engineering (a practice followed at many Engineering colleges), then combining them in our data produces the following, 

```{r}
# Combine Electrical and Computer Engineering
new_row <- data.table(
  program = "Electrical/Computer Engineering",
  N = sum(proxy_programs[program %ilike% "Electrical|Computer", N])
)

# New location in memory
rev_proxy <- copy(proxy_programs)

# Drop the separate Electrical and Computer rows
rev_proxy <- rev_proxy[!program %ilike% "Electrical|Computer"]

# Bind the new row and order
rev_proxy <- rbindlist(list(rev_proxy, new_row))
setorderv(rev_proxy, c("N"), -1)

# Display the top 6 rows
rev_proxy[1:6]
```

This list matches the top six programs in the NSF list in nearly the same order (rows 5 and 6 have swapped places). We conclude that the imputation is credible at least to the extent that the ranking of the majors is consistent with expectations. Additional work would be required to compare summaries by institution, race, or sex. 






## Closing

At institutions with First-Year Engineering (FYE) programs, students "starting" in degree-granting engineering majors are under-counted unless care is taken to account for FYE students who do not transition (post-FYE) to degree-granting engineering programs

We address this problem using FYE "proxies"---6-digit CIP codes of the  degree-granting engineering programs we predict FYE students would have declared had they not been required to enroll in FYE.














## References

<div id="refs"></div>






## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script. 

```{r}
#| eval: false

# Packages
library("midfieldr")
library("midfielddata")
suppressPackageStartupMessages(library("data.table"))

# Only if creating your own FYE proxies
library("mice")

# Printing options for data.table
options(
  datatable.print.nrows = 17,
  datatable.print.topn = 5,
  datatable.print.class = TRUE
)

# Using FYE proxies
data(term)

# Obtain first-term records
DT <- copy(study_mcid)
DT <- term[DT, .(mcid, term, cip6), on = c("mcid")]
setorderv(DT, cols = c("mcid", "term"))
DT <- DT[, .SD[1], by = c("mcid")]

# Data set-aside
direct_start <- DT[cip6 != "140102", .(mcid, cip6)]
direct_start <- study_programs[direct_start, .(cip6, program), on = "cip6"]
direct_start <- direct_start[!is.na(program)]
setorderv(direct_start, c("program"))

# Identify starters
DT <- fye_proxy[DT, .(mcid, cip6, proxy), on = c("mcid")]
DT[, start := fcase(
  cip6 == "140102", proxy,
  cip6 != "140102", cip6
)]
join_labels <- copy(study_programs)
setnames(join_labels, old = "cip6", new = "start")
DT <- join_labels[DT, .(mcid, start, program), on = c("start")]
DT <- DT[!is.na(program)]

# Creating FYE proxies
data(student, term)

# prep_fye_mice()
fye <- prep_fye_mice(student, term)

# mice() method
framework <- mice(fye, maxit = 0)
method_vector <- framework[["method"]]
method_vector[c("proxy")] <- "polyreg"
method_vector[c("mcid", "institution", "race", "sex")] <- ""

# mice() predictor
predictor_matrix <- framework[["predictorMatrix"]]
predictor_matrix[, c("mcid", "proxy")] <- c(0, 0, 0, 0, 0)
predictor_matrix[, c("institution", "race", "sex")] <- c(0, 0, 0, 0, 1)

# mice()
fye_mids <- mice(
  data = fye,
  method = method_vector,
  predictorMatrix = predictor_matrix,
  seed = 20180624,
  printFlag = TRUE
)
set.seed(NULL)
fye <- mice::complete(fye_mids)
setDT(fye)

# Post-processing
fye <- fye[, .(mcid, proxy)]
fye[, proxy := as.character(proxy)]
all_start <- term[, .(mcid, term, cip6)]
setorderv(all_start, cols = c("mcid", "term"))
all_start <- all_start[, .SD[1], by = c("mcid")]
fye_start <- all_start[cip6 == "140102", .(mcid)]
fye <- fye_start[fye, .(mcid, proxy), on = c("mcid"), nomatch = NULL]

# Quantifying starter miscounts
direct <- direct_start[, .(direct_start = .N), by = "program"]
predicted <- study_starters[, .(all_start = .N), by = "program"]
starter_subsets <- merge(direct, predicted, by = "program", all.x = TRUE)
starter_subsets[, FYE_pct := round(100 * (all_start - direct_start) / all_start, 1)]

# Credibility of the proxies
proxy_cips <- sort(unique(fye_proxy$proxy))
proxy_program_names <- filter_search(cip, keep_text = proxy_cips)
proxy_program_names <- proxy_program_names[, .(cip6, program = cip4name)]
proxy_programs <- proxy_program_names[fye_proxy[, .(cip6 = proxy)], .(program), on = c("cip6")]
proxy_programs <- proxy_programs[, .N, by = c("program")]
setorderv(proxy_programs, order = -1, cols = c("N"))

# Compare to NSF report
new_row <- data.table(
  program = "Electrical/Computer Engineering",
  N = sum(proxy_programs[program %ilike% "Electrical|Computer", N])
)
rev_proxy <- copy(proxy_programs)
rev_proxy <- rev_proxy[!program %ilike% "Electrical|Computer"]
rev_proxy <- rbindlist(list(rev_proxy, new_row))
setorderv(rev_proxy, c("N"), -1)
```

```{r echo = FALSE}
# to change the CSS file for block quotes
# per https://github.com/rstudio/rmarkdown/issues/732
knitr::opts_chunk$set(echo = FALSE)
```

```{css}
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    border-left: 0px
}
```
