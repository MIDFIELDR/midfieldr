---
title: "Data basics"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Data basics}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
nocite: | 
  @Dowle+Srinivasan:2020:data.table
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-data-basics-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
```

## Introduction 

Introduces the four data sets in the midfielddata package and basic data manipulation operations in the data.table package. 

Researchers interested in exploring MIDFIELD data are often R novices, learning to use midfieldr at the same time they are learning to use R. There are many good online resources for learning R, so we do not attempt to reproduce that work here. However, we would like to offer some suggestions to help address some of the obstacles our new users have encountered in the past.


### Why data.table? 

`data.table` provides "a high-performance version of base R’s `data.frame` with syntax and feature enhancements for ease of use, convenience and programming speed" [@Dowle+Srinivasan:2020:data.table:website]. MIDFIELD data can require a lot of memory (`midfieldcourses` has 3.5 M rows and requires 348 MB of memory), making data.table's efficient use of memory potentially an important consideration. 

Consequently, the midfieldr and midfielddata data sets are in data.table form and the inner workings of midfieldr functions are written using data.table syntax to take advantage of its features. 

However, midfieldr users are not required to adopt data.table syntax if they prefer a different "dialect" such as base R or dplyr---midfieldr functions attempt to preserve data frames and tibbles when used as arguments. 

The vignettes, while written using data.table syntax, can be rewritten in base R or dplyr using online resources such as those by van der Laken [-@vanDerLaken:2020] or Mercer [-@Mercer:2020]. We also highly recommend [@Zumel+Mount:2020, Ch. 5]. 

### This vignette uses

packages

```{r}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)

# print max 10 rows, otherwise 5 rows each head/tail
options(datatable.print.nrows = 10, datatable.print.topn = 5)
```

```{r echo = FALSE}
n_students <- nrow(midfieldstudents)
n_institutions <- length(unique(midfieldstudents$institution))
year_span <- floor(c(min(midfieldterms$term), max(midfieldterms$term)) / 10)
```

## midfielddata

```{r echo = FALSE}
# midfieldstudents
n_id_students <- nrow(unique(midfieldstudents[, .(id)]))
n_term_enter <- nrow(unique(midfieldstudents[, .(term_enter)]))
obs_students <- nrow(midfieldstudents)
var_students <- ncol(midfieldstudents)
size_students <- "19 MB"

# midfielddegrees
n_id_degrees <- nrow(unique(midfielddegrees[, .(id)]))
n_graduates <- nrow(unique(midfielddegrees[!is.na(degree), .(id)]))
n_term_degree <- nrow(unique(midfielddegrees[, .(term_degree)]))
obs_degrees <- nrow(midfielddegrees)
var_degrees <- ncol(midfielddegrees)
size_degrees <- "10.2 MB"

# midfieldterms
n_id_terms <- nrow(unique(midfieldterms[, .(id)]))
obs_terms <- nrow(midfieldterms)
var_terms <- ncol(midfieldterms)
n_institutions <- nrow(unique(midfieldterms[, .(institution)]))
n_programs_terms <- nrow(unique(midfieldterms[, .(institution, cip6)]))
n_terms <- nrow(unique(midfieldterms[, .(term)]))
year_span <- floor(c(min(midfieldterms$term), max(midfieldterms$term)) / 10)
size_terms <- "82 MB"

# midfieldcourses
n_id_courses <- nrow(unique(midfieldcourses[, .(id)]))
n_courses <- nrow(unique(midfieldcourses[, .(institution, abbrev, number)]))
n_term_course <- nrow(unique(midfieldcourses[, .(term_course)]))
obs_courses <- nrow(midfieldcourses)
var_courses <- ncol(midfieldcourses)
size_courses <- "349 MB"
```

midfielddata [(link)](https://midfieldr.github.io/midfielddata/) is an R data package that provides a stratified sample of MIDFIELD data. Contains data for `r n_students` undergraduates at `r n_institutions` institutions from `r year_span[1]`–`r year_span[2]` in four interrelated data sets.  

### midfieldstudents

- matriculation attributes keyed by student ID 
- `r n_id_students` students over `r n_term_enter` terms
- `r obs_students` rows, `r var_students` columns, `r size_students` memory
- [data dictionary](https://midfieldr.github.io/midfielddata/reference/midfieldstudents.html) 

```{r}
midfieldstudents
```

### midfielddegrees 

- degree attributes keyed by student ID 
- `r n_id_degrees` students of whom `r n_graduates` earn bachelor's degrees 
- `r obs_degrees` rows, `r var_degrees` columns, `r size_degrees` memory 
- [data dictionary](https://midfieldr.github.io/midfielddata/reference/midfielddegrees.html) 

```{r}
midfielddegrees
```

### midfieldterms 

- term attributes keyed by student ID and academic term 
- `r n_id_terms` students  in `r n_programs_terms` programs over `r n_terms` terms  
- `r obs_terms` rows, `r var_terms` columns, `r size_terms` memory  
- [data dictionary](https://midfieldr.github.io/midfielddata/reference/midfieldterms.html)

```{r}
midfieldterms
```

### midfieldcourses 

- course attributes keyed by student ID, academic term, and course/section identifiers 
- `r n_id_courses` students  in `r n_courses` courses over `r n_term_course` terms
- `r obs_courses` rows, `r var_courses` columns, `r size_courses` memory  
- [data dictionary](https://midfieldr.github.io/midfielddata/reference/midfieldcourses.html) 

```{r}
midfieldcourses
```



## Basic data manipulation with data.table

In this section, we introduce the data.table syntax most often used in the midfieldr vignettes. For more information on data.table, see [@Dowle+Srinivasan:2020:data.table:website]. 

### Identifying a data.table object

If you view a data frame in the console, one clue that it is a data.table is the colon that separates the row number from the first column. For example,  if I extract the first few rows from the degrees data, you can see the colons. 

```{r}
# data.table object (using data.frame syntax)
midfielddegrees[1:10]
```

Of course, we can identify its class directly. The output shows that a `data.table` is also `data.frame` thus one can operate on data.table objects using data.frame (base R) syntax.

```{r}
# confirm classification
class(midfielddegrees)
```

Viewing a data.frame object (base R `airquality` data), the row numbers are not denoted by colons. And here, the comma is required. 

```{r}
# data.frame object (comma is required)
airquality[1:10, ]

# confirm classification
class(airquality)
```

### Subset and arrange rows

**Summary**

- `DT[rows_we_want]` subset rows
- `DT[order(col)]` arrange rows by values in column
- `DT[]` to print the data

We start by copying a data.table object. As we discuss later in the vignette, copies are used to avoid changing the source in place. 

```{r}
# start with a fresh copy
DT <- copy(midfielddegrees)
```

**Filter rows using a logical expression**

```{r}
# TRUE/FALSE/NA vector
rows_we_want <- DT$cip6 == "540101"

# subset the data frame
DT <- DT[rows_we_want]

# examine the result
DT[]
```

We could have written `DT[cip6 == "540101"]` and obtained the same result. For clarity, however, we use the 2-step process illustrated above: 1) identify the rows (or columns) we want, and 2) subset the data frame in a separate step. 

Note too, in data.table syntax we can write 

```r
DT[rows_we_want]
```

instead of the base R syntax, 

```r
DF[rows_we_want, , drop = FALSE]
```

**Filter rows using multiple conditions**

```{r}
# start with a fresh copy
DT <- copy(midfielddegrees)

# subset the data frame
rows_we_want <- is.na(DT$cip6) & DT$institution == "Institution D"
DT <- DT[rows_we_want]

# examine the result
DT[]
```

**Discard rows with missing values**

```{r}
# start with a fresh copy
DT <- copy(midfielddegrees)

# subset the data frame
DT <- na.omit(DT)

# examine the result
DT[]
```

**Arrange rows in ascending order** 

```{r}
# start with a fresh copy
DT <- copy(midfielddegrees)

# subset the data frame
rows_we_want <- DT$cip6 == "540101"
DT <- DT[rows_we_want]

# order rows by values in ID column
DT <- DT[order(id)]

# examine the result
DT[]
```

**Arrange rows by more than one column**

```{r}
# order rows by values in two columns
DT <- DT[order(institution, id)]

# examine the result
DT[]
```

**Arrange rows in descending order**

```{r}
# order rows by values, one ascending, one descending
DT <- DT[order(institution, -term_degree)]

# examine the result
DT[]
```

**Print a result.** In the examples above, we use `DT[]` to print the result to the screen. This step is not always necessary. Often, simply typing the object name, e.g., `DT`, is sufficient. You'll see both types in the vignettes. 

### Select columns

**Summary**

- `DT[, ..cols_we_want]` select columns using a character vector
- `DT[, .(col1, col2)]` select columns using a list
- `DT[, .(col1, new_col = col2)]` select columns, rename one 

**Select columns using a character vector.** In this form, the column names are quoted and 2 dots identify the vector name, e.g., 

```r
DT[, ..cols_we_want]
```

Example

```{r}
# start with a fresh copy
DT <- copy(midfieldstudents)

# column-names vector
cols_we_want <- c("id", "race", "sex")

# subset the data frame
DT <- DT[, ..cols_we_want]

# examine the result
DT
```

**Select columns using a list.** The list appears with unquoted column names inside the brackets.  The syntax `.()` is data.table shorthand for `list()`, thus the two lines are equivalent.

```r
DT[, list(col1, col2)]
DT[, .(col1, col2)]
```

Example

```{r}
# start with a fresh copy
DT <- copy(midfieldstudents)

# subset the data frame
DT <- DT[, .(id, race, sex)]

# examine the result
DT
```

**Select columns, rename one.** 

```{r}
# subset the data frame, rename a column
DT <- DT[, .(id, race_ethnicity = race, sex)]

# examine the result
DT
```

A drawback to this approach is that you must include the names of all columns you want to keep. To rename a column without having to list them all, see `setnames()` discussion later in the vignette. 

### Combine row and column operations

In most cases, simply combine the row and column operation in the same set of brackets, i.e., `DT[i, j]`, where `i` is the row operation and `j` is the column operation. 

Example

```{r}
# start with a fresh copy
DT <- copy(midfieldstudents)

# subset the data frame
rows_we_want <- DT$hours_transfer > 11 & DT$hours_transfer < 49
cols_we_want <- c("id", "cip6", "hours_transfer")
DT <- DT[rows_we_want, ..cols_we_want]

# examine the result
DT
```

Example 

```{r}
# order rows and rename columns
DT <- DT[
  order(-hours_transfer),
  .(ID = id, CIP = cip6, HOURS = hours_transfer)
]

# examine the result
DT
```

### Modify columns in place

Columns are modified by reference (in place) using the column assignment symbol `:=`. The operation is faster than operations requiring a copy, especially for large data frames. 

**Summary**

- `DT[, col := NULL]` remove a column in place 
- `DT[, new_col := FUN]` add new column in place where FUN is a function or value
- `DT[rows_to_edit, col := value]` add or modify a column in place for specific rows

```{r}
# start with a fresh copy
DT <- copy(midfielddegrees)

# create a subset to work with
rows_we_want <- DT$institution == "Institution D"
DT <- DT[rows_we_want]

# examine the result
DT[order(degree)]
```

**Remove a column by selection.**  Earlier, we saw one approach to omitting columns is to exclude them from a selection vector. For example, by selecting the three columns shown below, we are necessarily omitting the `cip6` and `institution` columns.  This operation requires the use of the assignment operator `<-` to assign the result to an object name. 

```{r}
# omit columns by not selecting them
cols_we_want <- c("id", "degree", "term_degree")
DT <- DT[, ..cols_we_want]

# examine the result
DT[order(degree)]
```

**Remove a column in place.**  In contrast, we avoid the memory usage entailed by `<-` if we omit a column using the data.table `:=` operator. 

```{r}
# omit a column in place
DT[, id := NULL]

# examine the result
DT[order(degree)]
```

**Add a column in place.** The form is `DT[, new_col := FUN]`  where `FUN` is a function or value. Here we add a new column that consists of a single value. 

```{r}
# add column in place
DT[, inst_size := "small"]

# examine the result
DT[order(degree)]
```

**Modify a column in place using a function**  Here, we add a new columns `year` and `term_idx` that are functions of the `term_degree` column. This operation illustrates one approach to separating the encoded term into separate year and term-index columns. In this example we use the `:=` operator in its *functional* form. 

```{r}
# add columns in place
DT[, `:=` (year = substr(term_degree, 1, 4), 
           term_idx = substr(term_degree, 5, 5))]

# examine the result
DT[order(degree, term_degree)]
```

**Add a column in place for specific rows.** Here we create a new `status` column with the value of "grad" in rows where `degree` is not NA. In all other rows, the value of the `status` is automatically NA. 

```{r}
DT[!is.na(degree), status := "grad"]
DT[order(status)]
```

**Modify a column in place for specific rows.** Next we can overwrite the NA values in `status`. 

```{r}
DT[is.na(degree), status := "nongrad"]
DT[order(status)]
```

Of course, both operations can be combined using the data.table if-else structure, another example of modifying a column in place using a function. 

```{r}
# start with a fresh copy
DT <- copy(midfielddegrees)

# subset columns again
DT <- DT[, ..cols_we_want]

# using fifelse
DT[, status := fifelse(is.na(degree), "nongrad", "grad")]
DT[]
```


### Operations by group

**Summary**

- `DT[, .(new_col = .N), by = grouping_variables]` frequency by group
- `DT[, .SD[FUN(col)], by = grouping_variables]` operate on a column by group 

```{r}
# create a subset to work with
rows_we_want <- midfieldterms$cip6 == "141901"
cols_we_want <- c("institution", "cip6", "term", "coop")
DT <- midfieldterms[rows_we_want, ..cols_we_want]

# examine the result
DT
```

**Frequency by group.** We use this syntax regularly in computing persistence metrics. Once a data set keyed by student ID has been manipulated for the desired form, we count the number of students (or frequency) by group.  

First, we count the total number of students by institution. The data.table `.N` function is the total count. The default column name in `N`. 

```{r}
# count by institution
DT[, .N, by = institution]

# use keyby for grouping and ordering the rows by the same variable
DT[, .N, keyby = institution]

# count by coop
DT[, .N, by = coop]
```

Assign a column name to the count

```{r}
# column name for the count
DT[, .(N_coop = .N), by = coop]
```

Our practice in the vignettes is to place the grouping variables in a character vector. For example, 

```{r}
# edit the printout option
options(datatable.print.nrows = 16)

# assign the grouping variables
grouping_variables <- c("institution", "coop")

# count by the groupings
DT[, .(frequency = .N), keyby = grouping_variables]

# reset the printout option
options(datatable.print.nrows = 10, datatable.print.topn = 5)
```

**Operate on a column by group.** The data.table `.SD` operator can be thought of as a symbol that represents a data.table of a specific group. We can use it to operate on one column grouped by the values in another column. 

```{r}
# create a subset to work with
rows_we_want <- midfieldterms$cip6 == "141901"
cols_we_want <- c("id", "cip6", "term")
DT <- midfieldterms[rows_we_want, ..cols_we_want]

# examine the result
DT
```

Example. Retain rows with the most recent term by ID. 

```{r}
# keep the latest term data by ID
DT <- DT[, .SD[term == max(term)], by = id]

# examine the result
DT
```

### Modify in place

**Summary**

- `setDT()` convert data.frame to data.table in place
- `setDF()` convert data.table to data.frame in place 
- `setnames()` rename columns in place 
- `copy()` to avoid modifying the source object 

When we apply any data.table function that starts with `set` (or when we use the `:=` operator), data.table changes the object in place (also called "by reference"). This is an important feature for saving computational expense when working with large data frames such as `midfieldcourses`. 

**Side-effects.** Modify in place has side-effects, however, of which the user must be aware. Suppose we start with a data.frame object and we use `setDT()` to transform it to a data.table object. We'll use the base R `airquality` data set again. 

```{r}
# the original is a data.frame
DF <- copy(airquality)
class(DF)
```

Create a data.table with `setDT()`. 

```{r}
# create data.table
DT <- setDT(DF)
class(DT)
```

`DT` is a data.table as expected. However, because the transformation was "in place", it applied to the original `DF` as well. 

```{r}
class(DF)
```

Using in-place operations, `DF` and `DT` point to the same location in memory. 

```{r}
# both labels refer to the same memory address
address(DT)
address(DF)
```

It follows then that a function applied to `DT` is also applied to `DF`, 

```{r}
# edit DT
DT[, year := 1973]
DT

# and the change applied to DF
DF
```

To avoid this side effect, we use `copy()`. 

```{r}
# the original is a data.frame
DF <- copy(airquality)
class(DF)
```

Make a copy and transform to data.table 

```{r}
# make a copy
DT <- copy(DF)

# transform
setDT(DT)

# DT is a data.table
class(DT)
```

`DT` and `DF` have different addresses, so `DF` remains unaffected. 

```{r}
# the two objects have different addresses in memory
address(DT)
address(DF)

# DF remains a data.frame
class(DF)
```

Operating on `DT` no has no side-effect on `DF`.  

```{r}
# edit DT
DT[, year := 1973]

# examine the result
head(DT)

# no change to DF
head(DF)
```

**Convert data.frame to data.table in place**. Here we start with the  `airquality` data.frame from base R. Copy and transform to a data.table and compare results. The original is unaffected because we used `copy()`. 

```{r}
# start with a data.frame
class(airquality)

# copy and transform in place
DT <- copy(airquality)
setDT(DT)

# compare results
class(airquality)
class(DT)
```

**Convert data.table to data.frame in place**. Here we start with the  `cip` data.table from midfieldr. Copy and transform to a data.frame and compare results. Again, because we started with`copy()`, the original is unaffected by the `setDF()` operation.  

```{r}
# start with a data.table
class(cip)

# copy and transform in place
DF <- copy(cip)
setDF(DF)

# compare results
class(cip)
class(DF)
```

**Rename columns in place**. `setnames()` allows us to edit one or more column names without affecting unnamed columns. 

```{r}
# create a subset to work with
DT <- copy(midfielddegrees)
rows_we_want <- DT$institution == "Institution D"
DT <- DT[rows_we_want]

# examine the result
DT[order(degree)]
```

Edit some column names, leaving others intact

```{r}
# edit column names in place
setnames(DT, old = c("id", "cip6"), new = c("ID", "CIP"))

# examine the result
DT
```




## References

<div id="refs"></div>





## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval = FALSE}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)

# view each data set
midfieldstudents
midfielddegrees
midfieldterms
midfieldcourses

# identify objects
midfielddegrees[1:10]
class(midfielddegrees)
airquality[1:10, ]
class(airquality)

# subset and arrange rows
DT <- copy(midfielddegrees)
rows_we_want <- DT$cip6 == "540101"
DT <- DT[rows_we_want]

# filter rows using multiple conditions
DT <- copy(midfielddegrees)
rows_we_want <- is.na(DT$cip6) & DT$institution == "Institution D"
DT <- DT[rows_we_want]

# discard rows with missing values
DT <- copy(midfielddegrees)
DT <- na.omit(DT)

# arrange rows
DT <- copy(midfielddegrees)
rows_we_want <- DT$cip6 == "540101"
DT <- DT[rows_we_want]
DT <- DT[order(id)]
DT <- DT[order(institution, id)]
DT <- DT[order(institution, -term_degree)]

# select columns using a character vector
DT <- copy(midfieldstudents)
cols_we_want <- c("id", "race", "sex")
DT <- DT[, ..cols_we_want]

# select columns using a list
DT <- copy(midfieldstudents)
DT <- DT[, .(id, race, sex)]

# select columns, rename one
DT <- DT[, .(id, race_ethnicity = race, sex)]

# combine row and column operations
DT <- copy(midfieldstudents)
rows_we_want <- DT$hours_transfer > 11 & DT$hours_transfer < 49
cols_we_want <- c("id", "cip6", "hours_transfer")
DT <- DT[rows_we_want, ..cols_we_want]
DT <- DT[
  order(-hours_transfer),
  .(ID = id, CIP = cip6, HOURS = hours_transfer)
]

# remove a column in place
DT <- copy(midfielddegrees)
rows_we_want <- DT$institution == "Institution D"
cols_we_want <- c("id", "degree", "term_degree")
DT <- DT[rows_we_want, ..cols_we_want]
DT[, id := NULL]

# add a column in place
DT[, inst_size := "small"]
DT[, `:=` (year = substr(term_degree, 1, 4), 
           term_idx = substr(term_degree, 5, 5))]

# add/modify a column in place for specific rows
DT[!is.na(degree), status := "grad"]
DT[is.na(degree), status := "nongrad"]
DT <- copy(midfielddegrees)
DT <- DT[, ..cols_we_want]
DT[, status := fifelse(is.na(degree), "nongrad", "grad")]

# frequency by group
rows_we_want <- midfieldterms$cip6 == "141901"
cols_we_want <- c("institution", "cip6", "term", "coop")
DT <- midfieldterms[rows_we_want, ..cols_we_want]
DT[, .N, keyby = institution]
DT[, .(N_coop = .N), by = coop]
grouping_variables <- c("institution", "coop")
DT[, .(frequency = .N), keyby = grouping_variables]

# operate on a column by group
rows_we_want <- midfieldterms$cip6 == "141901"
cols_we_want <- c("id", "cip6", "term")
DT <- midfieldterms[rows_we_want, ..cols_we_want]
DT <- DT[, .SD[term == max(term)], by = id]

# convert data.frame to data.table in place
class(airquality)
DT <- copy(airquality)
setDT(DT)
class(airquality)
class(DT)

# convert data.table to data.frame in place
class(cip)
DF <- copy(cip)
setDF(DF)
class(cip)
class(DF)

# rename columns in place
DT <- copy(midfielddegrees)
rows_we_want <- DT$institution == "Institution D"
DT <- DT[rows_we_want]
setnames(DT, old = c("id", "cip6"), new = c("ID", "CIP"))
```
