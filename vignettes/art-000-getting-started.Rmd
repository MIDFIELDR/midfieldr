---
title: "Getting started"
date: "`r Sys.Date()`"
link-citations: yes
bibliography: ../inst/REFERENCES.bib
output: rmarkdown::html_vignette
csl: ../inst/information-science-and-technology.csl
vignette: >
  %\VignetteIndexEntry{Getting started}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
nocite: |
  @Dowle+Srinivasan:2021:data.table,  
  @Waring+Quinn:2022:skimr
resource_files: |
---

```{r setup, include = FALSE}
# code chunks
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  cache = FALSE # speeds up repeats
)

# figures
knitr::opts_chunk$set(
  fig.path = "../man/figures/art-000-getting-started-",
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)

# inline numbers
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})

# data.table printout
options(
  datatable.print.nrows = 6,
  datatable.print.topn = 3,
  datatable.print.class = TRUE
)

# accented text
# accent <- function (text_string){
#     kableExtra::text_spec(text_string, color = "#b35806", bold = TRUE)
# }
```




## Student unit records 

The MIDFIELD Student Unit Records (SUR) are registrar's student-level data compiled by an institution and anonymized and curated by the MIDFIELD data steward. SURs include personal information (e.g., age, sex, and race/ethnicity), enrollment information (e.g., institution, program, and grade level), and academic information (e.g., courses, grades, and degrees). MIDFIELD data are organized into four tables---student, course, term, and degree---keyed by student ID. 

From the MIDFIELD *research* data, we've taken a proportionate stratified sample and made it available as a *practice* data set in  [midfielddata](https://midfieldr.github.io/midfielddata/)---an R data package containing anonymized SURs for nearly 98,000 undergraduates at three institutions from 1988--2018. Table 1 briefly introduces the four practice data tables.

```{r}
#| echo: false

library("midfieldr")

wrapr::build_frame(
  "Practice data table", "Each row is", "No. of rows", "No. of columns", "Memory" |
    "course", "a student in a course", "3,439,936", "12", "340 Mb" |
    "term", "a student in a term", "710,841", "13", "80 Mb" |
    "student", "a degree-seeking student", "97,640", "13", "19 Mb" |
    "degree", "a student who graduates", "47,499", "5", "10.2 Mb"
) |>
  kableExtra::kbl(
    align = "llrrr",
    caption = "Table 1: Attributes of the practice data tables in midfielddata"
  ) |>
  kableExtra::kable_paper(lightable_options = "basic", full_width = TRUE) |>
  kableExtra::row_spec(0, background = "#c7eae5") |>
  kableExtra::column_spec(1, monospace = TRUE) |>
  kableExtra::column_spec(1:4, color = "black", background = "white")
```






## Method

With required packages installed (per the [main page](../index.html#requirements)), we start  with midfieldr by: 

- Reviewing R help functions
- Inspecting the four practice data tables 
- Introducing midfieldr functions

*Names of source data tables.* &nbsp; When a source data table is an argument of a midfieldr function, the default names are `student`, `course`, `term`, and `degree`. Alternate names can be used if desired. 

*Names of variables.* &nbsp; midfieldr functions are designed to work with variables names given in the source data tables with no mechanism for substitutions. Help pages denote the variable names that are required.  

*Caveat.*  &nbsp; The data in ‘midfielddata’ are practice data, suitable for learning to work with Student Unit Records (SURs) generally. Unlike the MIDFIELD research database, the data tables in ‘midfielddata’ are not research data; they are not suitable for drawing inferences about program attributes or student experiences.





## R help

This section is primarily for users fairly new to R. R's built-in help system is an essential part of solving problems you might encounter. Here we provide a short list of R help features applied to midfieldr content. 

To start, load the midfieldr package. 

```{r}
# Type in the Console
library("midfieldr")
```

*Help function.*  &nbsp;  From the R Console you can use `?` or `help()`. For example, the following commands yield the same result:

```{r}
#| eval: false

# Type in the Console
help("add_timely_term")
? add_timely_term
```

The help function can also be used to learn more about data sets included with midfieldr and midfielddata. 

```{r}
#| eval: false

# Type in the Console
? cip
```

*Data.* &nbsp; Use the `data()` function to view the names of the data sets included with a package. 

```{r}
#| eval: false

# Type in the Console
data(package = "midfieldr")
#> Data sets in package 'midfieldr':
#>
#> cip
#> fye_proxy
#> study_ever
#> ...
```

*List functions.*  &nbsp;  Use `lsf.str()` to list all functions in a package and their arguments, 

```{r}
# Type in the Console
lsf.str("package:midfieldr")
```

*Run examples.*  &nbsp;  Use the `example()` function to run the function examples that are included with a package.

```{r}
#| eval: false

# Type in the Console
example("add_timely_term")
```







## Load data

*Open.* &nbsp; If you are writing your own script to follow along, we use these packages in this vignette:

```{r}
# Getting started
# midfieldr vignette

# Packages used
library("midfieldr")
library("midfielddata")
library("data.table")
```

*Load data tables.*  &nbsp; Use `data()` to load the practice data tables into memory for use. For example, after loading the package with `library("midfielddata")` as we did above, you can run `ls()` to see that the environment contains zero objects, 

```{r}
# Names of objects in the environment
ls()
```

To load the `student` data from midfielddata into memory, we run

```{r}
#| echo: false

if (!exists("student")) data(student, package = "midfielddata")
```

```{r}
#| eval: false

# Load practice data
data(student, package = "midfielddata")
```

Checking the environment again, 

```{r}
# Names of objects in the environment
ls()
```

If you look in the RStudio *Environment* pane, you should see `student` listed. We will typically load the data sets we need at the top of a script just after loading the midfielddata package. You need to load them only once in a script.  

```{r}
#| echo: false

if (!exists("course")) data(course, package = "midfielddata")
if (!exists("term")) data(term, package = "midfielddata")
if (!exists("degree")) data(degree, package = "midfielddata")
```

```{r}
#| eval: false

# Load remaining practice data
data(course, term, degree, package = "midfielddata")
```

Checking the environment again, 

```{r}
# Names of objects in the environment
ls()
```


```{r}
#| echo: false

# cip
n_cip <- nrow(unique(cip))

# student
obs_students <- nrow(student)
var_students <- ncol(student)
size_students <- "13 MB"

# degree
n_id_degrees <- nrow(unique(degree[, .(mcid)]))
n_graduates <- nrow(unique(degree[!is.na(degree), .(mcid)]))
n_term <- nrow(unique(degree[, .(term)]))
obs_degrees <- nrow(degree)
var_degrees <- ncol(degree)
size_degrees <- "5 MB"

# term
n_id_terms <- nrow(unique(term[, .(mcid)]))
obs_terms <- nrow(term)
var_terms <- ncol(term)
n_institutions <- nrow(unique(term[, .(institution)]))
n_programs_terms <- nrow(unique(term[, .(institution, cip6)]))
n_terms <- nrow(unique(term[, .(term)]))
year_span <- c(substr(min(term[, term]), 1, 4), substr(max(term[, term]), 1, 4))
size_terms <- "73 MB"

# course
n_id_courses <- nrow(unique(course[, .(mcid)]))
n_courses <- nrow(unique(course[, .(institution, abbrev, number)]))
n_term_course <- nrow(unique(course[, .(term)]))
obs_courses <- nrow(course)
var_courses <- ncol(course)
size_courses <- "324 MB"
```





## Inspect the `student` data

`student` is a table of `r var_students` student-related variables for  degree-seeking students at the time they were admitted to their institutions. You can view the help page (and data dictionary) by running

```{r}
#| eval: false

# Run in Console
? student
```

Each observation is a unique student keyed by student ID. Student IDs and institution names are de-identified but are consistent across the four data sets. To see the data structure, run

```{r}
# View the structure of the data set
str(student)
```

`student` has `r obs_students` observations and occupies approximately `r size_students` memory. We can confirm that the student IDs are unique by running, 

```{r}
nrow(student)

length(unique(student$mcid))
```

Summarize some of the quantitative variables. 

```{r}
summary(student$sat_math)

summary(student$act_comp)
```

Examine a few of the categorical variables and their values. 

```{r}
sort(unique(student$sex))

sort(unique(student$race))
```

### Exercises
 
1. Determine the possible values in the `institution` column. 
2. Determine the possible values in the `transfer` column. 
3. Determine the median `sat_verbal` score.






## Inspect the `course` data

`course` is a data frame of `r var_courses` course-related variables with observations of students who complete a course or remain in a course beyond their institution's course-withdrawal deadline. You can view the help page (and data dictionary) by running

```{r}
#| eval: false

# Run in Console
? course
```

Each observation is one course in one term for one student keyed by student ID. To see the data structure, run

```{r}
# View the structure of the data set
str(course)
```

Of the four practice data sets in midfielddata, `course` is by far the largest, with `r obs_courses` observations and occupying `r size_courses` of memory. Depending on your machine, loading `course` can cause a noticeable delay in execution time, so you probably want to load it only when needed. 

To be recorded in `course` (unlike `student`), students can be non-degree-seeking but they must complete a course. The number of unique students in `course` is given by, 

```{r}
length(unique(course$mcid))
```
 
Summarize a quantitative variable. 

```{r}
summary(course$hours_course)
```

Examine a categorical variable and its values. 

```{r}
sort(unique(course$type))
```

### Exercises

1. Determine the possible values in the `faculty_rank` column. 
2. Determine the range of terms in `term` column. 
3. Determine the possible values in the `grade` column. 






## Inspect the `term` data

`term` is a data frame of `r var_terms` term-related variables with  observations of students who complete a term or remain in a program beyond their institution's term-withdrawal deadline. You can view the help page (and data dictionary) by running

```{r}
#| eval: false

# Run in Console
? term
```

Each observation is one term for one student keyed by student ID. To see the data structure, run

```{r}
str(term)
```

`term` has `r obs_terms` observations and occupies approximately `r size_terms` of memory. 

To be recorded in `term` (unlike `student`), students can be non-degree-seeking but they must complete a term. The number of unique students in `term` is given by, 

```{r}
length(unique(term$mcid))
```

Summarize some of the quantitative variables. 

```{r}
summary(term$hours_term)

summary(term$gpa_term)
```

Examine some categorical variables and their values.  

```{r}
sort(unique(term$level))

sort(unique(term$standing))
```




### Exercises

1. Determine the possible values in the `coop` column. 
2. Determine the range of terms in `term` column. 
3. Determine the median value of the `gpa_cumul` column. 





## Inspect the `degree` data

`degree` is a table of `r var_degrees` degree-related variables with observations of students who complete their program(s). You can view the help page (and data dictionary) by running

```{r}
#| eval: false

# Run in Console
? degree
```

Each observation is a unique combination of student and degree keyed by student ID. To see the data structure, run

```{r}
str(degree)
```

`degree` has `r obs_degrees` observations and occupies approximately `r size_degrees` memory.  The practice data include students earning a double degree (or more), thus the number of rows exceeds the number of unique IDs.

```{r}
nrow(degree)

length(unique(degree$mcid))
```

 

By student ID, the students in `degree` are a subset of the students in `student`. We can confirm by running the following, where a sum of `r length(unique(degree$mcid))`  indicates that all IDs in `degree` are present in `student`. 

```{r}
# Isolate IDs
degree_mcid <- unique(degree$mcid)
student_mcid <- unique(student$mcid)

# Sum of logical results, 1 for every TRUE, 0 for every FALSE
sum(degree_mcid %chin% student_mcid)
```

Examine some categorical variables and their values. 

```{r}
sort(unique(degree$institution))

sample(unique(degree$degree), 10)
```

Checking if any of the degrees are recorded as NA results in an empty table, thus all the students in `degree` are graduates. 

```{r}
degree[is.na(degree)]
```

### Exercises

Some packages have functions specialized for data frame summaries. Try this one---you may find it useful in future data explorations. 

1. Install the `skimr` package, load it with `library("skimr")`, and run `skim(x)`, where `x` is one of the data tables, for example, 

```{r}
#| eval: false

library(skimr)
skim(student)
skim(degree)
```




## Functions

The functions in midfieldr are briefly described in Table 2 with additional information available on the midfieldr [Reference](reference/reference/index.html) page. Detailed examples of usage are distributed throughout the vignettes. Two of the helper functions are discussed in sections below.   

```{r}
#| echo: false

wrapr::build_frame(
  "Function", "Action" |
    "add_completion_status()", "Determine degree completion status for every student" |
    "add_data_sufficiency()", "Determine data sufficiency for every student" |
    "add_timely_term()", "Determine a timely completion term for every student" |
    "filter_cip()", "Subset rows of CIP data to match search strings" |
    "order_multiway()", "Order the categories of multiway data for graphing" |
    "prep_fye_mice()", "Construct and format FYE data for multiple imputation" |
    "same_content()", "Test for equal content in two data tables" |
    "select_required()", "Reduce number of columns of a MIDFIELD source data table"
) |>
  kableExtra::kbl(
    align = "ll",
    caption = "Table 2: Functions provided in midfieldr."
  ) |>
  kableExtra::kable_paper(lightable_options = "basic", full_width = TRUE) |>
  kableExtra::column_spec(1, monospace = TRUE) |>
  kableExtra::column_spec(1:2, color = "black", background = "white") |>
  kableExtra::row_spec(c(0), background = "#c7eae5")
```






## `select_required()`

A midfieldr convenience function to reduce the number of columns of a MIDFIELD data table after loading. Using this function is optional. 

`select_required()` selects only those columns typically required by other midfieldr functions. Operates on a data frame to retain columns having names that match or partially match search terms. Rows are unaffected. 

The primary benefit is reducing screen clutter when viewing data frames during an interactive session. The disadvantage is that the deleted columns are unavailable unless you first set aside a copy of the source file or reload it using `data()` when you need it. 


*Arguments.*

- **`midfield_x`** &nbsp; MIDFIELD data frame, typically `student`, `term`, or `degree`. 

- **`select_add`** &nbsp; Optional character vector of search terms to add to the default vector given by `c("mcid", "institution", "race", "sex", "^term", "cip6", "level")`. Argument, if used, must be used by name.

*Before.* &nbsp; The original source file. 

```{r}
#| collapse: true
# Create a copy of the source file
source_term <- copy(term)
source_term[]
```

*After* &nbsp; The output retains only the variables required by other midfieldr functions.  

```{r}
# Select variables required by midfieldr functions
term <- select_required(source_term)
term[]
```

*Equivalent usage.* &nbsp; The following implementations yield identical results

```{r}
#| collapse: true

# Required argument explicitly named
x <- select_required(midfield_x = term)

# Required argument not named
y <- select_required(term)

# Optional argument, if used, must be named. NULL yields the default columns.
z <- select_required(term, select_add = NULL)
```


## `same_content()` 

In the code chunk just above, we claim the three results are equivalent. To verify that the three data tables have the same content, we use `same_content()`, a midfieldr function that wraps `all.equal()` for data.table objects that ignores row order, column order, and keys (if any). 

*Arguments.*

- **`x`, `y`** &nbsp; Two data frames or data.tables to compare. 

*Example.* &nbsp; Demonstrate the equivalence of the data tables from the previous section. 

```{r}
#| collapse: true
# Demonstrate equivalence
same_content(x, y)
same_content(x, z)
```

Demonstrate that row and column order are ignored. 

```{r}
#| collapse: true

# Two columns from student, use key to order rows
x <- student[, .(mcid, institution)]
setkey(x, mcid)
x[]

# Same information with different row order, column order, and key
y <- student[, .(institution, mcid)]
setkey(y, institution)
y[]

# Demonstrate equivalence
same_content(x, y)
```

If the two data tables do not have the same content, the printout indicates the types of differences. 

```{r}
#| collapse: true
# Demonstrate non-equivalence
same_content(student, degree)
```











## Reusable code: Getting started

We often conclude a vignette with a *Reusable code* section in two parts. 

- The first section, *Preparation*, describes the immediate prerequisites or "intake" required by the reusable code chunk.   

- The second section (labeled by the topic) provides the reusable code---a condensed version of midfieldr functionality explored in the vignette. In some cases the code can be used as-is; in others, the code must be edited to suit the goals of the project. 

*Preparation.* &nbsp; In this case, the only intakes are the source data tables.  

```{r}
#| eval: false

# Load source data
data(student, term, degree, package = "midfielddata")
```

*Initial data processing.* &nbsp; A summary code chunk for ready reference.  

```{r}
# Optional. Copy of source files with all variables
source_student <- copy(student)
source_term <- copy(term)
source_degree <- copy(degree)

# Optional. Select variables required by midfieldr functions
student <- select_required(source_student)
term <- select_required(source_term)
degree <- select_required(source_degree)
```











## References

<div id="refs"></div>



```{r}
#| echo: false

# to change the CSS file per https://github.com/rstudio/rmarkdown/issues/732
knitr::opts_chunk$set(echo = FALSE)
```

```{css}
blockquote {
    padding:     10px 20px;
    margin:      0 0 20px;
    border-left: 0px
}
caption {
    color:       #525252;
    text-align:  left;
    font-weight: normal;
    font-size:   medium;
    line-height: 1.5;
}
```
