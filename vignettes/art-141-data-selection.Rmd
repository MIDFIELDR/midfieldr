---
title: "Data selection"
vignette: >
  %\VignetteIndexEntry{Data selection}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
output: 
    rmarkdown::html_vignette:
        highlight: "tango"
        css: ["default", "midfieldr.css"]
bibliography: ../inst/REFERENCES.bib
link-citations: yes
always_allow_html: true
---

```{r child = "../man/rmd/common-setup.Rmd"}
```

```{r}
#| echo: false
knitr::opts_chunk$set(
  fig.path = "../man/figures/art-141-",
  message = FALSE
)
```

## Getting started

As shown in the [Preparing data three ways](art-140-preparing-data-three-ways.html) article.

```{r child = "../man/rmd/preparing-data-setup.Rmd"}
```






## Subsetting rows and columns

A common task when working with data is selecting a subset of rows,  columns, or both. 




### Indirect indexing

Using intermediate variables that refer to the values used to subset rows and columns.  We often construct intermediate variables `columns_we_want` and `rows_we_want` as indices for column and row subsetting to be used in more than one system example. The extra clarity is often worth the extra lines of code.  

*Task.* &nbsp; Prepare data to summarize domestic students by race, sex, and institution.

Our first step might be to subset columns (institution, race, sex, and us_citizen) and subset rows such that US citizenship is true. 

```{r}
# intermediate variable
columns_we_want <- c("institution", "race", "sex", "us_citizen")
```

```{r class.source = "base"}
# base R
rows_we_want <- student_df$us_citizen == "Yes"
result_df <- student_df[rows_we_want, columns_we_want, drop = FALSE]
```

```{r class.source = "dtbl"}
# data.table
rows_we_want <- student_dt$us_citizen == "Yes"
result_dt <- student_dt[rows_we_want, ..columns_we_want]
```

```{r class.source = "dplyr"}
# dplyr
rows_we_want <- student_tbl$us_citizen == "Yes"
result_tbl <- student_tbl %>%
  select(all_of(columns_we_want)) %>%
  filter(rows_we_want)
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```


*Comments*

- *base R.* When working with `[,]` always add a third argument `drop = FALSE` to ensure a data frame is returned. Base R's default behavior when selecting a single column is to return a vector. 

- *data.table.* The `..` notation indicates that `columns_we_want` refers to a character vector of column names and is not itself a column name. 

- *dplyr.* The added notation `all_of()` in effect serves the same purpose in dplyr as `..` does in data.table. 







### Direct indexing

Column and row selection that is typed directly into the subsetting operators `[,]` or `filter()` and `select()` without using intermediate variables. 

*Task.* &nbsp; Same as previous example. 

```{r class.source = "base"}
# base R
result_df <- student_df[student_df$us_citizen == "Yes",
  c("institution", "race", "sex", "us_citizen"),
  drop = FALSE
]
```

```{r class.source = "dtbl"}
# data.table
result_dt <- student_dt[us_citizen == "Yes", .(institution, race, sex, us_citizen)]
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- student_tbl %>%
  select(institution, race, sex, us_citizen) %>%
  filter(us_citizen == "Yes")
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```

*Comments*

- *base R.* For direct indexing, intermediate variable names in `[,]` are replaced verbatim by their values. 

- *data.table.* The notation `.()` subsets columns by name without quotation marks;  rows are subset without the `$` operator.

- *dplyr.* Similarly, `select()` operates on unquoted column names; rows are subset without the `$` operator. 






















### Subset rows with multiple conditions

Multiple logical conditions are combined with operators such as & (and), | (or), ! (not), etc.  

*Task.* &nbsp; Find IDs of transfer students with 15 or more credit hours transferred.   

When a variable is overwritten multiple times to get to a result, we will sometimes employ the variable `interim_df` as an intermediate variable. 

```{r}
columns_we_want <- c("mcid", "transfer", "hours_transfer")
```

```{r class.source="base"}
# base R
rows_we_want <- student_df$transfer == "First-Time Transfer" & student_df$hours_transfer >= 15
interim_df <- student_df[rows_we_want, columns_we_want, drop = FALSE]

# remove rows with NA in every column
rows_we_want <- rowSums(is.na(interim_df)) < ncol(interim_df)
result_df <- interim_df[rows_we_want, , drop = FALSE]
```

```{r class.source="dtbl"}
# data.table
result_dt <- student_dt[transfer == "First-Time Transfer" & hours_transfer >= 15, ..columns_we_want]
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- student_tbl %>%
  select(mcid, transfer, hours_transfer) %>%
  filter(transfer == "First-Time Transfer" & hours_transfer >= 15)
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```

*Comments*

- *base R.* Two steps required. Subset rows by the original logical conditions; then subset to remove rows with NA across all columns. `rowSums()` assigns 1 to TRUE and 0 to FALSE. If the number of NAs in a row is less than the number of columns, then that row contains non-NA data and we keep it.

- *data.table.* Multiple conditions separated by logical AND `&`. Does not generate all-NA rows as in base R.  

- *dplyr.* Similar. 





### Subset one column as a vector

*Task.* &nbsp; Obtain a vector of unique IDs in the `term` dataset.

```{r class.source="base"}
# base R
result_df <- term_df[, "mcid"]
result_df <- unique(result_df)
```

```{r class.source="dtbl"}
# data.table
result_dt <- term_dt[, mcid]
result_dt <- unique(result_dt)
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- term_tbl %>%
  pull(.data$mcid) %>%
  unique()
```

```{r}
str(result_dt)

all.equal(result_dt, result_df)
all.equal(result_dt, result_tbl)
```


*Comments*

- *base R.* For clarity, we deliberately write these steps in two lines of code. One could just as easily write the single line `result_df <- unique(term_df[, "mcid"])`.

- *data.table.* 

- *dplyr.* The conventional syntax would be `pull(mcid)` except for a subtle flaw in the current version of `pull()`. For details, see [@Layton:2024]. The dplyr function `distinct()` isn't used here because it applies to data frames, not vectors. 









## Removing records with incomplete data

An important variation of subsetting data is removing rows of data that have missing values. If appropriate, limit the dropped rows to those with missing values in specific columns. 

*Task.* &nbsp; We are asked to compare SAT scores by institution. Before doing any analysis, we first remove rows with missing SAT scores. 




### Using complete.cases

We select three columns, then obtain a logical vector with one entry per row of the data frame: TRUE if a row has no missing entries, FALSE otherwise. 

```{r class.source = "base"}
# base R
result_df <- student_df[, c("institution", "sat_math", "sat_verbal"), drop = FALSE]
result_df <- result_df[complete.cases(result_df), , drop = FALSE]
```

```{r class.source = "dtbl"}
# data.table
result_dt <- student_dt[, .(institution, sat_math, sat_verbal)]
result_dt <- result_dt[complete.cases(result_dt), ]
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- student_tbl %>%
  select(institution, sat_math, sat_verbal) %>%
  filter(complete.cases(.))
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```

*Comments*

- *base R.* Where before we used the name `columns_we_want` to reference a character vector of column names, here we use the character vector itself. 

- *data.table.* 

- *dplyr.* In magrittr pipe notation a dot `.` is taken to mean the item being piped. Here for example, the output of `select()` is piped to `filter()` then to `complete.cases(.)` --- the latter requiring the dot.  









### Using na.omit or equivalent

We can perform the same task without explicit Boolean row-selection in any of the systems. 

```{r class.source = "base"}
# base R
result_df <- student_df[, c("institution", "sat_math", "sat_verbal"), drop = FALSE]
result_df <- na.omit(result_df)
```

```{r class.source = "dtbl"}
# data.table
result_dt <- student_dt[, .(institution, sat_math, sat_verbal)]
result_dt <- na.omit(result_dt)
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- student_tbl %>%
  select(institution, sat_math, sat_verbal) %>%
  drop_na()
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```

*Comments*

- *base R.* 

- *data.table.*  

- *dplyr.* `drop_na()` is from the tidyr package. 













### Incomplete rows in specified columns

Delete rows with missing values in specified columns but retain all columns. Note that the number of rows matches the number in the previous example.  

```{r class.source = "base"}
# base R
row_index <- !(is.na(student_df$institution) |
  is.na(student_df$sat_math) |
  is.na(student_df$sat_verbal))
result_df <- student_df[row_index, , drop = FALSE]
```

```{r class.source = "dtbl"}
# data.table
result_dt <- na.omit(student_dt, cols = c("institution", "sat_math", "sat_verbal"))
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- student_tbl %>%
  drop_na(institution, sat_math, sat_verbal)
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```

*Comments*

- *base R.* Using logical operators `!` NOT and `|` OR to create a logical vector used as a row index. 

- *data.table.* The same function name `na.omit()` as base R but with an argument to drops rows with missing values in specified columns. Retains all columns. 

- *dplyr.* Similarly, `drop_na()` drops rows with missing values in  specified columns, retaining all columns. 









## Ordering rows

In some instances, it is important for us to control the order of rows in our data. 

*Task.* &nbsp; Suppose we want to know a student's level and declared major in their first term at their institution. We use the `term` dataset.  

We decide to order the rows first by institution, then by ID, then by term. In each case, we select columns in a separate operation so we can highlight the row-ordering operation.  

```{r}
columns_we_want <- c("institution", "mcid", "term", "level", "cip6")
```

```{r class.source = "base"}
# base R
interim_df <- term_df[, columns_we_want, drop = FALSE]

order_index <- with(interim_df, order(institution, mcid, term))
result_df <- interim_df[order_index, , drop = FALSE]
```

```{r class.source = "dtbl"}
# data.table
result_dt <- term_dt[, ..columns_we_want]

order_cols <- c("institution", "mcid", "term")
setorderv(result_dt, order_cols)
```

```{r class.source = "dplyr"}
# dplyr
result_tbl <- term_tbl %>%
  select(institution, mcid, term, level, cip6) %>%
  arrange(institution, mcid, term)
```

```{r}
result_dt

same_content(result_dt, data.table(result_df))
same_content(result_dt, data.table(result_tbl))
```

*Comments*

- *base R.* Using `with()`, we can list the variables to order by without using the `$` operator. 

- *data.table.* `setorderv()` reorders data in place---hence no assignment operator `<-` is required---and it operates on a character vector of column names.  

- *dplyr.* `arrange()` orders the rows of a data frame by the values of selected columns. 






## References

<div id="refs"></div>









```{r child = "../man/rmd/common-closing.Rmd"}
```
