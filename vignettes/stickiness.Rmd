---
title: "Stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: ../inst/REFERENCES.bib
---

```{r setup, echo = FALSE, message = FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(collapse = TRUE, comment = "#>")
opts_chunk$set(warning = TRUE, message = TRUE, cache = 0) # 0 FALSE 1 minimal
opts_chunk$set(error = TRUE, purl = FALSE)
opts_chunk$set(fig.width = 6)
options(tibble.print_min = 10L, tibble.print_max = 10L)
knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
```

```{r echo = FALSE}
library(midfieldr)
library(stringr)

# unpack data bits
library(midfieldstudents)
values_sex  <- str_c(sort(unique(midfieldstudents$sex)), collapse = ", ")
values_race <- str_c(sort(unique(midfieldstudents$race)), collapse = ", ")
```


"Stickiness" is a longitudinal persistence metric that tracks all students who contact an instructional program to determine what percentage “stick” to that program and graduate in it. Stickiness is defined as the ratio of the number of students graduating in a program to the number of students ever enrolled in the program.[@stickiness2012]

While you may choose your own grouping variables, because our research focuses on intersectionality, we typically group the stickiness data by program, sex, and "race" as defined by the participating US institutions for the years spanned in the data sample. Possible value for sex and race are:  

```{r}
# list unique values for sex and race from student demographics
library(midfieldstudents)
midfieldstudents[["sex"]]  %>%  unique() %>%  sort()
midfieldstudents[["race"]] %>%  unique() %>%  sort()
```



## Getting started 

In this article, we show you how to use midfieldr functions to compute program stickiness. Our workflow is: 

- select the programs 
- count the students ever enrolled
- count the students graduating  
- compute stickiness 
- graph stickiness 


If you are an R beginner, you can get the most out of this tutorial by 

- opening a new R script  
- copying or typing a line of code from the tutorial to your script 
- running your script after each new line is added 
- examining the result after each addition   






## Select the programs to study

For this example, we compare the stickiness of three engineering programs: Civil, Electrical, and Mechanical. Their 4-digit CIP codes were found by keyword search as illustrated in [Selecting CIP codes](cip_filter.html). 

We use:  

- `cip_filter()` to obtain the relevant program codes 
- `add_column()` (a [tibble](http://tibble.tidyverse.org) function) to add the user-defined `program` variable 


```{r warning = FALSE, message = FALSE}
# obtain CIP codes and names
library(dplyr)
library(tidyr)
library(tibble)
library(midfieldr)
cve <- cip_filter("^1408") %>% add_column(program = "Civil Engineering")
ele <- cip_filter("^1410") %>% add_column(program = "Electrical Engineering")
mce <- cip_filter("^1419") %>% add_column(program = "Mechanical Engineering")
```


Assigning a custom label via `program` is useful when a set of CIP codes does not already have a common name. For example, there is no CIP name for the Humanities group of programs.  

Next we bind the individual program data frames into one data frame. We use two [dplyr](http://dplyr.tidyverse.org) functions: 

- `bind_rows()` to bind the programs into one dataframe named `study_group` 
- `select()` to keep two variables: `CIP6` for finding the desired student records and `program` for grouping 

```{r}
# bind the four programs
study_group <- bind_rows(cve, ele, mce) %>%
  select(CIP6, program)
```

Examine the result: there are `r nrow(study_group)` CIP codes for these three programs. 

```{r}
# examine the result
study_group
```



## gather_ever()  

`gather_ever()` extracts a subset of `midfieldterms` containing all unique students ever enrolled in the programs listed in `study_group` and joins our user-defined `program` labels to these data. 

```{r}
# extract unique students from midfieldterms
library(midfieldterms)
unique_students <- gather_ever(midfieldterms, study_group)
```

`glimpse()` the result to check the number of observations and to view the first few values of each variable. 

```{r}
# examine the result
glimpse(unique_students)
```

## join_demographics() 

`join_demographics()` joins student race and sex from `midfieldstudents` to these data.  

```{r}
# join demographics from midfieldstudents
library(midfieldstudents)
unique_students <- join_demographics(unique_students)

# examine the result
glimpse(unique_students)
```


## count_and_fill()

Before counting students, we select the variables to use for grouping and summarizing. Here, for example, we select program, race, and sex (thereby omitting ID, CIP6, and institution). 

```{r}
# select the variables to use for counting
unique_students <- unique_students %>%
  select(program, sex, race)

# examine the result
glimpse(unique_students)
```

`count_and_fill()` counts the number of students grouped by the variables we just selected. If program, race, or sex are in the list, missing combinations  are filled with a zero. 

```{r}
# count ever enrolled and label the count "ever"
ever_enrolled <- count_and_fill(unique_students, "ever")

# examine the result
glimpse(ever_enrolled)
```

In summary, four functions are needed to gather and count the numbers of students ever enrolled in a set of programs. We can chain those functions together in one code chunk as follows: 

```{r}
# counting students ever enrolled in a program in one code chain
ever_enrolled <- gather_ever(midfieldterms, study_group) %>%
  join_demographics() %>%
  select(program, race, sex) %>%
  count_and_fill(., "ever")

# examine the result
glimpse(ever_enrolled)
```



## gather_grad() 

`gather_grad()` extracts a subset of `midfielddegrees` containing all unique students ever graduating from the programs listed in `study_group` and joins our user-defined `program` labels to these data.

```{r}
library(midfielddegrees)
first_degrees <- gather_grad(midfielddegrees, study_group)

glimpse(first_degrees)
```

We follow up with the same work flow used previously, with `join_demographics()`, `select()`, and `count_and_fill()`. Again, we can chain these functions together in one code chunk as follows:

```{r}
# count students graduating from programs 
graduated <- first_degrees %>%
  join_demographics() %>%
  select(program, race, sex) %>%
  count_and_fill(., "grad")

# examine the result
glimpse(graduated)
```





## tally_stickiness()

`tally_stickiness()` has two arguments: the `ever_enrolled` and  `graduated` data frames we constructed above. 


```{r}
stickiness <- left_join(ever_enrolled, graduated, by = c("program", "race", "sex")) %>% 
	mutate(stick = round(grad / ever, 3)) %>% 
	arrange(program, sex, race)
	
stickiness[is.na(stickiness)] <- NA
```


If we want to limit our results to a smaller set of race values, 

```{r}
stickiness <- stickiness %>% 
	filter(race %in% c("Asian", "Black", "Hispanic", "White"))
kable(stickiness)
```



## graph_stickiness()


## References
