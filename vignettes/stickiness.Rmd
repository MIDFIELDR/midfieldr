---
title: "Stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: ../inst/REFERENCES.bib
---

```{r setup, echo = FALSE, message = FALSE}
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = TRUE,
  purl = FALSE, 
  fig.width = 6, 
  fig.asp = 1/1.6, 
  out.width = "70%",  
  fig.align = "center"
)

knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
options(tibble.print_min = 10L, tibble.print_max = 10L)
```

"Stickiness" is the ratio of the number of students graduating in a program to the number of students ever enrolled in that program [@stickiness2012]. 

Unlike other longitudinal metrics such as graduation rate, stickiness accounts for every student the program had the opportunity to retain and graduate whether or not they started in the program. 

We typically group the stickiness results by program, sex, and "race" as defined by the participating US institutions.

## Getting started 

```{r message = FALSE}
# packages used in this article
library(midfieldr)
library(dplyr)
library(tidyr)
library(tibble)
library(ggplot2)
library(knitr)
library(stringr)
```

In this article, we show you how to use midfieldr functions to compute program stickiness. Our workflow is: 

- select the programs 
- count the students ever enrolled
- count the students graduating  
- compute stickiness 
- graph stickiness 


If you are an R beginner, you can get the most out of this tutorial by 

- opening a new R script  
- copying or typing a line of code from the tutorial to your script 
- running your script after each new line is added 
- examining the result after each addition   

## Select the programs to study

For this example, we compare the stickiness of four engineering programs: Civil, Electrical, Industrial, and Mechanical. Their 4-digit CIP codes were found by keyword search as illustrated in [Selecting CIP codes](cip_filter.html). 

We use:  

- `cip_filter()` to obtain the relevant program codes 
- `add_column()` (a [tibble](http://tibble.tidyverse.org) function) to add a user-defined `program` variable 


```{r warning = FALSE, message = FALSE}
# obtain 6-digit CIP and assign a custom program label
cve <- cip_filter("^1408") %>% add_column(program = "Civil Engineering")
ele <- cip_filter("^1410") %>% add_column(program = "Electrical Engineering")
mce <- cip_filter("^1419") %>% add_column(program = "Mechanical Engineering")
ise <- cip_filter("^1435") %>% add_column(program = "Industrial Engineering")
```

The custom label is used for grouping programs for graphing and to provide a shorter or common name for groups of programs. 

Next we bind the individual program data frames into one data frame. We use two [dplyr](http://dplyr.tidyverse.org) functions: 

- `bind_rows()` to bind the programs into one dataframe named `program_group` 
- `select()` to keep three variables: `CIP6` for finding the desired student records,  `program` for grouping, and `CIP6name` to check our custom program labels. 

```{r}
# bind the programs
program_group <- bind_rows(cve, ele, mce, ise) %>%
  select(CIP6, program, CIP6name)
```

Examine the result: there are `r nrow(program_group)` CIP codes for these three programs. Our shorter `program` labels agree with the longer  official `CIP6name` values. 

```{r}
# examine the result
program_group
```

## gather_ever()  

`gather_ever()` extracts a subset of `midfieldterms` containing all unique students ever enrolled in the programs listed in `program_group` and joins our user-defined `program` labels to these data. 

```{r}
# extract unique students from midfieldterms
students <- gather_ever(program_group)
```

`glimpse()` (a tibble function) the result to check the number of observations and to view the first few values of each variable. 

```{r}
# examine the result
glimpse(students)
```

## race_sex_join() 

`race_sex_join()` accepts any data frame with the MIDFIELD student `ID` variable and joins the student race and sex from `midfieldstudents` to these data. 

```{r}
students <- race_sex_join(students)

glimpse(students)
```

If the argument to `race_sex_join()` already includes a `sex` or `race` column, that column (or columns) is returned unchanged. For example, let's remove the sex variable from the current `students` data frame and reapply `race_sex_join()`. The output includes a message that `sex` was successfully joined and `race` returned unchanged. 

```{r message = TRUE}
students <- students %>%
  select(-sex) %>%
  race_sex_join()

glimpse(students)
```

## Count the numbers of students ever enrolled

We will use [dplyr](http://dplyr.tidyverse.org) functions to group and count the numbers of students ever enrolled in our programs. 

- `group_by()` to select the grouping variables 
- `summarize()` to count the number of students in each group 
- `ungroup()` to remove the grouping meta-information 

Here, we give the count the variable name `ever`. All variables in `students` not used as grouping variables are quietly dropped. 

```{r}
# count the numbers of students ever in a program
ever_enrolled <- students %>%
  group_by(program, race, sex) %>%
  summarize(ever = n()) %>% # assign the name "ever" to the count variable
  ungroup()
```

A similar chain of `dataframe %>% group_by() %>% summarize() %>% ungroup()`  is used every time we want to count numbers of students in a particular group. You are free to try any of the variables when counting, e.g., you could omit race and use `group_by(program, sex)`.

## zero_fill()

```{r echo = FALSE}
n_prog <- max(seq_along(unique(ever_enrolled$program)))
n_sex <- max(seq_along(unique(ever_enrolled$sex)))
n_race <- max(seq_along(unique(ever_enrolled$race)))
n_comb <- n_prog * n_sex * n_race
n_results <- nrow(ever_enrolled)
```

This example has `r n_prog` programs, `r n_sex` sexes, and `r n_race` race values, so we have `r n_prog` $\times$ `r n_sex` $\times$ `r n_race` = `r n_comb` possible combinations of program, sex, and race, yet our result above has only `r n_results` rows, not the expected `r n_comb`. This outcome tells us that one of the possible combinations is missing. 

The missing group, it happens, is Civil Engineering Native American Female. 

`zero_fill()` inserts a count of zero for missing combinations, ensuring that zero data values are not overlooked when printing data tables or constructing graphs. 

```{r}
# count ever enrolled and label the count "ever"
ever_enrolled <- zero_fill(ever_enrolled)

# examine the result
ever_enrolled
```

In summary, the following chain gathers and counts the numbers of students ever enrolled in a set of programs.

```{r eval = FALSE}
# counting students ever enrolled in a program (using one code chain)
ever_enrolled <- gather_ever(program_group) %>%
  race_sex_join() %>%
  group_by(program, race, sex) %>%
  summarize(ever = n()) %>% # assign the name "ever" to the count variable
  ungroup() %>%
  zero_fill()
```

## gather_grad() 

`gather_grad()` extracts a subset of `midfielddegrees` containing all unique students ever graduating from the programs listed in `program_group` and joins our user-defined `program` labels to these data. 

Similar to gathering the ever enrolled students, we can chain these functions together in one code chunk:

```{r}
# count students graduating from programs
graduated <- gather_grad(program_group) %>%
  race_sex_join() %>%
  group_by(program, race, sex) %>%
  summarize(grad = n()) %>% # assign the name "grad" to the count variable
  ungroup() %>%
  zero_fill()

# examine the result
glimpse(graduated)
```

## tally_stickiness()

`tally_stickiness()` has two arguments: the `ever_enrolled` and  `graduated` data frames we constructed above. 

The data frame returned has all the original columns plus the new `stick` variable, a fraction from zero to one, or `NA` if `ever` is 0. 

```{r}
stickiness <- tally_stickiness(ever_enrolled, graduated)

stickiness
```

## multiway_order() 


## References
