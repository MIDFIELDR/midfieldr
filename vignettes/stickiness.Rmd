---
title: "Stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE, message = FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(collapse = TRUE, comment = "#>")
opts_chunk$set(warning = TRUE, message = TRUE, cache = 0) # 0 FALSE 1 minimal
opts_chunk$set(error = TRUE, purl = FALSE)
opts_chunk$set(fig.width = 6)
options(tibble.print_min = 10L, tibble.print_max = 10L)
knit_hooks$set(inline = function(x) {
	if (!is.numeric(x)) { 
		x 
		} else if (x >= 10000) { 
		prettyNum(round(x, 2), big.mark = " ")
		} else {
		prettyNum(round(x, 2))
		}
	})
```



## Getting started 

"Stickiness" is a longitudinal persistence metric that tracks all students who contact an instructional program to determine what percentage “stick” to that program and graduate in it. Stickiness is defined as the ratio of the number of students graduating in a program to the number of students ever enrolled in the program.[^1]

<!-- footnote -->
[^1]: Matthew Ohland, Marisa Orr, Richard Layton, Susan Lord and Russell Long (2012) Introducing “stickiness” as a versatile metric of engineering persistence, in proc. *2012 Frontiers in Education Conference*, Seattle, WA, pp. 1--5. [DOI 10.1109/FIE.2012.6462214](http://dx.doi.org/10.1109/FIE.2012.6462214). 




In this article, we show you how to use midfieldr functions to compute program stickiness. Our workflow is: 

- select the programs 
- count the students ever enrolled
- count the students graduating  
- compute stickiness 
- graph stickiness 

Because our research focuses on intersectionality, we typically disaggregate the data by program, sex, and race/ethnicity.[^2] You may of course choose your own combination of variables to study. 





## Select the programs

For this example, we compare the stickiness of three engineering programs: Civil, Electrical, and Mechanical. Their 4-digit CIP codes were found by keyword search as illustrated in [Selecting CIP codes](cip_filter.html). 

We use:  

- `cip_filter()` to obtain the relevant program codes.  
- `add_column()` (a [tibble](http://tibble.tidyverse.org) function) to add the `PGRM` variable to the data frame: a custom program label we use later for grouping, counting, and graphing. 


```{r warning = FALSE, message = FALSE}
# obtain 2, 4, and 6-digit CIP codes and names
library(dplyr)
library(tibble)
library(midfieldr) 
cve <- cip_filter("^1408") %>% add_column(PGRM = "Civil Engineering")
ele <- cip_filter("^1410") %>% add_column(PGRM = "Electrical Engineering")
mce <- cip_filter("^1419") %>% add_column(PGRM = "Mechanical Engineering")
```


Assigning a custom label to `PGRM` is useful when the set of CIP codes we plan to group and count do not already have a common CIP name. For example, there is no CIP name for the general group of programs we might call Humanities. 

Selecting the values of `PGRM` is important when using collections not specifically identified as groups in the CIP dataset, e.g., Humanities, Physical Sciences, and the  collections provided in the midfieldr `named_series`.  

Next we bind the individual program data frames into one data frame. We use two [dplyr](http://dplyr.tidyverse.org) functions: 

- `bind_rows()` to bind the programs into one data frame ()
- `select()` to keep two variables: `CIP6` for finding the desired student records and `PGRM` for grouping.

```{r}
# bind the four programs
programs <- bind_rows(cve, ele, mce) %>% 
	select(CIP6, PGRM)
```

Examine the result: there are `r nrow(programs)` CIP codes for these three programs. 

```{r}
# examine the result
programs
```



## Count students ever enrolled 

A student contributes to a program's "ever enrolled" total if the program's CIP code appears in the student's `term` data. A student is counted once per program.  

To gather the students ever enrolled, we use:

- the midfieldr `term` data for term-by-term program information. 
- the midfieldr `student` data for student race/ethnicity and sex. 
- `gather_ever()` to gather students ever enrolled in `programs` and to add their race/ethnicity and sex to the data frame. 

```{r eval=FALSE}
# gather students ever enrolled in the programs
library(midfieldstudent)
library(midfieldterm)
ever <- gather_ever(term, programs)
```

```{r echo = FALSE}
# to save execution time during development
# the previous chunk echoes but does not execute
# this code chunk executes but does not echo
library(midfieldstudent)
library(midfieldterm)
# ever <- gather_ever(term, programs)
# devtools::use_data(ever, overwrite = TRUE, compress = 'bzip2')#temp
data(ever)
```

To examine the result of the operation, use `glimpse()`, a [tibble](http://tibble.tidyverse.org) function. 

```{r}
# examine the result
glimpse(ever)
```

<!-- footnote -->
```{r echo = FALSE}
# character values for the footnote
library(stringr)
sex_values    <- str_c(sort(unique(ever$SEX)), collapse = ", ")
ethnic_values <- str_c(sort(unique(ever$ETHNIC)), collapse = ", ")
```

[^2]: The possible values of race/ethnicity and sex categories are limited to those used by the participating US institutions. Thus sex is limited to the set  (`r sex_values`) and race/ethnicity is limited to the set (`r ethnic_values`). 



At this point, one decides how to group the the students for counting. In our example, we group by race/ethnicity, sex, and program. We use the following [dplyr](http://dplyr.tidyverse.org) functions:

- `count()` to group and count the students by program, ethnicity/race, and sex. The count is assigned to the default variable `n`. 
- `rename()` to rename `n` to `EVER` for the number of students in this group ever enrolled in the program. 
- `arrange()` to arrange the rows of the resulting data frame in order of descending magnitude of the count. 

```{r}
# count ever enrolled by grouping variables 
ever_count <- count(ever, PGRM, ETHNIC, SEX)  %>% 
	rename(EVER = n) %>% 
	arrange(desc(EVER))

# examine the result
ever_count
```



We can examine our saummarized data using [ggplot2](http://ggplot2.tidyverse.org). 

```{r}
# multiway graph of ever enrolled numbers 
library(ggplot2)
f1 <- ggplot(ever_count, aes(x = EVER, y = reorder(ETHNIC, EVER, median), col = SEX)) +
	geom_point(size = 2) + 	
	facet_wrap(~ reorder(PGRM, -EVER, median), ncol = 1) +
	labs(x = "Number of students ever enrolled", y = "") 
```

To format the graph, we use the following midfieldr graph functions: 

- `expon_scale_x_log10()` creates exponential powers-of-ten notation and logarithmic grid lines.  
- `midfield_theme()`, the ggplot `theme_minimal()` with some revisions. 
- `rcb()` yields a hexadecimal code for specific colors named in the `midfieldr::rcb_colors` dataset.  

```{r fig.width = 7.2, fig.asp = 0.9}
# format with midfieldr graph functions
f1 <- f1 +
	scale_color_manual(values = c(rcb("mid_Br"), rcb("mid_BG"))) + 
	expon_scale_x_log10() +
	midfield_theme() 

print(f1)
```

For the rationale underlying the design of this "multiway" graph, see our [Multiway data and graphs](multiway.html) discussion.




## Count students graduating 

To gather the students graduating from a program, we use:

- `student` dataset for student race/ethnicity and sex. 
- `degree` dataset for the programs from which students graduate. 
- `midfieldr::gather_grad()` to subset `degree` for those students graduating from `programs` and add variables `ETHNIC` and `SEX`. 

```{r}
glimpse(degree)
sort(unique(degree$GCIP))
sort(unique(degree$GCIP2))
sort(unique(degree$GCIP3))
```

```{r}
library(stringr)
# draft of gather_grad()
gather_grad <- function(degree, programs) {
	
	# select only those variables likely to be used for grouping
	grad <- degree %>%
		dplyr::select(MID, GYEAR, GTERM, INSTITUTION, GCIP, GCIP2, GCIP3)
	
	# keep the earliest term in which a student earns a degree
	grad <- grad %>%
		arrange(MID, GYEAR, GTERM) %>%
		group_by(MID) %>%
		filter(row_number(MID) == 1) %>%
		ungroup()
	
	# gather all 6-digit codes (GCIP, GCIP2, GCIP3) for multiple degrees
	# omit rows with no second or third degree
	grad <- grad %>%
		tidyr::gather(GCIPN, CIP6, GCIP:GCIP3) %>%
		filter(!is.na(GCIPN)) 
	
	# collapse the programs CIP6 vector to a search string
	# then filter grad for the desired programs
	series <- stringr::str_c(programs$CIP6, collapse = "|")
	grad <- grad %>%
		dplyr::filter(str_detect(CIP6, series)) %>%
		unique()
	
	# Join the program labels to grad
	grad <- left_join(grad, programs, by = "CIP6") %>%
		dplyr::arrange(CIP6)

	# Join the sex and ethnicity/race demographics from student
	grad <- join_demographics(grad)
	
	return(grad)
}
```


```{r}
grad <- gather_grad(degree, programs)
glimpse(grad)
```



```{r}
library(tidyr)
# count graduates by grouping variables 
grad_count <- count(grad, PGRM, ETHNIC, SEX)  %>% 
	rename(GRAD = n) %>% 
	arrange(desc(GRAD))

# examine the result
grad_count

# join ever and grad
stickiness <- left_join(ever_count, grad_count, by = c("PGRM", "ETHNIC", "SEX")) 

# if GRAD is NA, due to join with EVER. Is correctly set to zero 
stickiness <- stickiness %>% 
	replace_na(list(GRAD = 0))

# compute stickiness
stickiness <- stickiness %>% 
	mutate(STICK = round(GRAD / EVER, 2))

	
												
kable(stickiness)
```

```{r}
# select only those variables likely to be used for grouping
grad <- degree %>%
	dplyr::select(MID, GYEAR, GTERM, INSTITUTION, GCIP, GCIP2, GCIP3)


unique(grad$GCIP2)
unique(grad$GCIP3)
```

```{r}
# keep the earliest term in which a student earns a degree
one_degree <- grad %>%
	filter(is.na(GCIP2) & is.na(GCIP3)) %>%
	arrange(MID, GYEAR, GTERM)  %>% 
	unique() %>%
 	group_by(MID) %>%
 	filter(row_number(MID) == 1) %>%
	ungroup()
glimpse(one_degree)

unique(one_degree$GCIP2)
unique(one_degree$GCIP3)

```

Gather the GCIPs into a single column

```{r}
one_degree <- one_degree %>% 
	gather(GCIPN, CIP6, GCIP:GCIP3) %>% 
	filter(!is.na(CIP6))

glimpse(one_degree)
```


Now count

```{r}

```




## Compute stickiness 



## Graph stickiness 





## cleanup 

delete the temp data save 
```{r}
# unlink("data/ever.rda")
```

