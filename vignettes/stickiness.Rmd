---
title: "Stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: ../inst/REFERENCES.bib
---

```{r setup, echo = FALSE, message = FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(collapse = TRUE, comment = "#>")
opts_chunk$set(warning = FALSE, message = FALSE, cache = 0) # 0 FALSE 1 minimal
opts_chunk$set(error = TRUE, purl = FALSE)
opts_chunk$set(fig.width = 6)
options(tibble.print_min = 10L, tibble.print_max = 10L)
knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
```

```{r echo = FALSE}
library(midfieldr)
library(stringr)

# unpack data bits
library(midfieldstudents)
values_sex  <- str_c(sort(unique(midfieldstudents$sex)), collapse = ", ")
values_race <- str_c(sort(unique(midfieldstudents$race)), collapse = ", ")
```


"Stickiness" is a longitudinal persistence metric that tracks all students who ever enrolled in an instructional program to determine what percentage "stick" to that program and graduate in it. 

Stickiness is defined as the ratio of the number of students graduating in a program to the number of students ever enrolled in the program [@stickiness2012]. We typically group the stickiness results by program, sex, and "race" as defined by the participating US institutions.

## Getting started 

```{r}
# packages used in this article
library(midfieldr)
library(midfieldstudents)
library(midfieldterms)
library(midfielddegrees)
library(dplyr)
library(tidyr)
library(tibble)
```


In this article, we show you how to use midfieldr functions to compute program stickiness. Our workflow is: 

- select the programs 
- count the students ever enrolled
- count the students graduating  
- compute stickiness 
- graph stickiness 


If you are an R beginner, you can get the most out of this tutorial by 

- opening a new R script  
- copying or typing a line of code from the tutorial to your script 
- running your script after each new line is added 
- examining the result after each addition   






## Select the programs to study

For this example, we compare the stickiness of three engineering programs: Civil, Electrical, and Mechanical. Their 4-digit CIP codes were found by keyword search as illustrated in [Selecting CIP codes](cip_filter.html). 

We use:  

- `cip_filter()` to obtain the relevant program codes 
- `add_column()` (a [tibble](http://tibble.tidyverse.org) function) to add a user-defined `program` variable 


```{r warning = FALSE, message = FALSE}
# obtain the CIP codes for three engineering majors and assign our own program label
cve <- cip_filter("^1408") %>% add_column(program = "Civil Engineering")
ele <- cip_filter("^1410") %>% add_column(program = "Electrical Engineering")
mce <- cip_filter("^1419") %>% add_column(program = "Mechanical Engineering")
```

Assigning a custom label via `add_column()` is helpful when a set of CIP codes does not already have a common or brief name. For example, courses we would group together as the humanities do not have a single CIP name.   

Next we bind the individual program data frames into one data frame. We use two [dplyr](http://dplyr.tidyverse.org) functions: 

- `bind_rows()` to bind the programs into one dataframe named `program_group` 
- `select()` to keep three variables: `CIP6` for finding the desired student records,  `program` for grouping, and `CIP6name` to check our custom program labels. 

```{r}
# bind the programs
program_group <- bind_rows(cve, ele, mce) %>%
  select(CIP6, program, CIP6name)
```

Examine the result: there are `r nrow(program_group)` CIP codes for these three programs. Our shorter `program` labels agree with the longer  official `CIP6name` values. 

```{r}
# examine the result
program_group
```



## gather_ever()  

`gather_ever()` extracts a subset of `midfieldterms` containing all unique students ever enrolled in the programs listed in `program_group` and joins our user-defined `program` labels to these data. 

```{r}
# extract unique students from midfieldterms
students <- gather_ever(program_group)
```

`glimpse()` (a tibble function) the result to check the number of observations and to view the first few values of each variable. 

```{r}
# examine the result
glimpse(students)
```

## race_sex_join() 

`race_sex_join()` accepts any data frame with the MIDFIELD student `ID` variable and joins the student race and sex from `midfieldstudents` to these data.  

```{r}
# join demographics from midfieldstudents
students <- race_sex_join(students)

# examine the result
glimpse(students)
```













## Count the numbers of students ever enrolled

We will use two [dplyr](http://dplyr.tidyverse.org) functions to group and count the numbers of students ever enrolled in our programs. 

- `group_by()` to select the grouping variables 
- `summarize()` to count the number of students in each group 

Here, we give the count the variable name `ever`. All variables in `students` not used as groupipng variables are quietly dropped. 

```{r}
# count the numbers of students ever in a program 
ever_enrolled <- students %>%
	group_by(program, race, sex) %>%
	summarize(ever = n()) %>% 
	ungroup()
```

A similar chain of `dataframe %>% group_by() %>% summarize() %>% ungroup()`  is used every time we want to count numbers of students in a particular group. You are free to try any of the variables when counting, e.g., you could omit race and use `group_by(program, sex)`.

Before examining a result, it is often useful to use `arrange()` (a dplyr function) to order the rows of the dataframe.  

```{r}
# order the rows for viewing
ever_enrolled <- ever_enrolled %>% 
	arrange(program, sex, race)

# examine the result
ever_enrolled
```

 







## zero_fill()

This example has 3 programs, 2 sexes, and 8 race values, so we would expect to have $3 \times 2 \times 8 = 48$ rows in our data frame. However, our results above show 47 rows. One of the possible combinations of program, race, and sex (Native American Female in Civil Engineering) is missing. 

`zero_fill()` inserts a count of zero for missing combinations. 

```{r}
zero_fill_2 <- function(df) {
	# for gather() and spread() key-value pairs, the "key" is any  
	# character variable and the "value" is the single numerical variable
	
	# must be a df
	stopifnot(is.data.frame(df))
	# obtain type of variables to distinguish character fron numeirc
	var_types <- sapply(df, typeof)
		# obtain list of symbolic variable names to recover column order
	var_name_list <- rlang::syms(names(df))

  # must have only one numerical count value
  value_idx <- var_types[var_types == "double" | var_types == "integer"]
  value_len <- max(seq_along(value_idx))
  stopifnot(value_len == 1)
  
  # must have at least two character variables for spread/gather
  key_idx <- var_types[var_types == "character"]
  key_len <- max(seq_along(key_idx))
  stopifnot(key_len >= 2)
  
  # acquire the names for the "key-value" pair
  key_names  <- names(key_idx)
  value_name <- names(value_idx)
  
  # select the "key" and "value" variables for spread() and gather() 
  key   <- rlang::sym(key_names[[1]])
  value <- rlang::sym(value_name[[1]])
  
  # obtain the first and last value of the key for gathering
  df <- df %>% dplyr::arrange(!!key)
  key_level_1 <- utils::head(unique(df[[key]]), n = 1)
  key_level_n <- utils::tail(unique(df[[key]]), n = 1)
  
  # spread, creates NA for missing combinations, fill NA with zero, and gather
  df <- df %>%
  	tidyr::spread(!!key, !!value, fill = 0) %>%
  	tidyr::gather(!!key, !!value, key_level_1:key_level_n) %>% 
  	select(!!!var_name_list)
}
```

```{r}
ever_enrolled

# count ever enrolled and label the count "ever"
ever_enrolled <- zero_fill_2(ever_enrolled)

# examine the result
ever_enrolled
```

In summary, the following chain gathers and counts the numbers of students ever enrolled in a set of programs.

```{r}
# counting students ever enrolled in a program in one code chain
ever_enrolled <- gather_ever(program_group) %>%
  race_sex_join() %>%
	group_by(program, race, sex) %>%
	summarize(ever = n()) %>% 
	ungroup() %>% 
  zero_fill_2()

# examine the result
glimpse(ever_enrolled)
```



## gather_grad() 

`gather_grad()` extracts a subset of `midfielddegrees` containing all unique students ever graduating from the programs listed in `program_group` and joins our user-defined `program` labels to these data.

```{r}
# obtain graduates from midfielddegrees data
first_degrees <- gather_grad(midfielddegrees, program_group)

glimpse(first_degrees)
```

We follow up with the same work flow used previously, with `race_sex_join()`, `select()`, and `zero_fill()`. Again, we can chain these functions together in one code chunk as follows:

```{r}
# count students graduating from programs 
graduated <- first_degrees %>%
  race_sex_join() %>%
  select(program, race, sex) %>%
  zero_fill(., "grad")

# examine the result
glimpse(graduated)
```





## tally_stickiness()

`tally_stickiness()` has two arguments: the `ever_enrolled` and  `graduated` data frames we constructed above. 


```{r}
stickiness <- left_join(ever_enrolled, graduated, by = c("program", "race", "sex")) %>% 
	mutate(stick = round(grad / ever, 3)) %>% 
	arrange(program, sex, race)
	
stickiness[is.na(stickiness)] <- NA
```


If we want to limit our results to populations with higher numbers, 

```{r}
stickiness <- stickiness %>% 
	filter(race %in% c("Asian", "Black", "Hispanic", "White"))
kable(stickiness)
```



## graph_stickiness()


## References
