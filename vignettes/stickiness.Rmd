---
title: "Stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
bibliography: ../inst/REFERENCES.bib
resource_files:
  - ../man/figures/stickiness-fig1-1.png
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE, message = FALSE, purl = FALSE}
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(
	echo = TRUE, # varies from one Rmd to another 
  message = TRUE,
  warning = TRUE, 
  collapse = TRUE,
  comment = "#>",
  error = TRUE,
  purl = FALSE, 
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center",
  fig.path = "../man/figures/stickiness-"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
options(tibble.print_min = 8L, tibble.print_max = 8L)

# normally, purl is FALSE. But in some code chunks, I want purl = TRUE so that # the code in the vignette is executed to pass R CMD check. These next few 
# lines set that up. In the code chunk header, add opts.label = 'dopurl'
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_template$set(dopurl = list(purl = TRUE, error = FALSE))
```

Longitudinal "stickiness" is the ratio of the number of students graduating in a program to the number of students ever enrolled in that program [@stickiness2012]. 

Thus the stickiness metric accounts for all students a program had the most immediate opportunity to retain and graduate---the students were, after all, enrolled in the program at one time. 

We typically group stickiness results by program, biological sex (we have no data on gender identity), and "race" as defined by the participating US institutions. 

## Getting started 

```{r message = FALSE}
# packages used
library(midfieldr)
library(tidyverse)
```

In this article, we show you how to use midfieldr functions to compute program stickiness. Our workflow is: 

- select the programs 
- count the students ever enrolled
- count the students graduating  
- compute stickiness 
- create a graph  

If you are an R beginner, you can get the most out of this tutorial by 

- opening a new R script  
- copying or typing a line of code from the tutorial to your script 
- running your script after each new line is added 
- examining the result after each addition   

## Select the programs to study

For this example, we compare the stickiness of four engineering programs: Civil, Electrical, Industrial, and Mechanical. Their 4-digit CIP codes (1408, 1410, 1419, 1435) were found by keyword search as illustrated in [Selecting CIP codes](cip_filter.html). 

We use:  

- `cip_filter()` to obtain the relevant program codes 
- `cip_label()` to assign our own program label  

```{r}
# obtain the electrical engineering subset of CIPs
ele <- cip_filter(series = "^1410") 

# check the 4-digit program name
unique(ele$cip4name)
```

In this case, the default program name is inconveniently long. We add a new column to the `ele` data frame with our own shorter program label using 
`cip_label()`. 

```{r}
# add a shorter program label
ele <- cip_label(data = ele, program = "Electrical Engineering")

# check the result
ele
```

For the next three programs, the default 4-digit program name is an acceptable program label. 

```{r}
# civil engineering
cve <- cip_filter(series = "^1408") %>% cip_label(program = "cip4name")

# mechanical engineering
mce <- cip_filter(series = "^1419") %>% cip_label(program = "cip4name")

# industrial and systems engineering
ise <- cip_filter(series = "^1435") %>% cip_label(program = "cip4name")
```

We use `bind_rows()`, a [dplyr](http://dplyr.tidyverse.org) function, to bind the programs into one data frame named `program_group`. 

```{r}
# bind the programs
program_group <- bind_rows(cve, ele, mce, ise)
```

Examine the result: there are a total of 12 CIP codes for these programs. We have 7 columns: 6 from the `cip` dataset and the one `program` column of labels we added using `cip_label()`. 

```{r}
# check the result
program_group
```

## gather_ever()  

`gather_ever()` extracts a subset of the `midfieldterms` data containing all unique students ever enrolled in the programs listed in `program_group` and joins our user-defined `program` labels to these data. 

```{r}
# extract unique students from midfieldterms
students <- gather_ever(program_group)
```

`glimpse()` (a [tibble](http://tibble.tidyverse.org) function) the result to check the number of observations and to view the first few values of each variable. 

```{r}
# check the result
glimpse(students)
```

## race_sex_join() 

`race_sex_join()` accepts any data frame with the MIDFIELD student `id` variable and joins the student race and sex from the `midfieldstudents` data to these data. 

```{r}
students <- race_sex_join(students)

# check the result
glimpse(students)
```

If the argument to `race_sex_join()` already includes a `sex` or `race` column, that column (or columns) is returned unchanged.

## Count the numbers of students ever enrolled

We will use [dplyr](http://dplyr.tidyverse.org) functions to group and count the numbers of students ever enrolled in our programs. 

- `group_by()` to select the grouping variables 
- `summarize()` to count the number of students in each group 
- `ungroup()` to remove the grouping meta-information 

All variables in `students` not used as grouping variables are quietly dropped. The assigned count variable is `ever`.  

```{r}
# count the numbers of students ever in a program
ever_enrolled <- students %>%
  group_by(program, race, sex) %>%
  summarize(ever = n()) %>%
  ungroup()

# check the result
ever_enrolled
```

You can change how you group the data by changing the arguments of `group_by()`.  

## zero_fill()

```{r echo = FALSE, opts.label = 'dopurl'}
# use the dopurl hook to make these values available for the inline 
# expressions in the next paragraph during R CMD check. Causes this code 
# chunk to be written to vignettes/*.R 
n_prog <- length(unique(ever_enrolled$program))
n_sex  <- length(unique(ever_enrolled$sex))
n_race <- length(unique(ever_enrolled$race))
n_comb <- n_prog * n_sex * n_race
n_obs  <- dim(ever_enrolled)[[1]]
```

This example has `r n_prog` programs, `r n_sex` sexes, and `r n_race` race values, yielding `r n_comb` possible combinations. Yet our result above has only `r n_obs` observations, not the expected `r n_comb`. This outcome tells us that one of the possible combinations is missing.

The missing group, it happens, is Civil Engineering Native American Female. 

`zero_fill()` inserts a count of zero for missing combinations, ensuring that zero data values are not overlooked when printing data tables or constructing graphs.  The arguments of `zero_fill()` must be identical to the arguments of `group_by()` used earlier. 

```{r}
ever_enrolled <- ever_enrolled %>%
  zero_fill(program, race, sex)
```

The output message `Joining, by = c("program", "race", "sex")` indicates that data  has been successfully joined to its expanded version containing all combinations of these three variables.   

```{r}
# examine the result
ever_enrolled
```

In summary, the following chain gathers and counts the numbers of students ever enrolled in a set of programs.

```{r eval = FALSE}
# counting students ever enrolled in a program (using one code chain)
ever_enrolled <- gather_ever(program_group) %>%
  race_sex_join() %>%
  group_by(program, race, sex) %>%
  summarize(ever = n()) %>%
  ungroup() %>%
  zero_fill(program, race, sex)
```

## gather_grad() 

`gather_grad()` extracts a subset of the `midfielddegrees` data containing the  unique students ever graduating from the programs listed in `program_group` and joins our user-defined `program` labels to these data. 

Similar to gathering the ever enrolled students, we can chain these functions together in one code chunk. Here, the assigned count variable is `grad`.  

```{r}
# count students graduating from programs
graduated <- gather_grad(program_group) %>%
  race_sex_join() %>%
  group_by(program, race, sex) %>%
  summarize(grad = n()) %>%
  ungroup() %>%
  zero_fill(program, race, sex)

# check the result
graduated
```

## tally_stickiness()

`tally_stickiness()` has two arguments: `ever` and `grad` data frames. The two data frames are joined by the variables they have in common.   

The function returns a data frame with all the original variables plus a column for the stickiness variable `stick`. Stickiness is reported as a fraction between 0 and 1, or NA if the ever count for a group is zero.   

```{r echo = -1}
options(tibble.print_min = 10L)
stickiness <- tally_stickiness(ever_enrolled, graduated)

# check the result
stickiness
```

## multiway_order() 

Before structuring the data for graphing, we select the populations we are interested in. For example, we might omit students for whom the "race" designation is ambiguous. This step could have been taken earlier, but must be taken (if at all) before using `multiway_order()`. 

We use `filter()` (a [dplyr](http://dplyr.tidyverse.org) function) to keep all rows except those in which race is Unknown, International, or Other.  

```{r}
stickiness_multiway <- stickiness %>%
  filter(!race %in% c("Unknown", "International", "Other"))
```

We structure the stickiness results as *multiway* data by combining student race and sex into a single `race_sex` variable. The [Multiway](multiway.html) article explains multiway data and graphs in detail. 

We use: 

- `mutate()` (a [dplyr](http://dplyr.tidyverse.org) function) to create a new variable 
- `str_c()` (a [stringr](http://stringr.tidyverse.org) function) to combine the race and sex strings 
- `select()` (a [dplyr](http://dplyr.tidyverse.org) function) to keep three variables only 

```{r}
# create the race_sex variable
stickiness_multiway <- stickiness_multiway %>%
  mutate(race_sex = str_c(race, sex, sep = " ")) %>%
  select(program, race_sex, stick)

# check the result
stickiness_multiway
```

`multiway_order()` converts the character variables `program` and `race_sex` into *factors* and orders the levels of the two factors by the relevant stickiness medians. `glimpse()` shows that the two categorical variables are now factors.

```{r}
# convert the data to a multiway structure
stickiness_multiway <- multiway_order(stickiness_multiway)

# check the result
stickiness_multiway
```

## Graphing the multiway

By using `multiway_order()` to condition the data, the rows and panels of the multiway graph will be ordered by the appropriate medians. We use conventional ggplot2 functions applied to the `stickiness` data frame: 

- `stick` is the quantitative x-variable 
- `race_sex` is the y-variable forming the rows of the panels 
- `program` in `facet_wrap()` conditions the panels  
- `as.table = FALSE` places the panels in ascending order from bottom to top 
- `geom_point()` creates the data markers; any NA values are removed by `na.rm = TRUE` 
- `labs()` assign axis labels 

```{r fig1, fig.asp = 2/1.6}
ggplot(stickiness_multiway, aes(x = stick, y = race_sex)) +
  facet_wrap(~ program, ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "") +
  theme_midfield()
```

We also apply our own `theme_midfield()` to edit the visual properties of the graph: axes, legends, panels, strips, etc. Open the help page by running

```r
?theme_midfield()
```

## Complete script

For reference, the complete script for this example is collected below. 

```{r eval = FALSE}
# packages used
library(midfieldr)
library(tidyverse)

# obtain 6-digit CIPs and assign custom program labels
cve <- cip_filter(series = "^1408") %>% cip_label(program = "cip4name")
ele <- cip_filter(series = "^1410") %>% cip_label(program = "Electrical Engineering")
mce <- cip_filter(series = "^1419") %>% cip_label(program = "cip4name")
ise <- cip_filter(series = "^1435") %>% cip_label(program = "cip4name")

# bind the programs in a single data frame 
program_group <- bind_rows(cve, ele, mce, ise)

# count students ever enrolled in programs
ever_enrolled <- gather_ever(program_group) %>%
	race_sex_join() %>%
	group_by(program, race, sex) %>%
	summarize(ever = n()) %>%
	ungroup() %>%
	zero_fill(program, race, sex)

# count students graduating from programs
graduated <- gather_grad(program_group) %>%
	race_sex_join() %>%
	group_by(program, race, sex) %>%
	summarize(grad = n()) %>%
	ungroup() %>%
	zero_fill(program, race, sex)

# compute stickiness of programs 
stickiness <- tally_stickiness(ever_enrolled, graduated)

# prepare the data for graphing in a multiway plot 
stickiness_multiway <- stickiness %>% 
	filter(!race %in% c("Unknown", "International", "Other")) %>%
	mutate(race_sex = str_c(race, sex, sep = " ")) %>%
	select(program, race_sex, stick) %>%
	multiway_order()

# create graph
ggplot(stickiness_multiway, aes(x = stick, y = race_sex)) +
	facet_wrap(~ program, ncol = 1, as.table = FALSE) +
	geom_point(na.rm = TRUE) +
	labs(x = "Stickiness", y = "") +
	theme_midfield()
```


## References
