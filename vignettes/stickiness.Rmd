---
title: "Stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE, message = FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(collapse = TRUE, comment = "#>")
opts_chunk$set(warning = TRUE, message = TRUE, cache = 0) # 0 FALSE 1 minimal
opts_chunk$set(error = TRUE, purl = FALSE)
opts_chunk$set(fig.width = 6)
options(tibble.print_min = 10L, tibble.print_max = 10L)
knit_hooks$set(inline = function(x) {
	if (!is.numeric(x)) { 
		x 
		} else if (x >= 10000) { 
		prettyNum(round(x, 2), big.mark = " ")
		} else {
		prettyNum(round(x, 2))
		}
	})
```



## Getting started 

"Stickiness" is a longitudinal persistence metric that tracks all students who contact an instructional program to determine what percentage “stick” to that program and graduate in it. Stickiness is defined as the ratio of the number of students graduating in a program to the number of students ever enrolled in the program.[^1]

[^1]: Matthew Ohland, Marisa Orr, Richard Layton, Susan Lord and Russell Long (2012) Introducing “stickiness” as a versatile metric of engineering persistence, in proc. *2012 Frontiers in Education Conference*, Seattle, WA, pp. 1--5. [DOI 10.1109/FIE.2012.6462214](http://dx.doi.org/10.1109/FIE.2012.6462214). 

In this article, we show you how to use functions in midfieldr to compute program stickiness. Our workflow is: 

- select the programs 
- count the students ever enrolled
- count the students graduating  
- compute stickiness 
- graph stickiness 

Because our research focuses on intersectionality, we typically disaggregate the data by program, sex, and race/ethnicity. You may of course choose your own combination of variables to study. 



## Select the programs

For this example, we compare the stickiness of three engineering programs: Civil, Electrical, and Mechanical. Their 4-digit CIP codes were found by keyword search as illustrated in [Selecting CIP codes](cip_filter.html). 

We use:  

- `midfieldr::cip_filter()` to obtain the relevant program codes.  
- `tibble::add_column()`  to label the program groups we've defined. The `PGRM` variable is handy later for grouping data and for titling graph panels. 

```{r warning = FALSE, message = FALSE}
# obtain 2, 4, and 6-digit CIP codes and names
library(dplyr)
library(tibble)
library(midfieldr) 
cve <- cip_filter("^1408") %>% add_column(PGRM = "Civil Engineering")
ele <- cip_filter("^1410") %>% add_column(PGRM = "Electrical Engineering")
mce <- cip_filter("^1419") %>% add_column(PGRM = "Mechanical Engineering")
```

Selecting our own program label `PGRM` is important when using collections not specifically identified as groups in the CIP dataset, e.g., Humanities, Physical Sciences, and the  collections provided in `midfieldr::named_series`.  

Next we bind the individual program data frames into one data frame. We use: 

- `dplyr::bind_rows()` to bind the programs into one data frame 
- `dplyr::select()` to keep two variables: `CIP6` for finding the desired student records and `PGRM` for grouping.

```{r}
# bind the four programs
programs <- bind_rows(cve, ele, mce) %>% 
	select(CIP6, PGRM)

# examine the result
programs
```



## Count students ever enrolled 

A student contributes to a program's "ever enrolled" total if the program's CIP code appears in the student's `term` data. Each unique student/program combination is counted only once.  

To gather the students ever enrolled, we use:

- `student` dataset for student race/ethnicity and sex. 
- `term` dataset for the programs in which students are enrolled term-by-term. 
- `midfieldr::gather_ever()` to subset `term` for those students ever enrolled in `programs` and add variables `ETHNIC` and `SEX`. 

```{r}
# gather students ever enrolled in the programs
library(midfieldstudent)
library(midfieldterm)
# saves time instead of caching
# ever <- gather_ever(term, programs)
# devtools::use_data(ever, overwrite = TRUE, compress = 'bzip2')#temp
data(ever)

# examine the result
glimpse(ever)
```

At this point, one decides how to group the the students for counting. In our example, we group by race/ethnicity, sex, and program. We use:

- `dplyr::count()` to group and count the students by program, ethnicity/race, and sex. The count is assigned to the default variable `n`. 
- `dplyr::rename()` to rename `n` to `EVER` for the number of students in this group ever enrolled in the program. 
- `dplyr::arrange()` to arrange the rows of the resulting data frame in order of descending magnitude of the count. 

```{r}
# count ever enrolled by grouping variables 
ever_count <- count(ever, PGRM, ETHNIC, SEX)  %>% 
	rename(EVER = n) %>% 
	arrange(desc(EVER))

# examine the result
ever_count
```

To get a sense of the data, we visualize it using a "multiway" graph. (See [Multiway data and graphs](multiway.html) for an in-depth discussion of multiways.)  To construct the graph, we use ggplot2 and the following midfieldr graph functions: 

- `midfieldr::expon_scale_x_log10()` creates exponential powers-of-ten notation and logarithmic grid lines.  
- `midfieldr::midfield_theme()`, the ggplot `theme_minimal()` with some revisions. 
- `midfieldr::rcb()` yields a hexadecimal code for specific colors named in the `midfieldr::rcb_colors` dataset.  

```{r fig.width = 7.2, fig.asp = 0.9}
# multiway graph of ever enrolled numbers 
library(ggplot2)
ggplot(ever_count, aes(x = EVER, y = reorder(ETHNIC, EVER, median), col = SEX)) +
	geom_point(size = 2) + 	
	facet_wrap(~ reorder(PGRM, -EVER, median), ncol = 1) +
	labs(x = "Number of students ever enrolled", y = "") +
	scale_color_manual(values = c(rcb("mid_Br"), rcb("mid_BG"))) + 
	expon_scale_x_log10() +
	midfield_theme() 
```



## Count students graduating 

To gather the students graduating from a program, we use:

- `student` dataset for student race/ethnicity and sex. 
- `degree` dataset for the programs from which students graduate. 
- `midfieldr::gather_grad()` to subset `degree` for those students graduating from `programs` and add variables `ETHNIC` and `SEX`. 

```{r}
glimpse(degree)
sort(unique(degree$GCIP))
sort(unique(degree$GCIP2))
sort(unique(degree$GCIP3))
```

```{r}
library(stringr)
# draft of gather_grad()
gather_grad <- function(degree, programs) {
	
	# select only those variables likely to be used for grouping
	grad <- degree %>%
		dplyr::select(MID, GYEAR, GTERM, INSTITUTION, GCIP, GCIP2, GCIP3)
	
	# keep the earliest term in which a student earns a degree
	grad <- grad %>%
		arrange(MID, GYEAR, GTERM) %>%
		group_by(MID) %>%
		filter(row_number(MID) == 1) %>%
		ungroup()
	
	# gather all 6-digit codes (GCIP, GCIP2, GCIP3) for multiple degrees
	# omit rows with no second or third degree
	grad <- grad %>%
		tidyr::gather(GCIPN, CIP6, GCIP:GCIP3) %>%
		filter(!is.na(GCIPN)) 
	
	# collapse the programs CIP6 vector to a search string
	# then filter grad for the desired programs
	series <- stringr::str_c(programs$CIP6, collapse = "|")
	grad <- grad %>%
		dplyr::filter(str_detect(CIP6, series)) %>%
		unique()
	
	# Join the program labels to grad
	grad <- left_join(grad, programs, by = "CIP6") %>%
		dplyr::arrange(CIP6)

	# Join the sex and ethnicity/race demographics from student
	grad <- join_demographics(grad)
	
	return(grad)
}
```


```{r}
grad <- gather_grad(degree, programs)
glimpse(grad)
```



```{r}
library(tidyr)
# count graduates by grouping variables 
grad_count <- count(grad, PGRM, ETHNIC, SEX)  %>% 
	rename(GRAD = n) %>% 
	arrange(desc(GRAD))

# examine the result
grad_count

# join ever and grad
stickiness <- left_join(ever_count, grad_count, by = c("PGRM", "ETHNIC", "SEX")) 

# if GRAD is NA, due to join with EVER. Is correctly set to zero 
stickiness <- stickiness %>% 
	replace_na(list(GRAD = 0))

# compute stickiness
stickiness <- stickiness %>% 
	mutate(STICK = round(GRAD / EVER, 2))

	
												
kable(stickiness)
```

```{r}
# select only those variables likely to be used for grouping
grad <- degree %>%
	dplyr::select(MID, GYEAR, GTERM, INSTITUTION, GCIP, GCIP2, GCIP3)


unique(grad$GCIP2)
unique(grad$GCIP3)
```

```{r}
# keep the earliest term in which a student earns a degree
one_degree <- grad %>%
	filter(is.na(GCIP2) & is.na(GCIP3)) %>%
	arrange(MID, GYEAR, GTERM)  %>% 
	unique() %>%
 	group_by(MID) %>%
 	filter(row_number(MID) == 1) %>%
	ungroup()
glimpse(one_degree)

unique(one_degree$GCIP2)
unique(one_degree$GCIP3)

```

Gather the GCIPs into a single column

```{r}
one_degree <- one_degree %>% 
	gather(GCIPN, CIP6, GCIP:GCIP3) %>% 
	filter(!is.na(CIP6))

glimpse(one_degree)
```


Now count

```{r}

```




## Compute stickiness 



## Graph stickiness 





## cleanup 

delete the temp data save 
```{r}
# unlink("data/ever.rda")
```

