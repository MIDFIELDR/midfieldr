---
title: "Stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
---

```{r setup, echo = FALSE, message = FALSE}
library(knitr)
opts_knit$set(root.dir = "../")
opts_chunk$set(collapse = TRUE, comment = "#>")
opts_chunk$set(warning = TRUE, message = TRUE, cache = 0) # 0 FALSE 1 minimal
opts_chunk$set(error = TRUE, purl = FALSE)
opts_chunk$set(fig.width = 6)
options(tibble.print_min = 10L, tibble.print_max = 10L)
knit_hooks$set(inline = function(x) {
	if (!is.numeric(x)) { 
		x 
		} else if (x >= 10000) { 
		prettyNum(round(x, 2), big.mark = " ")
		} else {
		prettyNum(round(x, 2))
		}
	})
```



## Getting started 

"Stickiness" is a longitudinal persistence metric that tracks all students who contact an instructional program to determine what percentage “stick” to that program and graduate in it. Stickiness is defined as the ratio of the number of students graduating in a program to the number of students ever enrolled in the program.[^1]

[^1]: Matthew Ohland, Marisa Orr, Richard Layton, Susan Lord and Russell Long (2012) Introducing “stickiness” as a versatile metric of engineering persistence, in proc. *2012 Frontiers in Education Conference*, Seattle, WA, pp. 1--5. [DOI 10.1109/FIE.2012.6462214](http://dx.doi.org/10.1109/FIE.2012.6462214). 

In this article, we show you how to use functions in midfieldr to compute program stickiness. Our workflow is: 

- select the programs 
- count the students ever enrolled
- count the students graduating  
- compute stickiness 
- graph stickiness 

Because our research focuses on intersectionality, we typically disaggregate the data by program, sex, and race/ethnicity. You may of course choose your own combination of variables to study. 



## Select the programs

For this example, we compare the stickiness of three engineering programs: Civil, Electrical, and Mechanical. Their 4-digit CIP codes were found by keyword search as illustrated in [Selecting CIP codes](cip_filter.html). 

We use:  

- `midfieldr::cip_filter()` to obtain the relevant program codes.  
- `tibble::add_column()`  to label the program groups we've defined. The `PGRM` variable is handy later for grouping data and for titling graph panels. 

```{r warning = FALSE, message = FALSE}
# obtain 2, 4, and 6-digit CIP codes and names
library(dplyr)
library(tibble)
library(midfieldr) 
cve <- cip_filter("^1408") %>% add_column(PGRM = "Civil Engineering")
ele <- cip_filter("^1410") %>% add_column(PGRM = "Electrical Engineering")
mce <- cip_filter("^1419") %>% add_column(PGRM = "Mechanical Engineering")
```

Selecting our own `PGRM` label is important when using collections not specifically identified as groups in the CIP dataset, e.g., Humanities, Physical Sciences, and the  collections provided in `midfieldr::named_series`.  

Next we bind the individual program data frames into one data frame. We use: 

- `dplyr::bind_rows()` to bind the programs into one data frame 
- `dplyr::select()` to keep two variables: `CIP6` for finding the desired student records and `PGRM` for grouping.

```{r}
# bind the four programs
programs <- bind_rows(cve, ele, mce) %>% 
	select(CIP6, PGRM)

# examine the result
programs
```



## Count students ever enrolled 

A student contributes to a program's "ever enrolled" total if the program's CIP code appears in the student's `term` data. Each unique student/program combination is counted only once.  

To gather the students ever enrolled, we use:

- `student` dataset for student race/ethnicity and sex. 
- `term` dataset for the programs in which students are enrolled term-by-term. 
- `midfieldr::gather_ever()` to subset `term` for those students ever enrolled in `programs` and add variables `ETHNIC` and `SEX`. 

```{r}
# gather students ever enrolled in the programs
library(midfieldstudent)
library(midfieldterm)
ever <- gather_ever(term, programs)

# examine the result
glimpse(ever)
```

At this point, one decides how to group the the students for counting. In our example, we group by race/ethnicity, sex, and program. We use:

- `dplyr::count()` to group and count the students by program, ethnicity/race, and sex. The count is assigned to the default variable `n`. 
- `dplyr::rename()` to rename `n` to `EVER` for the number of students in this group ever enrolled in the program. 
- `dplyr::arrange()` to arrange the rows of the resulting data frame in order of descending magnitude of the count. 

```{r}
# count ever enrolled by grouping variables 
ever_count <- count(ever, PGRM, ETHNIC, SEX)  %>% 
	rename(EVER = n) %>% 
	arrange(desc(EVER))

# examine the result
ever_count
```

To get a sense of the data, we visualize it using a "multiway" graph. (See [Multiway data and graphs](multiway.html) for an in-depth discussion of multiways.)  To construct the graph, we use ggplot2 and the following midfieldr graph functions: 

- `midfieldr::expon_scale_x_log10()` creates exponential powers-of-ten notation and logarithmic grid lines.  
- `midfieldr::midfield_theme()`, the ggplot `theme_minimal()` with some revisions. 
- `midfieldr::rcb()` yields a hexadecimal code for specific colors named in the `midfieldr::rcb_colors` dataset.  

```{r fig.width = 7.2, fig.asp = 0.9}
# multiway graph of ever enrolled numbers 
library(ggplot2)
ggplot(ever_count, aes(x = EVER, y = reorder(ETHNIC, EVER, median), col = SEX)) +
	geom_point(size = 2) + 	
	facet_wrap(~ reorder(PGRM, -EVER, median), ncol = 1) +
	labs(x = "Number of students ever enrolled", y = "") +
	scale_color_manual(values = c(rcb("mid_Br"), rcb("mid_BG"))) + 
	expon_scale_x_log10() +
	midfield_theme() 
```



## Count students graduating 




## Compute stickiness 




## Graph stickiness 





