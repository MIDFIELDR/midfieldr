---
title: "Computing stickiness"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Computing stickiness}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
resource_files:
  - ../man/figures/stickiness-fig1-1.png
---

```{r setup, echo = FALSE, message = FALSE, purl = FALSE}
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(
  echo = TRUE, # varies from one Rmd to another
  message = TRUE,
  warning = TRUE,
  collapse = TRUE,
  comment = "#>",
  error = TRUE,
  purl = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center",
  fig.path = "../man/figures/stickiness-"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
  })
options(tibble.print_min = 8L, tibble.print_max = 8L)

# normally, purl is FALSE. But in some code chunks, I want purl = TRUE so that the code in the vignette is executed to pass R CMD check. These next few lines set that up. In the code chunk header, add opts.label = 'dopurl'
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_template$set(dopurl = list(purl = TRUE, error = FALSE))
```

In this vignette, we demonstrate computing the "stickiness" persistence metric using Civil, Electrical, Industrial, and Mechanical Engineering as our example programs. 


## Contents

[Introduction]    
[Choose programs]    
[Filter students ever enrolled]    
[Group and summarize ever enrolled]    
[Repeat for graduating students]    
[Tally stickiness]    
[Prepare the data in multiway form]    
[Graph the multiway]  
[References]    

*Appendices*    

[Issue bin]    
[Complete script]    
[Session information]    



## Introduction 

Longitudinal "stickiness" is the ratio of the number of students graduating in a program to the number of students ever enrolled in that program [@stickiness2012]. 

The stickiness metric accounts for all students in a program. Unlike the graduation rate metric, stickiness includes students who begin college part-time, who enroll mid-year, and who switch majors or transfer between institutions. 

Every student counted in a program's stickiness metric was enrolled in that program for at least one term. The program succeeded in attracting these students---stickiness tells us how well the program succeeded in retaining them. 

The workflow is: 

- select the programs 
- count the students ever enrolled
- count the students graduating  
- compute stickiness 
- create a multiway graph  








<br>
<a href="#top">&#9650; top of page</a>   










## Choose programs

```{r message = FALSE}
# packages used 
library("midfieldr")
library("midfielddata")
library("dplyr")
library("stringr")
library("ggplot2")
library("seplyr")
```

```{r echo=FALSE}
# used by my_session() 
pkg_names <- c("midfieldr", "midfielddata", "dplyr", "seplyr", "stringr", "ggplot2")
```

The [Selecting groups of programs](selecting_programs.html) vignette describes the  process for obtaining the program codes and names for four engineering programs: Civil, Electrical, Industrial, and Mechanical. The output of that vignette is saved as a midfieldr case data set, `case_program_group`. You may 

- create the program group by running the code in the vignette 
- or load the saved case data 

The case data are loaded with midfieldr. Simply assign the data to an object  such as `program_group`.  

```{r}
# CIP information saved from an earlier vignette
program_group <- case_program_group
```

Examine the result: there are a total of `r length(unique(program_group[["cip6"]]))` CIP codes for these programs. We have  two columns from the `cip` dataset and the `program` column we added using `cip6_select()`. 

```{r echo = -1}
options(tibble.print_min = 12L)
# check the result
print(program_group)
```

As part of the problem setup, we define a vector of variable names that will be used later for grouping, summarizing, and joining. `grouping_variables` is used by 

- `group_summarize()` from seplyr 
- `left_join()` from dplyr 

```{r}
# variable names for grouping, summarizing, and joining 
grouping_variables <- c("program", "race", "sex")
```







<br>
<a href="#top">&#9650; top of page</a>   









## Filter students ever enrolled

We use `ever_filter()` to collect all students ever enrolled in the programs we are studying. `ever_filter()` has two required arguments:

- `data` data frame of term information, default `midfieldterms` 
- `filter_by` atomic character vector of 6-digit CIP codes

The `filter_by` argument in this case is an atomic vector of the 6-digit CIP codes in our `program_group`. The function uses these codes to search `midfieldterms`, the default reference data set. Use `print()` to check the result. 

```{r}
# extract the 6-digit CIPs as a search series
program_series <- program_group[["cip6"]] %>%
        unique() %>%
        sort() %>%
        print()
```

Extract all students from midfieldterms ever enrolled in these programs. 

```{r opts.label = 'dopurl'}
students <- ever_filter(data = midfieldterms, filter_by = program_series) %>% 
        print()
```

If one is working strictly with the data sets in midfielddata, then the data argument can be omitted because if `data` is NULL, its default assignment is `midfielddata::midfieldterms`.  Thus, the following code yields the same result as the one above. 

```{r}
students <- ever_filter(filter_by = program_series) %>% 
        print()
```

View the result to check the number of observations and to view the first few values of each variable. We see that we have `r nrow(students)` students ever enrolled in these programs. 

```{r}
# check the result
print(students)
```

Open the help page by running 

```r
? ever_filter()
```





<br>
<a href="#top">&#9650; top of page</a>   






## Group and summarize ever enrolled

`race_sex_join()` accepts any data frame with the MIDFIELD student `id` variable and joins the student race and sex from the `midfieldstudents` reference data to these data. 

```{r}
students <- race_sex_join(students) %>%
        print()
```

If the argument to `race_sex_join()` already includes a `sex` or `race` column, that column (or columns) is returned unchanged. Open the help page by running

```r
? race_sex_join()
```

Next we join our custom program names to the student data. We use `left_join()` (a dplyr function) to join `program_group` to `students` by the 6-digit CIP code. 

```{r}
students <- left_join(students, program_group, by = "cip6") %>%
        print()
```

We use `group_summarize()` (an seplyr function) to group and count the numbers of students ever enrolled in our programs.  All variables in `students` not used as grouping variables are quietly dropped. The assigned count variable is `ever`. 

```{r}
# count students ever enrolled in programs
ever_enrolled <- group_summarize(students, grouping_variables, "ever" = n()) %>%
        print()
```





<br>
<a href="#top">&#9650; top of page</a>   






## Repeat for graduating students

`grad_filter()` extracts a subset of the `midfielddegrees` data containing the  unique students ever graduating from the programs listed in `program_series `. 

The procedure for gathering graduates is nearly identical to the procedure for gathering the ever-enrolled. We use `grad_filter()` to search the  `midfielddegrees` dataset using the same `filter_by` argument; we join race, sex, and program in the same way; and when we count students, the totals are assigned to the new variable `grad`.

Reminder that in a sequence of operations using the pipe operator (`%>%`), the outcome of the one operation is assigned to the first argument of the next operation using the dot (`.`) argument. 

```{r}
# count students graduating from programs
graduated <- grad_filter(series = program_series) %>%
        race_sex_join() %>% 
        left_join(program_group, by = "cip6") %>%
        group_summarize(., grouping_variables, "grad" = n()) %>%
        print()
```


Notes. 

- In the code chunk above, the dot (`.`) argument can be safely omitted from `race_sex_join()` and `print()` because both functions operate on the single data frame object passed by the pipe. 
- In contrast, `group_summarize()` from the seplyr package requires explicit arguments, hence the dot placeholder to represent the incoming data frame. 
- If keeping track of when you need a dot and when you don't is a cognitive burden, you can always use a dot to represent the incoming object explicitly. For example, the code chunk above could be written, 

```{r results = "hide"}
graduated <- grad_filter(series = program_series) %>%
        race_sex_join(.) %>% 
        left_join(., program_group, by = "cip6") %>%
        group_summarize(., grouping_variables, "grad" = n()) %>%
        print(.)
```


Open the help page by running 

```r
? grad_filter()
```






<br>
<a href="#top">&#9650; top of page</a>   






## Tally stickiness

To set up the stickiness calculation, we join `graduated` to `ever_enrolled` by program, race, and sex.  

```{r}
stickiness <- left_join(ever_enrolled, graduated, by = grouping_variables) %>%
        print()
```

We suggest omitting observations with 5 or fewer students ever enrolled. 

```{r}
stickiness <- filter(stickiness, ever > 5)
```

Finally, we create `stick`, the ratio of `grad` to `ever`. Stickiness is reported as a fraction between 0 and 1. 

```{r echo = -1}
options(tibble.print_min = 10L)
# tally stickiness
stickiness <- stickiness %>%
        mutate(stick = round(grad / ever, 3)) %>%
        print()
```





<br>
<a href="#top">&#9650; top of page</a>   






## Prepare the data in multiway form

Before structuring the data for graphing, we select the populations we are interested in. For example, we might omit students for whom the "race" designation is ambiguous. This step could have been taken earlier, but must be taken (if at all) before using `multiway_order()`. 

We use `filter()` (a [dplyr](http://dplyr.tidyverse.org) function) to keep all rows except those in which race is Unknown, International, or Other.  

```{r}
# prepare data for graph
stickiness_mw <- stickiness %>%
        filter(!race %in% c("Unknown", "International", "Other")) %>%
        filter(!sex %in% "Unknown")
```

This example has no "Unknown" values in `sex`, but the larger data set does have a few. For completeness, I've also filtered to remove those observations.  

We structure the stickiness results as *multiway* data by combining student race and sex into a single `race_sex` variable. The [Multiway](multiway.html) article explains multiway data and graphs in detail. 

We use: 

- `mutate()` (a dplyr function) to create a new variable 
- `str_c()`  (a stringr function) to combine the race and sex strings 
- `select()` (a dplyr function) to keep three variables only 

```{r}
# create the race_sex variable
stickiness_mw <- stickiness_mw %>%
        mutate(race_sex = str_c(race, sex, sep = " ")) %>%
        select(program, race_sex, stick) %>%
        print()
```

`multiway_order()` converts the character variables `program` and `race_sex` into *factors* and orders the levels of the two factors by the relevant stickiness medians. `glimpse()` shows that the two categorical variables are now factors. 

```{r}
# convert the data to a multiway structure
stickiness_mw <- multiway_order(stickiness_mw) %>%
        print()
```

Open the help page by running 

```r
? multiway_order()
```





<br>
<a href="#top">&#9650; top of page</a>   






## Graph the multiway

By using `multiway_order()` to condition the data, the rows and panels of the multiway graph will be ordered by the appropriate medians. We use conventional ggplot2 functions applied to the `stickiness` data frame: 

- `stick` is the quantitative x-variable 
- `race_sex` is the y-variable forming the rows of the panels 
- `program` in `facet_wrap()` conditions the panels  
- `as.table = FALSE` places the panels in ascending order from bottom to top 
- `geom_point()` creates the data markers; any NA values are removed by `na.rm = TRUE` 
- `labs()` assign axis labels 

```{r fig1, fig.asp = 2/1.6}
ggplot(stickiness_mw, aes(x = stick, y = race_sex)) +
        facet_wrap(vars(program), ncol = 1, as.table = FALSE) +
        geom_point(na.rm = TRUE) +
        labs(x = "Stickiness", y = "") +
        theme_midfield()
```

We also apply our own `theme_midfield()` to edit the visual properties of the graph: axes, legends, panels, strips, etc. Open the help page by running

```r
? theme_midfield()
```



<br>
<a href="#top">&#9650; top of page</a>   




## References

<div id="refs"></div>




<br>
<a href="#top">&#9650; top of page</a> 
 



## Issue bin

- Add a note regarding the suggested 6-student minimum. 
- Account for "possible graduation in 6 years"
- Could use mice to impute unknown values of the race and sex variables 
- Possibly a separate vignette on standard evaluation and non-standard evaluation 



<br>
<a href="#top">&#9650; top of page</a> 




## Complete script

For reference, the complete script for this example is collected below. We've omitted intermediate exploratory steps and retained only the minimum code required to obtain the results graph. 

```{r eval = FALSE}
# packages used 
library("midfieldr")
library("midfielddata")
library("dplyr")
library("stringr")
library("ggplot2")
library("seplyr")

# CIP information saved from an earlier vignette
program_group <- case_program_group

# variable names for grouping, summarizing, and joining 
grouping_variables <- c("program", "race", "sex")

# extract the 6-digit CIPs as a search series
program_series <- program_group[["cip6"]] %>%
        unique() %>%
        sort()

# count students ever enrolled in programs
ever_enrolled <- ever_filter(midfieldterms, filter_by = program_series) %>%
        race_sex_join() %>% 
        left_join(., program_group, by = "cip6") %>%
        group_summarize(., grouping_variables, "ever" = n())

# count students graduating from programs
graduated <- grad_filter(series = program_series) %>%
        race_sex_join() %>%
        left_join(., program_group, by = "cip6") %>%
        group_summarize(., grouping_variables, "grad" = n())

# tally stickiness, by group
stickiness <- left_join(ever_enrolled, graduated, by = grouping_variables) %>%
        filter(ever > 5) %>%
        mutate(stick = round(grad / ever, 3))

# prepare data for graph
stickiness_mw <- stickiness %>%
        filter(!race %in% c("Unknown", "International", "Other")) %>%
        filter(!sex %in% "Unknown") %>%
        mutate(race_sex = str_c(race, sex, sep = " ")) %>%
        select(program, race_sex, stick) %>%
        multiway_order()

# graph
ggplot(stickiness_mw, aes(x = stick, y = race_sex)) +
        facet_wrap(vars(program), ncol = 1, as.table = FALSE) +
        geom_point(na.rm = TRUE) +
        labs(x = "Stickiness", y = "") +
        theme_midfield()
```




<br>
<a href="#top">&#9650; top of page</a>   





## Session information 

```{r echo = FALSE, comment = NA}
# internal function for session information
my_session(pkg_names)
```


<br>
<a href="#top"         >&#9650;     top of page </a>     
<a href="../index.html">&#9665;       main page </a> 

