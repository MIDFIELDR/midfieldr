---
title: "Case study: Results"
date: "`r Sys.Date()`"
link-citations: yes
bibliography: ../inst/REFERENCES.bib
output: rmarkdown::html_vignette
csl: ../inst/information-science-and-technology.csl
vignette: >
  %\VignetteIndexEntry{Case study: Results}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
nocite: | 
resource_files: |
---

```{r setup, include = FALSE}
# code chunks
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = FALSE,
  comment = "#>",
  error = FALSE
)

# figures
knitr::opts_chunk$set(
    fig.path = "../man/figures/art-003-case-results-", 
    fig.width = 6,
    fig.asp = 1 / 1.6,
    out.width = "70%",
    fig.align = "center"
)

# inline numbers
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
```

Part 3 of a case study in three parts:

- [Goals.](art-001-case-goals.html) Describing the study parameters.  
- [Data.](art-002-case-data.html) Transforming the data to yield the observations of interest.
- [Results.](art-003-case-results.html) Calculating summary statistics and metrics and displaying the results. 


In this part, we use the midfieldr functions:  

- `condition_multiway()` 

## Preface

Our goal in this segment is to group and summarize the observations we saved previously, calculate the stickiness metric, and display the results. 

If you are writing your own script to follow along, we start with these packages: 

```{r}
# Packages
library("midfieldr")
suppressPackageStartupMessages(library("data.table"))
suppressPackageStartupMessages(library("ggplot2"))

# Printing options for data.table
options(
  datatable.print.nrows = 15,
  datatable.print.topn = 5,
  datatable.print.class = TRUE
)
```

## Import data

**Copying.** Copy the data file `study_observations` containing the final set of case study "ever" and "grad" observations as developed in the previous segment. These data are bundled with midfieldr.

```{r}
# Copy the case study observations
DT <- copy(study_observations)
DT[]
```

View the data set help page by running

    # Run in Console to view help page
    ? study_observations
    
## Group and summarize

To calculate stickiness, we want to count the number of students ever enrolled in each of our programs and the number of students graduating from the programs, grouped by race/ethnicity and sex.

These grouping variables are columns in the data set (`race`, `sex`, `program`, and `group`)---a structure we designed to support this specific  analytical goal. We can now group and summarize in one line of code. 

```{r}
# Group and summarize
DT <- DT[, .N, by = c("group", "program", "race", "sex")]
DT[]
```

## Compute metric

Stickiness is the ratio of the number of graduates to the number of students ever enrolled in a program. To be able to divide `grad / ever` we would like these two values to be in the same row. The `dcast()` function accomplishes that for us. 

This operation is essentially a transformation from block records to row records---a process known by a number of different names, e.g., pivot, crosstab, unstack, spread, or widen [@Mount+Zumel:2019:fluid-data].  This step  leaves the graphing variables (program, race/ethnicity, and sex) in place. 

```{r}
# Transform to row-record form
DT <- dcast(DT, program + sex + race ~ group, value.var = "N", fill = 0)
DT[]
```

We calculate percent stickiness. 

```{r}
DT[, stick := round(100 * grad / ever, 1)]
DT[]
```

In this form, the data are bundled with midfieldr as the `study_results` data set. You can view its help page by running 

    ? study_results

## Prepare for dissemination

We take several additional steps to prepare the data for dissemination in  tables or charts.  

**Filtering.** To preserve the anonymity of the people involved, we remove observations with 10 or fewer graduates.   

```{r}
# Preserve anonymity 
DT <- DT[grad >= 10]
DT[]
```

**Filtering.** Let us assume that our study focuses on "domestic" students of known race/ethnicity. In that case, we omit observations labeled "International" and Other/Unknown". 

```{r}
# Filter by study design
DT <- DT[!race %chin% c("International", "Other/Unknown")]
DT[]
```

**Creating variables.** We have found it useful to report such data with a variable that combines race/ethnicity and sex. 

```{r}
DT[, race_sex := paste(race, sex)]
DT[, c("race", "sex") := NULL]
setcolorder(DT, c("program", "race_sex"))
DT[]
```

**Recoding values.** Readers can more readily interpret our charts and tables if the programs are un-abbreviated. 

```{r}
DT[, program := fcase(
    program %like% "CE", "Civil Engineering", 
    program %like% "EE", "Electrical Engineering", 
    program %like% "ME", "Mechanical Engineering", 
    program %like% "ISE", "Industrial/Systems Engineering"
)]
DT[]
```

With one quantitative variable (stickiness) for every combination of the levels of two categorical variables (program and race/ethnicity/sex), these data are *multiway data* [@Cleveland:1993]. How one orders the categorical variables is critical for visualizing effects. 

**Conditioning.** Convert the two categorical variables to ordered factors to support the ordering of rows and panels in the chart. 

```{r}
# Convert categorical variables to factors
DT <- condition_multiway(DT, 
                        x = "stick", 
                        yy = c("program", "race_sex"), 
                        order_by  = "percent", 
                        param_col = c("grad", "ever"))
DT[]
```


You may view the function's help page by running

    ? condition_multiway


The column `program_stick` determines the order of the programs in the chart; `race_sex_stick` determines the order of the race/ethnicity/sex groupings; the values in `stick` are the quantitative values to be graphed. 

## Charts

In the first multiway chart, the rows are programs and panels are people, facilitating comparisons of different program for a single group. Rows and panels are both ordered from bottom to top in order of increasing stickiness. 

```{r}
#| label: fig-stickiness-01
#| fig-asp: 1.2
ggplot(DT, aes(x = stick, y = program)) +
    facet_wrap(vars(race_sex), ncol = 1, as.table = FALSE) +
    geom_point()  +
    labs(x = "Stickiness (%)", y = "")
```

Alternatively, we can consider the dual chart, swapping the roles of the panels and rows.  Here the rows are people and panels are programs, facilitating comparisons of different people within a program.  Over many years of publishing research using MIDFIELD data, placing people on the rows of the multiway chart has been perhaps our most frequently used design. 

```{r}
#| label: fig-stickiness-02
#| fig-asp: 1
ggplot(DT, aes(x = stick, y = race_sex)) +
    facet_wrap(vars(program), ncol = 1, as.table = FALSE) +
    geom_point()  +
    labs(x = "Stickiness (%)", y = "")
```

**Reminder.** These are practice data, not research data---suitable for learning about student-record analysis, but not for drawing inferences about student performance.

The chart illustrates the importance of ordering the rows and panels. We would conclude that Industrial/Systems Engineering is the stickiest program of the four, followed by Civil, Mechanical, and Electrical in descending order. 

Because rows are ordered, one expects a generally increasing trend within a panel. A response greater or smaller than expected creates a visual asymmetry. For example, Asian Female students are asymmetrically higher in Mechanical Engineering but asymmetrically lower in Industrial/Systems Engineering. 




## Tables

Data tables are often needed for publication. In this example, we format the data in a conventional row-record form with the groups of people in the first column labeling the rows and the program names labeling the remaining columns. 

```{r}
# Select the columns I want for the table
tbl <- DT[, .(program, race_sex, grad, ever, stick)]

# Shorten the names that will appear in the header row
tbl[, program := fcase(
    program %like% "Civil Engineering", "Civil", 
    program %like% "Electrical Engineering", "Electrical", 
    program %like% "Mechanical Engineering", "Mechanical", 
    program %like% "Industrial/Systems Engineering", "Industrial/Sys"
)]

# Combine three columns into one character column 
tbl[, results := paste0("(", grad, "/", ever, ") ", format(stick, nsmall = 1))]

# Transform from block records to row records 
tbl <- dcast(tbl, race_sex ~ program, value.var = "results")

# Change factor to character so the rows can b alphabetized 
tbl[, race_sex := as.character(race_sex)]
tbl <- tbl[order(race_sex)]

# Edit one column header
setnames(tbl, old = "race_sex", new= "Group", skip_absent = TRUE)
```

Program stickiness in percent with the ratio (`grad/ever`) in parentheses, i.e., the number of program graduates and the number of students ever enrolled in the program. Groups with numbers below our reporting threshold are denoted NA or omitted. 

```{r}
#| echo: false
tbl |> 
    kableExtra::kbl(align = "lrrrr") |>
    kableExtra::kable_paper(lightable_options = "basic", full_width = TRUE) |>
    kableExtra::row_spec(0, background = "#c7eae5") |>
    # kableExtra::column_spec(1, monospace = TRUE) |>
    kableExtra::column_spec(1:5, color = "black", background = "white")
```


## Closing

Starting with the prepared data (the case study observations), we compute longitudinal stickiness for four programs (Civil, Electrical, Industrial/Systems, and Mechanical Engineering) grouped by program, race/ethnicity, and sex. We create a data table and charts to disseminate the results. 

**Write to file.** Results like those just prior to the dissemination preparation step are often written to file as an intermediate result. In this case, the pre-dissemination data frame is bundled with midfieldr as `study_results`.

## References

<div id="refs"></div>







## Appendix

### Complete script

We conclude each vignette by collecting its code chunks in a single, condensed script for the convenience of those who wish to copy it into their own R file.

```{r}
#| eval: false
# Packages
library("midfieldr")
suppressPackageStartupMessages(library("data.table"))
suppressPackageStartupMessages(library("ggplot2"))

# Printing options for data.table
options(
  datatable.print.nrows = 15,
  datatable.print.topn = 5,
  datatable.print.class = TRUE
)

# Copy the case study observations
DT <- copy(study_observations)

# Group and summarize
DT <- DT[, .N, by = c("group", "program", "race", "sex")]

# Compute the metric
DT <- dcast(DT, program + sex + race ~ group, value.var = "N", fill = 0)
DT[, stick := round(100 * grad / ever, 1)]

# Prepare for dissemination
DT <- DT[grad >= 10]
DT <- DT[!race %chin% c("International", "Other/Unknown")]
DT[, race_sex := paste(race, sex)]
DT[, c("race", "sex") := NULL]
setcolorder(DT, c("program", "race_sex"))
DT[, program := fcase(
    program %like% "CE", "Civil Engineering", 
    program %like% "EE", "Electrical Engineering", 
    program %like% "ME", "Mechanical Engineering", 
    program %like% "ISE", "Industrial/Systems Engineering"
)]

# Convert categorical variables to factors
DT <- condition_multiway(DT, 
                        x = "stick", 
                        yy = c("program", "race_sex"), 
                        order_by  = "percent", 
                        param_col = c("grad", "ever"))

# Chart 1
ggplot(DT, aes(x = stick, y = program)) +
    facet_wrap(vars(race_sex), ncol = 1, as.table = FALSE) +
    geom_point()  +
    labs(x = "Stickiness (%)", y = "")

# Chart 2
ggplot(DT, aes(x = stick, y = race_sex)) +
    facet_wrap(vars(program), ncol = 1, as.table = FALSE) +
    geom_point()  +
    labs(x = "Stickiness (%)", y = "")

# Table
tbl <- DT[, .(program, race_sex, grad, ever, stick)]
tbl[, program := fcase(
    program %like% "Civil Engineering", "Civil", 
    program %like% "Electrical Engineering", "Electrical", 
    program %like% "Mechanical Engineering", "Mechanical", 
    program %like% "Industrial/Systems Engineering", "Industrial/Sys"
)]
tbl[, results := paste0("(", grad, "/", ever, ") ", format(stick, nsmall = 1))]
tbl <- dcast(tbl, race_sex ~ program, value.var = "results")
tbl[, race_sex := as.character(race_sex)]
tbl <- tbl[order(race_sex)]
setnames(tbl, old = "race_sex", new= "Group", skip_absent = TRUE)
```

