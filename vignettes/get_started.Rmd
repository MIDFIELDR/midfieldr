---
title: "Get started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
resource_files:
  - ../man/figures/vignette-get-started-fig1-1.png
nocite: | 
  @Dowle+Srinivasan:2020:data.table
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-get-started-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
asp_ratio_mw <- function(data, categories) {
  cat1 <- categories[1] # panels
  cat2 <- categories[2] # rows
  nlevel1 <- nlevels(data[, get(cat1)])
  nlevel2 <- nlevels(data[, get(cat2)])
  r <- nlevel1 * nlevel2
  q <- 32
  asp_ratio1 <- (r + 2 * nlevel1) / q
  asp_ratio2 <- (r + 2 * nlevel2) / q
  ratios <- c(asp_ratio1, asp_ratio2)
}
```

## Introduction

In the midfielddata sample, the programs with the greatest numbers of students are Business and Engineering. In this vignette, we compare the number of students ever enrolled in these programs, grouped by sex and race/ethnicity.

We use midfieldr functions to access midfielddata student records. We condition, group and summarize the data, and graph a result. For data carpentry, we use base R and selected syntax from the data.table package. 

### This vignette uses

midfieldr functions 

- `filter_text()` 
- `timely_completion_term()`
- `prepare_multiway()` 

midfieldr built-in data sets 

- `cip`  

packages

```{r}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# print max 20 rows, otherwise 10 rows each head/tail
options(datatable.print.nrows = 20, datatable.print.topn = 10)
```

## Gather programs

Instructional programs are encoded by 6-digit CIP codes, included in midfieldr in the `cip` data set.  You may view its help page by running

```
? cip
```

`filter_text()` accesses the `cip` data set and retrieves all the 6-digit codes that satisfy stated conditions. In this case, we want all codes that start with 14 (engineering) and 52 (business). 

```{r}
# engineering
engineering <- filter_text(cip, keep_text = "^14", keep_col = "cip6")

# add program label
engineering[, program := "Engineering"]

# examine the result
engineering[order(cip6)]
```

Repeat for business.  

```{r}
# business
business <- filter_text(cip, keep_text = "^52", keep_col = "cip6")

# add program label
business[, program := "Business"]

# examine the result
business[order(cip6)]
```

Bind the two data frames. 

```{r}
# bind the two data frames
program_group <- rbindlist(list(engineering, business))

# examine the result
program_group[order(cip6)]
```

We extract the `cip6` column as a character vector to use later to extract student data by their CIP codes.  

```{r}
# extract a vector of 6-digit CIP codes
group_cip <- program_group$cip6

# examine the result
str(group_cip)
```

## Gather students 

We access `midfieldterms` to obtain the IDs of all students ever enrolled in these programs.  

```{r}
# extract students ever enrolled from terms data
cols_we_want <- c("id", "cip6")
rows_we_want <- midfieldterms$cip6 %in% group_cip
enrollees <- midfieldterms[rows_we_want, ..cols_we_want]
enrollees <- unique(enrollees)

# examine the result
enrollees[order(id)]
```

For some of these students, completing their program may not be feasible given the range of data available. `subset_feasible()` subsets the enrollees IDs, retaining those who matriculate at least six years before the last term in the data. 

```{r}
# apply the feasible completion filter
feasible_ids <- subset_feasible(enrollees$id)

# subset the enrollees
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]

# examine the result
enrollees[order(id)]
```

Related vignettes 

- *Feasible completion* [(link)](feasible_completion.html) describes how completion feasibility is determined  

## Join the grouping variables

In this example, the results are eventually grouped by program, race/ethnicity, and sex. Here, we join these variables to the working data frame. 

We access `midfieldstudents` to obtain students' race/ethnicity and sex as self-reported at matriculation. 

```{r}
rows_we_want <- midfieldstudents$id %in% feasible_ids
cols_we_want <- c("id", "race", "sex")
race_sex <- midfieldstudents[rows_we_want, ..cols_we_want]
race_sex <- unique(race_sex)

# examine the result
race_sex[order(id)]
```

Join the race/ethnicity and sex data frame to the enrollees data frame by `id`. Then join the program names from `program_group` to our working data frame by `cip6`. 

```{r}
# left-join demographics to enrollees
enrollees <- merge(enrollees, race_sex, by = "id", all.x = TRUE)

# left-join program_group to enrollees
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)

# examine the result
enrollees[order(id)]
```

Here we edit one last time by deleting the CIP column and removing duplicates. In this way, students who migrate within engineering, for example, are not counted twice, but a student who transfers from engineering to business (or vice versa) is counted in both programs. 

```{r}
# remove the CIP codes
enrollees[, cip6 := NULL]

# remove duplicates
enrollees <- unique(enrollees)

# examine the result
enrollees[order(id)]
```


## Group and summarize

To frame our results in terms of program, race/ethnicity, and sex, we group by these variables and count the number of students in each grouping using syntax from the data.table package. The count is assigned to the new `ever` column. 

```{r}
# assign
grouping_variables <- c("program", "race", "sex")

# aggregate using data.table syntax
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]

# examine the result
grouped_enrollees
```

## Condition the data for display 

To prepare the results for graphing, we construct a "pre-multiway" version of the data frame. We begin by removing ambiguous levels of race/ethnicity. 

```{r}
# initialize the pre-multiway data frame
pre_mw <- copy(grouped_enrollees)

# remove ambiguous levels of race/ethnicity
rows_we_want <- !pre_mw$race %in% c("Unknown", "International", "Other")
pre_mw <- pre_mw[rows_we_want]

# examine the result
unique(pre_mw$race)
```

To protect confidentiality, we omit observations with 10 or fewer students ever enrolled.

```{r}
# protect confidentiality of small populations
rows_we_want <- pre_mw$ever > 10
pre_mw <- pre_mw[rows_we_want]

# order rows for viewing
pre_mw <- pre_mw[order(program, race, sex)]

# examine the result
pre_mw
```

In intersectional studies, we have found combined race/ethnicity and sex to be a useful category. We unite two columns to create the `race_sex` column. 

```{r}
# create a new category
pre_mw[, race_sex := paste(race, sex, sep = " ")]

# examine the result
pre_mw
```

*Multiway data* are characterized by two categorical variables and one quantitative variable [@Cleveland:1993]. In this example, the two categories are program and race/ethnicity/sex and the quantitative variable is the number of students ever enrolled. 

To structure the data in multiway form, we select the three multiway variables. 

```{r}
# select the three multiway variables
cols_we_want <- c("program", "race_sex", "ever")
pre_mw <- pre_mw[, ..cols_we_want]

# examine the result
pre_mw
```

The second attribute of multiway data is that the levels of the categories are ordered by the median value of the quantitative variable. `prepare_multiway()`  converts the categorical variables to factors and orders the category levels.  

```{r}
# order the category levels
data_mw <- prepare_multiway(pre_mw)
```

The median values are attributes of the data frame. We can view them as follows. Note that `program` and `race_sex` are now factors ordered by the median enrolled numbers (recorded under the `scores` attribute). 

```{r}
lapply(data_mw, FUN = attributes)
```

Related vignettes

- *Multiway graphs and tables* [(link)](multiway_graphs.html) describes multiway data and graphs in detail 


## Graph the results

```{r include = FALSE}
asp_ratio <- asp_ratio_mw(data_mw, categories = c("program", "race_sex"))
```

We use ggplot2 to graph the multiway data. Rows and panels, from top to bottom, are ordered by decreasing medians. We use a logarithmic scale because the numbers differ by orders of magnitude. In a log base-2 scale, every grid line represents a doubling of the previous grid line.   

```{r fig1, fig.asp = 0.8}
ggplot(data = data_mw, mapping = aes(x = ever, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  scale_x_continuous(
    trans = "log2",
    breaks = 2^seq(4, 14),
    limits = 2^c(4, 14)
  ) +
  theme(panel.grid.minor.x = element_blank()) +
  labs(
    x = "Number of students (log-2 scale)",
    y = "",
    title = "Ever enrolled in the program",
    caption = "Source: midfielddata"
  )
```

## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval=FALSE}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# gather programs
engineering <- filter_text(cip, keep_text = "^14", keep_col = "cip6")
engineering[, program := "Engineering"]
business <- filter_text(cip, keep_text = "^52", keep_col = "cip6")
business <- business[, program := "Business"]
program_group <- rbind(engineering, business)
group_cip <- program_group$cip6

# gather students
cols_we_want <- c("id", "cip6")
rows_we_want <- midfieldterms$cip6 %in% group_cip
enrollees <- midfieldterms[rows_we_want, ..cols_we_want]
rows_we_want <- midfieldstudents$cip6 %in% group_cip
matriculants <- midfieldstudents[rows_we_want, ..cols_we_want]
enrollees <- rbind(enrollees, matriculants)
enrollees <- unique(enrollees)

# apply feasible completion
feasible_ids <- subset_feasible(enrollees$id)
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]

# join grouping variables
rows_we_want <- midfieldstudents$id %in% feasible_ids
cols_we_want <- c("id", "race", "sex")
race_sex <- midfieldstudents[rows_we_want, ..cols_we_want]
enrollees <- merge(enrollees, race_sex, by = "id", all.x = TRUE)
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)
enrollees[, cip6 := NULL]
enrollees <- unique(enrollees)

# group and summarize
grouping_variables <- c("program", "race", "sex")
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]

# condition the data for display
pre_mw <- grouped_enrollees
rows_we_want <- !pre_mw$race %in% c("Unknown", "International", "Other")
pre_mw <- pre_mw[rows_we_want]
rows_we_want <- pre_mw$ever > 10
pre_mw <- pre_mw[rows_we_want]
pre_mw[, race_sex := paste(race, sex, sep = " ")]
cols_we_want <- c("program", "race_sex", "ever")
pre_mw <- pre_mw[, ..cols_we_want]
data_mw <- prepare_multiway(pre_mw)

# graph results
ggplot(data = data_mw, mapping = aes(x = ever, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  scale_x_continuous(
    trans = "log2",
    breaks = 2^seq(4, 14),
    limits = 2^c(4, 14)
  ) +
  theme(panel.grid.minor.x = element_blank()) +
  labs(
    x = "Number of students (log-2 scale)",
    y = "",
    title = "Ever enrolled in the program",
    caption = "Source: midfielddata"
  )
```
