---
title: "Get started"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Get started}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
resource_files:
  - ../man/figures/vignette-get-started-fig1-1.png
nocite: | 
  @Dowle+Srinivasan:2020:data.table
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-get-started-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
asp_ratio_mw <- function(data, categories) {
  cat1 <- categories[1] # panels
  cat2 <- categories[2] # rows
  nlevel1 <- nlevels(data[, get(cat1)])
  nlevel2 <- nlevels(data[, get(cat2)])
  r <- nlevel1 * nlevel2
  q <- 32
  asp_ratio1 <- (r + 2 * nlevel1) / q
  asp_ratio2 <- (r + 2 * nlevel2) / q
  ratios <- c(asp_ratio1, asp_ratio2)
}
```

## Introduction

In the MIDFIELD practice data, the programs with the greatest numbers of students are Business and Engineering. In this vignette, we compare the number of students ever enrolled in these programs, grouped by sex and race/ethnicity.

We use midfieldr functions to access midfielddata student records. We condition, group and summarize the data, and graph a result. For data carpentry, we use base R and selected syntax from the data.table package. 

### This vignette uses

midfieldr functions 

- `filter_text()` 
- `prepare_multiway()` 

midfieldr built-in data sets 

- `cip`  

packages

```{r}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)
```

```{r}
# optional code to control data.table printing
options(datatable.print.nrows = 20, datatable.print.topn = 10)
```

## Gather programs

Instructional programs are encoded by 6-digit CIP codes, included in midfieldr in the `cip` data set.  You may view its help page by running

```
? cip
```

We search `cip` for our program codes using `filter_text()`. You may view its help page by running

```
? filter_text
```

In this example, we assume we have already searched `cip` and found that the codes we want start with 14 (engineering) and 52 (business). Our next step is to pull all 6-digit codes associated with these two programs. 

```{r}
# engineering
engineering <- filter_text(cip, keep_text = "^14", keep_col = "cip6")

# add program label
engineering[, program := "Engineering"]

# examine the result
engineering[order(cip6)]
```

Repeat for business.  

```{r}
# business
business <- filter_text(cip, keep_text = "^52", keep_col = "cip6")

# add program label
business[, program := "Business"]

# examine the result
business[order(cip6)]
```

Bind the two data frames. 

```{r}
# bind the two data frames
program_group <- rbindlist(list(engineering, business))

# examine the result
program_group[order(cip6)]
```

We extract the `cip6` column as a character vector to use later to extract student data by their CIP codes.  

```{r}
# extract a vector of 6-digit CIP codes
group_cip <- program_group$cip6

# examine the result
str(group_cip)
```

## Gather students 

We access the term data to obtain the IDs of all students ever enrolled in these programs.  The result, `DT`, is a data table to which we will add information as we proceed. 

```{r}
# extract unique students ever enrolled from term data
cols_we_want <- c("id", "cip6", "institution")
rows_we_want <- midfieldterms$cip6 %chin% group_cip
DT <- midfieldterms[rows_we_want, ..cols_we_want]
DT <- unique(DT)

# examine the result
DT[order(id)]
```

We update the IDs a number of times, so we extract them from the data table as a character vector. 

```{r}
# initialize an ID vector
latest_id <- unique(DT$id)

# examine the result
length(latest_id)
```

At this point we have `r length(latest_id)` unique students in our study. 

We access the student data set to limit our research to students for whom we have matriculation information. 

```{r}
# limit study to students with matriculation data
cols_we_want <- c("id")
rows_we_want <- midfieldstudents$id %chin% latest_id
matriculate <- midfieldstudents[rows_we_want, ..cols_we_want]

# examine the result
matriculate
```

Update the ID vector.

```{r}
# update the ID vector
latest_id <- unique(matriculate$id)
                    
# examine the result
length(latest_id)
```

In this case, all our enrollees are recorded in the student data set, so the number of students remains the same.  

## Join the grouping variables

Our results are goint to be grouped by program, race/ethnicity, and sex. Here, we join these variables to the working data frame. We access the student data to obtain race/ethnicity and sex as self-reported at matriculation. 

```{r}
# pull demographics
cols_we_want <- c("id", "race", "sex")
rows_we_want <- midfieldstudents$id %chin% latest_id
race_sex <- midfieldstudents[rows_we_want, ..cols_we_want]

# examine the result
race_sex[order(id)]
```

We merge the race/ethnicity and sex information with our data table. The `all.x` argument is set to FALSE so that only rows in common between `DT` and `race_sex` are retained. 

```{r}
# merge demographics 
DT <- merge(DT, race_sex, by = "id", all.x = FALSE)

# examine the result
DT
```

In case we had lost any students, we again update the ID vector. As it turns out, no students were omitted in this step. 

```{r}
# update the ID vector
latest_id <- unique(DT[, (id)])

# examine the result
length(latest_id)
```

Next we join the program names from `program_group` to our working data frame by `cip6`. This time, the `all.x` argument is TRUE because we want to retain all the rows of `DT` when joining the program groups to it. 

```{r}
# add program name 
DT <- merge(DT, program_group, by = "cip6", all.x = TRUE)

# examine the result
DT
```

## Group and summarize

To frame our results in terms of program, race/ethnicity, and sex, we group by these variables and count the number of students in each grouping. The count is assigned to the new `ever` column. 

```{r}
# assign
grouping_variables <- c("program", "race", "sex")

# aggregate
grouped_DT <- DT[, .(ever = .N), by = grouping_variables]

# examine the result
grouped_DT
```

## Condition the data for display 

To prepare the results for graphing, we construct a "pre-multiway" version of the data frame. We begin by removing ambiguous levels of race/ethnicity. 

```{r}
# initialize the pre-multiway data frame
pre_mw <- copy(grouped_DT)

# remove ambiguous levels of race/ethnicity
rows_we_want <- !pre_mw$race %chin% c("Unknown", "International", "Other")
pre_mw <- pre_mw[rows_we_want]

# examine the result
unique(pre_mw$race)
```

To protect confidentiality, we omit observations with 10 or fewer students ever enrolled.

```{r}
# protect confidentiality of small populations
rows_we_want <- pre_mw$ever > 10
pre_mw <- pre_mw[rows_we_want]

# order rows for viewing
pre_mw <- pre_mw[order(program, race, sex)]

# examine the result
pre_mw
```

In intersectional studies, we have found combined race/ethnicity and sex to be a useful category. We unite two columns to create the `race_sex` column. 

```{r}
# create a new category
pre_mw[, race_sex := paste(race, sex, sep = " ")]

# examine the result
pre_mw
```

*Multiway data* are characterized by two categorical variables and one quantitative variable [@Cleveland:1993]. In this example, the two categories are program and race/ethnicity/sex and the quantitative variable is the number of students ever enrolled. 

To structure the data in multiway form, we select the three multiway variables. 

```{r}
# select the three multiway variables
cols_we_want <- c("program", "race_sex", "ever")
pre_mw <- pre_mw[, ..cols_we_want]

# examine the result
pre_mw
```

The second attribute of multiway data is that the levels of the categories are ordered by the median value of the quantitative variable. `prepare_multiway()`  converts the categorical variables to factors and orders the category levels.  

```{r}
# order the category levels
data_mw <- prepare_multiway(pre_mw)
```

The median values are attributes of the data frame. We can view them as follows. Note that `program` and `race_sex` are now factors ordered by the median enrolled numbers (recorded under the `scores` attribute). 

```{r}
lapply(data_mw, FUN = attributes)
```

## Graph the results

```{r include = FALSE}
asp_ratio <- asp_ratio_mw(data_mw, categories = c("program", "race_sex"))
```

We use ggplot2 to graph the multiway data. Rows and panels, from top to bottom, are ordered by decreasing medians. We use a logarithmic scale because the numbers differ by orders of magnitude. In a log base-2 scale, every grid line represents a doubling of the previous grid line.   

```{r fig1, fig.asp = 0.8}
ggplot(data = data_mw, mapping = aes(x = ever, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  scale_x_continuous(
    trans = "log2",
    breaks = 2^seq(4, 14),
    limits = 2^c(4, 14)
  ) +
  theme(panel.grid.minor.x = element_blank()) +
  labs(
    x = "Number of students (log-2 scale)",
    y = "",
    title = "Ever enrolled in the program",
    caption = "Source: midfielddata"
  )
```

## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval=FALSE}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# gather programs
engineering <- filter_text(cip, keep_text = "^14", keep_col = "cip6")
engineering[, program := "Engineering"]
business <- filter_text(cip, keep_text = "^52", keep_col = "cip6")
business <- business[, program := "Business"]
program_group <- rbindlist(list(engineering, business))
group_cip <- program_group$cip6

# gather students
cols_we_want <- c("id", "cip6", "institution")
rows_we_want <- midfieldterms$cip6 %chin% group_cip
DT <- midfieldterms[rows_we_want, ..cols_we_want]
DT <- unique(DT)
latest_id <- unique(DT$id)
cols_we_want <- c("id")
rows_we_want <- midfieldstudents$id %chin% latest_id
matriculate <- midfieldstudents[rows_we_want, ..cols_we_want]
latest_id <- unique(matriculate$id)

# join grouping variables
cols_we_want <- c("id", "race", "sex")
rows_we_want <- midfieldstudents$id %chin% latest_id
race_sex <- midfieldstudents[rows_we_want, ..cols_we_want]
DT <- merge(DT, race_sex, by = "id", all.x = FALSE)
latest_id <- unique(DT[, (id)])
DT <- merge(DT, program_group, by = "cip6", all.x = TRUE)

# group and summarize
grouping_variables <- c("program", "race", "sex")
grouped_DT <- DT[, .(ever = .N), by = grouping_variables]

# condition the data for display
pre_mw <- copy(grouped_DT)
rows_we_want <- !pre_mw$race %chin% c("Unknown", "International", "Other")
pre_mw <- pre_mw[rows_we_want]
rows_we_want <- pre_mw$ever > 10
pre_mw <- pre_mw[rows_we_want]
pre_mw[, race_sex := paste(race, sex, sep = " ")]
cols_we_want <- c("program", "race_sex", "ever")
pre_mw <- pre_mw[, ..cols_we_want]
data_mw <- prepare_multiway(pre_mw)

# graph results
ggplot(data = data_mw, mapping = aes(x = ever, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  scale_x_continuous(
    trans = "log2",
    breaks = 2^seq(4, 14),
    limits = 2^c(4, 14)
  ) +
  theme(panel.grid.minor.x = element_blank()) +
  labs(
    x = "Number of students (log-2 scale)",
    y = "",
    title = "Ever enrolled in the program",
    caption = "Source: midfielddata"
  )
```
