---
title: "Case study: Data"
author: "Richard Layton"
date: "`r Sys.Date()`"
link-citations: yes
bibliography: ../inst/REFERENCES.bib
output: rmarkdown::html_vignette
csl: ../inst/information-science-and-technology.csl
vignette: >
  %\VignetteIndexEntry{Case study: Data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
nocite: | 
resource_files: |
---

```{r setup, include = FALSE}
# code chunks
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE
)

# figures
knitr::opts_chunk$set(
    fig.path = "../man/figures/art-002-case-data-", 
    fig.width = 6,
    fig.asp = 1 / 1.6,
    out.width = "70%",
    fig.align = "center"
)

# inline numbers
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
```

Part 2 of a case study in four parts:

- [Goals.](art-001-case-goals.html) Describing the study parameters.  
- [Data.](art-002-case-data.html) Transforming the data to yield the observations of interest.
- [Metrics.](art-003-case-metrics.html) Calculating summary statistics and metrics.
- [Displays.](art-004-case-displays.html) Creating tables and charts to display results.





## Preface

Our data manipulation goal is to reduce the source data tables to the specific observations needed to compute our metrics. The data manipulation tasks include selecting, renaming, and recoding variables, creating new variables, joining data frames, and filtering observations. 

The analysis is organized to produce two data frames: students ever enrolled in the programs; and students graduating from the programs. Both are keyed by student ID. 

If you are writing your own script to follow along, we start with these packages: 

```{r}
# Packages
library("midfieldr")
library("midfielddata")
suppressPackageStartupMessages(library("data.table"))

# Printing options for data.table
options(
  datatable.print.nrows = 15,
  datatable.print.topn = 3,
  datatable.print.class = TRUE
)
```






## Import data

All MIDFIELD data are in block-record form, that is, every row is an observation (keyed by student ID) and every column is a variable. Data structure is explored in greater detail in  the [Getting started](art-000-getting-started.html) vignette. 

**Importing.** Load three of the midfielddata data tables. 

```{r}
# Load practice data
data(student, term, degree)
```


## Gather ever enrolled 

Copy the `term` data set to create the working data frame (`DT`), leaving `term` unaltered for later use. 

```{r}
# Initialize the working data table
DT <- copy(term)
str(DT)
```

The result has `r nrow(DT)` observations. We will usually note the number of observations as they change. 

**Selecting.** For the stickiness metric, only three variables are needed: `mcid` is a key;  `institution` is required for data sufficiency; `cip6` is required for labeling programs. We drop unnecessary columns. 

```{r}
# Retain necessary columns
DT <- DT[, .(mcid, institution, cip6)]
DT[]
```

**Filtering.** Remove duplicate rows. 

```{r}
# Retain unique observations
DT <- unique(DT)
DT[]

# Count unique IDs
length(unique(DT$mcid))
```

The result has `r nrow(DT)` observations. The number of unique students is smaller than the number of observations because students change majors. Here we have one row per unique combination of student (`mcid`) and program (`cip6`).  






## Filter for data sufficiency

The time span of records varies by institution, each having their own lower and upper bounds. For some student records, data are insufficient at the boundaries to unambiguously assess program completion. Neglecting to exclude such records results in false summary counts. 

**Creating variables.** Using information in `term`, we add the  `timely_term` variable needed for data sufficiency. 

```{r}
# Access term data to add institution and timely term variable
DT <- add_timely_term(DT)
DT[]
```

**Creating variables.** Using information in `term`, we add the  `data_sufficiency` variable.

```{r}
# Access term data to add data sufficiency variable
DT <- add_data_sufficiency(DT)
DT[]
```

**Filtering.** We filter to retain observations for which the data are sufficient.   

```{r}
# Filter for data sufficiency
DT <- DT[data_sufficiency == "include"]
DT[]

# Count unique IDs
length(unique(DT$mcid))
```

The result has `r nrow(DT)` observations of `r length(unique(DT$mcid))` unique students.

**Selecting.** Drop unnecessary columns. 

```{r}
# Retain necessary columns
DT <- DT[, .(mcid, cip6)]
DT[]
```








## Filter for degree-seeking

The `term` data table (and therefore `DT`) includes all students enrolled, degree-seeking or not. The `student` data table contains only students admitted as degree-seeking. In a study of program stickiness, we must exclude non-degree-seeking students.

**Filtering.** Retain degree-seeking students only. 

```{r}
# Retain degree-seeking students
DT <- filter_match(DT, match_to = student, by_col = "mcid")
DT[]
```

The result has `r nrow(DT)` observations. (No change is expected in this example because all students in the midfielddata practice data are degree-seeking.) 






## Filter by program 

The US Classification of Instructional Programs (CIP) provides an encoding of academic programs. The `cip6` variable is the 6-digit CIP code of the program in which a student is enrolled in a given term. 

For example, CIPs for Civil Engineering programs start with 1408, Electrical Engineering 1410, Mechanical Engineering 1419, and Industrial/Systems Engineering 1427, 1435, 1436, and 1437. 

**Importing.** The `cip` data set bundled with midfieldr contains all 6-digit CIP codes for the programs in the case study. 

```{r}
# Collect a CIP subset 
study_program <- filter_search(cip, keep_text = c("^1408", "^1410", "^1419", "^1427", "^1435", "^1436", "^1437"))

# Retain necessary columns
study_program <- study_program[, .(cip6, cip6name)]
study_program[]
```

**Creating variables.** Add a variable to label each of these `r nrow(study_program)` programs with one of the four conventional program abbreviations we will use in comparing metrics, i.e., Civil (CE), Electrical (EE), Mechanical (ME), and Industrial/Systems Engineering (ISE). 

```{r}
# Add a custom program abbreviation
study_program[, program := fcase(
    cip6 %like% "^1408", "CE", 
    cip6 %like% "^1410", "EE", 
    cip6 %like% "^1419", "ME", 
    cip6 %between% c("142701", "143701"), "ISE"
)]

# View partial result
print(study_program[, .(cip6name, program)])
```

**Selecting.** Having checked that the new abbreviations correctly represent the programs, we drop the `cip6name` variable. 

```{r}
# Retain necessary columns
study_program[, cip6name := NULL]
study_program[]
```

**Joining.** Join program names for students ever enrolled in the study programs. 

```{r}
# Label program in every term 
DT <- merge(DT, study_program, by = "cip6", all.x = TRUE)
DT[]
```

**Filtering.**  All instances of NA programs are dropped.

```{r}
# Retain observations in the study programs
DT <- DT[!is.na(program)]
DT[]

# Count unique IDs
length(unique(DT$mcid))
```

The result has `r nrow(DT)` observations of `r length(unique(DT$mcid))` unique students.

**Filtering.** A program label can be associated with multiple CIP codes. We drop the code and filter to remove duplicates to ensure unique combinations of ID and program. 

```{r}
# Ensure unique combinations of student ID and program label
DT[, cip6 := NULL]
DT <- unique(DT)
DT[]

# Count unique IDs
length(unique(DT$mcid))
```

The result has `r nrow(DT)` observations of `r length(unique(DT$mcid))` unique students.

## Add demographics

**Creating variables.** Here we add a variable with a student's race/ethnicity and sex  using information in the `student` data table.

```{r}
# Access student data to add race/ethnicity and sex variables 
DT <- add_race_sex(DT)
DT[]
```

**Filtering.** Suppose our study design excludes students whose race/ethnicity is unknown or "International".  We filter on the `race` variable to remove those observations. 

```{r}
# Retain "domestic" students with known race/ethnicity
DT <- DT[race %chin% c("International", "Other/Unknown")]
DT[]

# Count unique IDs
length(unique(DT$mcid))
```


```{r include = FALSE}
study_reduced_ever <- copy(DT)
```

The result has `r nrow(DT)` observations of `r length(unique(DT$mcid))` unique students.

**Write to file.**  Results like these, used as inputs for calculating summary statistics and metrics, are often written to file as an intermediate result. In this case, the data frame above is bundled with midfieldr as `study_reduced_ever`. 








## Gather graduates

Because the previous data frame contains all students ever enrolled in our four programs, we can use it as a starting point for gathering the program graduates into a separate data frame. 

```{r}
# Gather unique students from the "ever enrolled" data processing 
# study_reduced_ever data is bundled with midfieldr
DT <- copy(study_reduced_ever)
DT <- DT[, .(mcid, race, sex)]
DT <- unique(DT)
DT[]
```

The result has `r nrow(DT)` unique observations.

To be counted as a graduate in this metric, a student must complete their program in a timely manner (default 6 years after admission, with reduced spans for some transfer students). 


## Filter for timely completion 


**Creating variables.** Using information in `term`, we again determine timely completion terms for use in determineg timely completion. 

```{r}
# Access term data to add timely term 
DT <- add_timely_term(DT)
DT[]
```

**Creating variables.** Using information in `degree`, we determine if students complete their programs and if so whether the completion was timely.  

```{r}
# Access degree data to add timely completion
DT <- add_timely_completion(DT, details = TRUE)
DT[]
```

**Filtering.** Retain records with timely completion TRUE. 

```{r}
# Retain records where completion was timely 
DT <- DT[timely_completion == TRUE]
DT[]
```

The result has `r nrow(DT)` unique observations.






## Filter by program

**Selecting.** Rename the CIP variable and drop unnecessary variables.

```{r}
# Prepare for next join operation 
setnames(DT, old = c("cip6_degree"), new = c("cip6"))

# Retain necessary columns
DT <- DT[, .(mcid, race, sex, cip6)]
DT[]
```

**Joining.** Join program names. A value of NA indicates the student completed a program other than one the four programs being studied.  

```{r}
# Label completed degree programs
DT <- merge(DT, study_program, by = "cip6", all.x = TRUE)
DT[]
```

**Filtering.** Retain programs of study only. 

```{r}
# Drop observations for programs not in the study
DT <- DT[!is.na(program)]
DT[]
```

**Filtering.** Ensure one combination only of ID and program.

```{r}
# Ensure unique combinations of ID and program
DT[, cip6 := NULL]
DT <- unique(DT)

# Rearrange columns for consistency with ever enrolled data
setcolorder(DT, c("mcid", "program"))
DT[]
```

The result has `r nrow(DT)` unique observations.

**Write to file.**  The data frame above is bundled with midfieldr as `study_reduced_grad`. 


## Closing

Starting with the `student`, `term`, and `degree` data tables, we have reduced the observations needed to determine stickiness. 

Two intermediate data frames were written to file: one for students ever-enrolled and one for graduates. 





