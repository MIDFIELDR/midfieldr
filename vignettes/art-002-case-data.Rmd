---
title: "Case study---data"
author: "Richard Layton"
date: "`r Sys.Date()`"
link-citations: yes
bibliography: ../inst/REFERENCES.bib
output: rmarkdown::html_vignette
csl: ../inst/information-science-and-technology.csl
vignette: >
  %\VignetteIndexEntry{Case study---data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
nocite: | 
resource_files: |
---

```{r setup, include = FALSE}
# code chunks
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE
)

# figures
knitr::opts_chunk$set(
    fig.path = "../man/figures/art-002-case-data-", 
    fig.width = 6,
    fig.asp = 1 / 1.6,
    out.width = "70%",
    fig.align = "center"
)

# inline numbers
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
```

Part 2 of a case study in four parts:

- [Goals.](art-001-case-goals.html) Describing the study parameters.  
- [Data.](art-002-case-data.html) Transforming the data to yield the observations of interest.
- [Metrics.](art-003-case-metrics.html) Calculating summary statistics and metrics.
- [Displays.](art-004-case-displays.html) Creating tables and charts to display results.





## Preface

Our data manipulation goal is to reduce the source data tables to the specific observations needed to compute our metrics. The data manipulation tasks include selecting, renaming, and recoding variables, creating new variables, joining data frames, and filtering observations. 

Computing the stickiness metric requires two data summaries: the count of students ever enrolled in the study programs and the count of students graduating from the programs. Therefore, this analysis is organized to produce a data frame with an ever-enrolled variable and timely-completion variable with observations keyed by student ID. 

If you are writing your own script to follow along, we start with these packages: 

```{r}
# Packages
library("midfieldr")
library("midfielddata")
suppressPackageStartupMessages(library("data.table"))

# Printing options for data.table
options(
  datatable.print.nrows = 15,
  datatable.print.topn = 3,
  datatable.print.class = TRUE
)
```






## Import data

All MIDFIELD data are in block-record form, that is, every row is an observation (keyed by student ID) and every column is a variable. Data structure is explored in greater detail in  the [Getting started](art-000-getting-started.html) vignette. 

**Importing.** Load three of the midfielddata data tables. 

```{r}
# Load practice data
data(student, term, degree)
```

Copy the `term` data set to create the working data frame (`DT`), leaving `term` unaltered for later use. 

```{r}
# Initialize the working data table
DT <- copy(term)
str(DT)
```

The result has `r nrow(DT)` observations. We will usually note the number of observations as they change. 

**Selecting.** For the stickiness metric, only three variables are needed: `mcid` is a key;  `institution` is required for data sufficiency; `cip6` is required for labeling programs. We drop unnecessary columns. 

```{r}
# Retain necessary columns
DT <- DT[, .(mcid, institution, cip6)]
DT[]
```

**Filtering.** Remove duplicate rows. 

```{r}
# Retain unique observations
DT <- unique(DT)
DT[]

# Count unique IDs
length(unique(DT$mcid))
```

The result has `r nrow(DT)` observations. The number of unique students is smaller than the number of observations because students change majors. Here we have one row per unique combination of student (`mcid`) and program (`cip6`).  






## Filter by data sufficiency

The time span of records varies by institution, each having their own lower and upper bounds. The bounds themselves create ambiguity in some records, specifically in our estimates of a student's *timely completion term,* the last term by which completing their program would be considered timely (typically a 6-year span). 

We filter observations to retain those with sufficient data. 

**Creating variables.** Using information in `term`, we add   `timely_term`---an estimated timely completion term for every student.   

```{r}
# Data sufficiency requires a timely term 
DT <- add_timely_term(DT, midfield_term = term)
DT[]
```

**Creating variables.** Again using information in `term`, we add  `data_sufficiency`---indicating that data are sufficient (TRUE/FALSE) for estimating timely completion.   

```{r}
# Add data sufficiency variable
DT <- add_data_sufficiency(DT, midfield_term = term)
DT[]
```

**Filtering.** We filter to retain observations for which the data are sufficient.   

```{r}
# Filter for data sufficiency
DT <- DT[data_sufficiency == TRUE]
DT[]

# Count unique IDs
length(unique(DT$mcid))
```

The result has `r nrow(DT)` observations of `r length(unique(DT$mcid))` unique students.

**Selecting.** Drop unnecessary columns. 

```{r}
# Retain necessary columns
DT <- DT[, .(mcid, cip6, timely_term)]
DT[]
```








## Filter for degree-seeking

The `term` data table (and therefore `DT`) includes all students enrolled, degree-seeking or not. The `student` data table contains only students admitted as degree-seeking. In a study of program stickiness, we must exclude non-degree-seeking students.

**Filtering.** Retain degree-seeking students only. 

```{r}
# Retain degree-seeking students
DT <- filter_match(DT, match_to = student, by_col = "mcid")
DT[]
```

The result has `r nrow(DT)` observations. (No change is expected in this example because all students in the midfielddata practice data are degree-seeking.) 






## Filter by program 

The US Classification of Instructional Programs (CIP) provides an encoding of academic programs. The `cip6` variable is the 6-digit CIP code of the program in which a student is enrolled in a given term. 

For example, CIPs for Civil Engineering programs start with 1408, Electrical Engineering 1410, Mechanical Engineering 1419, and Industrial/Systems Engineering 1427, 1435, 1436, and 1437. 

**Importing.** The `cip` data set bundled with midfieldr contains all 6-digit CIP codes for the programs in the case study. 

```{r}
# Collect a CIP subset 
study_program <- filter_search(cip, keep_text = c("^1408", "^1410", "^1419", "^1427", "^1435", "^1436", "^1437"))

# Retain necessary columns
study_program <- study_program[, .(cip6, cip6name)]
study_program[]
```

**Creating variables.** Add a variable to label each of these `r nrow(study_program)` programs with one of the four conventional program abbreviations we will use in comparing metrics, i.e., Civil (CE), Electrical (EE), Mechanical (ME), and Industrial/Systems Engineering (ISE). 

```{r}
# Add a custom program abbreviation
study_program[, program := fcase(
    cip6 %like% "^1408", "CE", 
    cip6 %like% "^1410", "EE", 
    cip6 %like% "^1419", "ME", 
    cip6 %between% c("142701", "143701"), "ISE"
)]

# View partial result
print(study_program[, .(cip6name, program)])
```

**Selecting.** Having checked that the new abbreviations correctly represent the programs, we drop the `cip6name` variable. 

```{r}
# Retain necessary columns
study_program[, cip6name := NULL]
study_program[]
```

**Joining.** Join program names for students ever enrolled in the study programs. 

```{r}
# Label program in every term 
DT <- merge(DT, study_program, by = "cip6", all.x = TRUE)
DT[]
```

**Filtering.**  All instances of `program` not equal to NA are retained.

```{r}
# Retain observations in the study programs
DT <- DT[!is.na(program)]
DT[]

# Count unique IDs
length(unique(DT$mcid))
```

The result has `r nrow(DT)` observations of `r length(unique(DT$mcid))` unique students.






## Determine timely completion 

*Timely completion* is defined as program completion no later than the timely completion term (default 6 years after admission). For transfer students, the timely completion span can be reduced to account for transfer credits. 

**Creating variables.** Add `completion_timely` with values of TRUE or FALSE with FALSE also assigned to non-completers. Setting `detail = TRUE` yields the CIP code for graduates' degree programs.

```{r}
# Add the completion timely variable
DT <- add_completion_timely(DT, midfield_degree = degree, detail = TRUE)
DT[]
```

For the stickiness metric, an untimely completer is counted as a non-completer. 

**Recoding.** Recode `cip6_degree` for untimely completers as NA. (Non-completers are already encoded as NA.) 

```{r}
# Recode untimely completers
DT <- DT[completion_timely == FALSE, cip6_degree:= NA_character_]
DT[]
```

**Selecting.** Drop unnecessary variables.

```{r}
# Retain necessary columns
DT <- DT[, .(mcid, program, cip6_degree)]
DT[]
```

We want to join the study program labels to the degree CIPs. We  rename two variables to facilitate the join. 

**Renaming.** Prepare for labeling degree CIPs with program names. The `program_ever` variable is used for summarizing the ever-enrolled population.    

```{r}
# Prepare for next join operation 
setnames(DT, 
         old = c("program", "cip6_degree"), 
         new = c("program_ever", "cip6"))
DT[]
```

**Joining.** Join program names for program completers.  

```{r}
# Label completed degree programs
DT <- merge(DT, study_program, by = "cip6", all.x = TRUE)
DT[]
```

**Renaming.** The `program_grad` variable is used for summarizing the timely-completion population.   

```{r}
# Naming for consistency of usage 
setnames(DT, old = c("program"), new = c("program_grad"))
DT[]
```

**Selecting.** Drop unnecessary variables.

```{r}
# Retain necessary columns
DT <- DT[, .(mcid, program_ever, program_grad)]
DT[]
```




## Add demographics

**Creating variables.** Here we add a variable with a student's race/ethnicity and sex  using information in the `student` data table.

```{r}
# Additional grouping variables 
DT <- add_race_sex(DT, midfield_student = student)
DT[]
```

**Filtering.** Suppose our study design excludes students whose race/ethnicity is unknown or "International".  We filter on the `race` variable to remove those observations. 

```{r}
# Retain "domestic" students with known race/ethnicity
rows_we_want <- !DT$race %chin% c("International", "Other/Unknown")
DT <- DT[rows_we_want]
DT[]

# Count unique IDs
length(unique(DT$mcid))
```

The result has `r nrow(DT)` observations of `r length(unique(DT$mcid))` unique students.

## Closing

Starting with the `student`, `term`, and `degree` data tables, we have reduced the observations needed to determine stickiness. 

**Write to file.**  Results like these, used as inputs for calculating summary statistics and metrics, are often written to file as an intermediate result. In this case, the final data frame above is bundled with midfieldr as `study_reduced_data`. 







