---
title: "Compute the stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Compute the stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
resource_files:
  - ../man/figures/vignette-compute-stickiness-fig1-1.png
---

```{r include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-compute-stickiness-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
```

## Introduction 

Longitudinal "stickiness" is the ratio of the number of students graduating in a program to the number of students ever enrolled in that program [@Ohland+Orr+others:2012]. 

The stickiness metric accounts for all students in a program. Unlike the graduation rate metric, stickiness includes students who begin college part-time, who enroll mid-year, and who switch majors or transfer between institutions. 

Every student counted in a program's stickiness metric was enrolled in that program for at least one term. The program succeeded in attracting these students---stickiness tells us how well the program succeeded in retaining them.

### This vignette uses

midfieldr functions 
 
- `filter_by_id()` 
- `filter_by_cip()` 
- `subset_feasible()` 

data.table syntax

- `copy()` prevent changing a source by reference
- `DT[rows_we_want]` subset rows 
- `DT[, .(new_col = .N), by = grouping_variables]` count N by group
- `DT[, new_col := FUN]` create new column as a function of old columns 
- `DT[rows_to_edit, col := value]` for identified rows, assign value in column 

packages

```{r}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# print max 20 rows, otherwise 10 rows each head/tail
options(datatable.print.nrows = 20, datatable.print.topn = 10)
```

## Choose the programs to study

In the *Gather programs* vignette [(link)](get_programs.html), we create the program group of 6-digit codes and user-defined program names  for the engineering case study. These data are included with midfieldr as the built-in data set `rep_group`. View its help page by running

```r
? rep_group 
```

The data are loaded with midfieldr. 

```{r}
# obtain programs (built-in data set)
program_group <- copy(rep_group)

# examine the result
program_group
```

We extract the `cip6` column as a character vector to gather student data. 

```{r}
# extract a vector of 6-digit CIP codes
group_cips <- program_group$cip6

# examine the result
group_cips
```

## Gather the students ever enrolled

We use `filter_by_cip()` to extract from `midfieldterms` the IDs of students ever enrolled in these programs.  

```{r}
# gather students ever enrolled in programs
enrollees <- filter_by_cip(midfieldterms,
  keep_cip = group_cips, # <---------------- group_cips from above
  keep_col = c("id", "cip6"),
  unique_row = TRUE
)

# examine the result
enrollees
```

There may be FYE students who are imputed to have started in one of these programs as well. In the *Impute FYE starting programs* vignette [(link)](impute_fye.html), we derive the starting programs for all FYE students in midfielddata. Again, we filter by the program group CIP codes. 

```{r}
# column name cip6 is required
fye <- copy(fye_start)
setnames(fye, old = "start", new = "cip6")

# gather FYE students predicted to start in these programs
fye_starters <- filter_by_cip(fye,
  keep_cip = group_cips,
  unique_row = TRUE
)

# examine the result
fye_starters
```

Bind the two data frames

```{r}
enrollees <- rbind(enrollees, fye_starters)
enrollees <- unique(enrollees)

# examine the result
enrollees
```

```{r include = FALSE, eval = FALSE}
# run this manually to save external data
rep_ever <- enrollees$id
usethis::use_data(
  rep_ever,
  internal  = FALSE,
  overwrite = TRUE
)
```

The enrollee data derived above is the data set `rep_ever` in midfieldr.  View its help page by running

```r
? rep_ever
```

For some of these students, completing their program may not be feasible given the range of data available. `subset_feasible()` subsets the student IDs, retaining those who matriculate at least six years before the last term in the data. 

```{r}
# apply the feasible completion filter
feasible_ids <- subset_feasible(id = enrollees$id)

# examine the result
str(feasible_ids)
```

See the *Filter for program completion feasibility* vignette [(link)](feasible_completion.html) for a detailed explanation of how completion feasibility is determined.

```{r}
# subset the enrollees
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]

# examine the result
enrollees
```

We use `filter_by_id()` to extract from `midfieldstudents` the race/ethnicity and sex of the enrollees. 

```{r}
# obtain race/ethnicity and sex at matriculation
race_sex <- filter_by_id(midfieldstudents,
  keep_id = feasible_ids, # <---------------- feasible_ids from above
  keep_col = c("id", "race", "sex"),
  unique_row = TRUE
)

# examine the result
race_sex
```

Now we can join the race/ethnicity and sex data frame to the enrollees data frame. 

```{r}
# left-join demographics to enrollees
enrollees <- merge(enrollees, race_sex, by = "id", all.x = TRUE)

# examine the result
enrollees
```

We join the program names from `program_group` to our working data frame so we can aggregate by groups in a future step.  

```{r}
# left-join program_group to enrollees
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)

# examine the result
enrollees
```

## Gather the students graduating 

A similar process is used to group and summarize our graduates. We use `filter_by_cip()` to extract from `midfielddegrees` the IDs of students  graduating from these programs. We skip the feasible completion step because for  graduates, the question of completion feasibility is moot---graduation itself establishes feasibility. 

```{r}
# gather students graduating from programs
graduates <- filter_by_cip(midfielddegrees,
  keep_cip = group_cips, # <---------------- group_cips again from above
  keep_col = c("id", "cip6"),
  unique_row = TRUE,
  first_degree = TRUE
)
race_sex <- filter_by_id(midfieldstudents,
  keep_id = graduates$id, # <---------------- from graduates just above
  keep_col = c("id", "race", "sex"),
  unique_row = TRUE
)
graduates <- merge(graduates, race_sex, by = "id", all.x = TRUE)
graduates <- merge(graduates, program_group, by = "cip6", all.x = TRUE)

# examine the result
graduates
```

## Group, summarize, and join 

To frame our results in terms of program, race/ethnicity, and sex, we assign these variables as our grouping variables. 

```{r}
# assign variables to aggregate by
grouping_variables <- c("program", "race", "sex")
```

We count the number of students in each grouping. The count is assigned to the new `ever` column. 

```{r}
# group and summarize
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]

# examine the result
grouped_enrollees
```

Note the change in the size of the data frame, from `r nrow(enrollees)` in `enrollees` where every row is a student to `r nrow(grouped_enrollees)` in the `grouped_enrollees` below where every row is a group.

Repeat for the graduates, creating the new `grad` column. 

```{r}
# group and summarize
grouped_graduates <- graduates[, .(grad = .N), by = grouping_variables]

# examine the result
grouped_graduates
```

We join the two data frames by our grouping variables, producing a data frame with `ever` and `grad` for each group. Note that we have `r nrow(grouped_enrollees)` groupings of enrollees but only `r nrow(grouped_graduates)` groupings of graduates. Some enrollee groups have no graduates. 


```{r}
# left-join graduates to enrollees
grouped_data <- merge(grouped_enrollees,
  grouped_graduates,
  by = grouping_variables, # <---------------- the grouping variables again
  all.x = TRUE
)

# examine the result, ordered by program
grouped_data[order(program)]
```

## Compute stickiness 

There are `r nrow(grouped_enrollees) - nrow(grouped_graduates)` NA entries in the `grad` column where we have enrollees but no graduates. To see them more directly:

```{r}
# begin work on computing the metric
stickiness <- grouped_data

# identify NA values
rows_with_degree_NA <- is.na(stickiness$grad)
stickiness[rows_with_degree_NA]
```

We convert the NA values in the `grad` column to zero.

```{r}
# convert grad NA to zero
stickiness[rows_with_degree_NA, grad := 0]

# examine the result
stickiness[rows_with_degree_NA]
```

We omit rows with zero students ever enrolled, if any, to avoid dividing by zero. 

```{r}
# prevent division by zero
rows_we_want <- stickiness$ever > 0
stickiness <- stickiness[rows_we_want]
```

Stickiness is the ratio of `grad` to `ever`.  

```{r}
# compute stickiness
stickiness[, stick := round(grad / ever, 2)]

# examine the result
stickiness
```

To see the class of each column: 

```{r}
# name and class of variables (columns)
unlist(lapply(stickiness, FUN = class))
```


The stickiness data derived above is the data set `rep_stickiness` in midfieldr.  View its help page by running

```r
? rep_stickiness
```

## Condition the data for display 

Before graphing, we isolate the three multiway variables (program, combined race and sex, and stickiness) and transform the categorical variables into factors with levels that are ordered by median stickiness. 

In the *Explore multiway data* vignette [(link)](explore_multiway.html), we describe this transformation in detail. The transformed multiway data are included with midfieldr as the built-in data set `rep_stickiness_mw`. View its help page by running

```r
? rep_stickiness_mw 
```

The data are loaded with midfieldr. 

```{r}
# condition the data in multiway form (built-in data set)
data_mw <- rep_stickiness_mw
data_mw
```

The attributes of the data frame confirm that the categorical variables are factors and not characters. The median values by which the factor levels are ordered are shown in the `scores` attributes. 

```{r}
# name and class of variables (columns)
lapply(data_mw, FUN = attributes)
```

## Graph the metric

```{r echo = FALSE}
nlevel1 <- nlevels(data_mw$program)
nlevel2 <- nlevels(data_mw$race_sex)
r <- nlevel1 * nlevel2
q <- 32
asp_ratio1 <- (r + 2 * nlevel1) / q
asp_ratio2 <- (r + 2 * nlevel2) / q
```

We use conventional ggplot2 functions to graph the `data_mw` data set in a multiway graph. 

```{r fig1, fig.asp = asp_ratio1}
# graph results
ggplot(data = data_mw, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```
<br>

For more information on multiway data and interpreting multiway graphs, see the *Explore multiway data* vignette [(link)](explore_multiway.html). 

## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval=FALSE}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# obtain programs (built-in data set)
program_group <- rep_group
group_cips <- program_group$cip6

# gather students ever enrolled in programs
enrollees <- filter_by_cip(midfieldterms,
  keep_cip = group_cips,
  keep_col = c("id", "cip6"),
  unique_row = TRUE
)
fye <- copy(fye_start)
setnames(fye, old = "start", new = "cip6")
fye_starters <- filter_by_cip(fye,
  keep_cip = group_cips,
  unique_row = TRUE
)
enrollees <- rbind(enrollees, fye_starters)
enrollees <- unique(enrollees)
feasible_ids <- subset_feasible(id = enrollees$id)
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]
race_sex <- filter_by_id(midfieldstudents,
  keep_id = feasible_ids,
  keep_col = c("id", "race", "sex"),
  unique_row = TRUE
)
enrollees <- merge(enrollees, race_sex, by = "id", all.x = TRUE)
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)

# gather students graduating from programs
graduates <- filter_by_cip(midfielddegrees,
  keep_cip = group_cips,
  keep_col = c("id", "cip6"),
  unique_row = TRUE,
  first_degree = TRUE
)
race_sex <- filter_by_id(midfieldstudents,
  keep_id = graduates$id,
  keep_col = c("id", "race", "sex"),
  unique_row = TRUE
)
graduates <- merge(graduates, race_sex, by = "id", all.x = TRUE)
graduates <- merge(graduates, program_group, by = "cip6", all.x = TRUE)

# group, summarize, and join
grouping_variables <- c("program", "race", "sex")
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]
grouped_graduates <- graduates[, .(grad = .N), by = grouping_variables]
grouped_data <- merge(grouped_enrollees,
  grouped_graduates,
  by = grouping_variables,
  all.x = TRUE
)

# compute the metric
stickiness <- grouped_data
rows_with_degree_NA <- is.na(stickiness$grad)
stickiness[rows_with_degree_NA, grad := 0]
rows_we_want <- stickiness$ever > 0
stickiness <- stickiness[rows_we_want]
stickiness[, stick := round(grad / ever, 2)]

# condition the data in multiway form (built-in data set)
data_mw <- rep_stickiness_mw

# graph results
ggplot(data = data_mw, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```
