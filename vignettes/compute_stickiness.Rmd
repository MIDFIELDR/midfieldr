---
title: "Compute the stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Compute the stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/journal-of-glaciology.csl
link-citations: yes
resource_files:
  - ../man/figures/vignette-compute-stickiness-fig1-1.png
---

```{r setup, include = FALSE}
source("vignette-knitr-opts.R")
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-compute-stickiness-")
```

## Introduction 

Longitudinal "stickiness" is the ratio of the number of students graduating in a program to the number of students ever enrolled in that program [@Ohland+Orr+others:2012]. 

The stickiness metric accounts for all students in a program. Unlike the graduation rate metric, stickiness includes students who begin college part-time, who enroll mid-year, and who switch majors or transfer between institutions. 

Every student counted in a program's stickiness metric was enrolled in that program for at least one term. The program succeeded in attracting these students---stickiness tells us how well the program succeeded in retaining them.

### This vignette uses

midfieldr functions 
 
- `filter_by_id()` 
- `filter_by_cip()` 
- `feasible_subset()` 

data.table syntax

- `DT[rows_we_want]` subset rows 
- `DT[, .(new_col = .N), by = grouping_variables]` count N by group
- `DT[, new_col := FUN]` create new column as a function of old columns 
- `DT[rows_to_edit, col := value]` for identified rows, assign value in column 

packages

```{r}
 # packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# print max 20 rows, otherwise 5 rows each head/tail
options(datatable.print.nrows = 20, datatable.print.topn = 5)
```


<br>
<a href="#top">&#9650; top of page</a>  

## Choose the programs to study

In the *Gather programs* vignette [(link)](get_programs.html), we create the program group of 6-digit codes and user-defined program names  for the engineering case study. These data are included with midfieldr as the built-in data set `rep_group`. View its help page by running

```r
? rep_group 
```

The data are loaded with midfieldr. 

```{r}
# obtain programs (built-in data set)
program_group <- rep_group

# examine the result
program_group
```

We extract the `cip6` column as a character vector to gather student data. 

```{r}
# extract a vector of 6-digit CIP codes
group_cips <- program_group$cip6

# examine the result
group_cips
```




<br>
<a href="#top">&#9650; top of page</a> 






## Gather the students ever enrolled

We use `filter_by_cip()` to extract from `midfieldstudents` the IDs of students ever enrolled in these programs.  

```{r}
# gather students ever enrolled in programs
enrollees <- filter_by_cip(midfieldterms,
  keep_cip = group_cips, # <---------------- group_cips from above
  keep_col = c("id", "cip6"),
  unique_row = TRUE
)

# examine the result
enrollees
```

For convenience, the IDs of these enrollees are included in midfieldr as the built-in character vector `rep_ever`. View its help page by running

```r
? rep_ever
```

For some of these students, completing their program may not be feasible given the range of data available. `feasible_subset()` subsets the student IDs, retaining those who matriculate at least six years before the last term in the data. 

```{r}
# apply the feasible completion filter
feasible_ids <- feasible_subset(id = enrollees$id)

# examine the result
str(feasible_ids)
```

See the *Filter for program completion feasibility* vignette [(link)](feasible_completion.html) for a detailed explanation of how completion feasibility is determined.

```{r}
# subset the enrollees
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]

# examine the result
enrollees
```

We use `filter_by_id()` to extract from `midfieldstudents` the race/ethnicity and sex of the enrollees. 

```{r}
# obtain race/ethnicity and sex at matriculation
race_sex <- filter_by_id(midfieldstudents,
  keep_id = feasible_ids, # <---------------- feasible_ids from above
  keep_col = c("id", "race", "sex"),
  unique_row = TRUE
)

# examine the result
race_sex
```

Now we can join the race/ethnicity and sex data frame to the enrollees data frame. 

```{r}
# left-join demographics to enrollees
enrollees <- merge(enrollees, race_sex, by = "id", all.x = TRUE)

# examine the result
enrollees
```

We join the program names from `program_group` to our working data frame so we can aggregate by groups in a future step.  

```{r}
# left-join program_group to enrollees
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)

# examine the result
enrollees
```



<br>
<a href="#top">&#9650; top of page</a>   




## Gather the students graduating 

A similar process is used to group and summarize our graduates. We use `filter_by_cip()` to extract from `midfielddegrees` the IDs of students  graduating from these programs. We skip the feasible completion step because for  graduates, the question of completion feasibility is moot---graduation itself establishes feasibility. 

```{r}
# gather students graduating from programs
graduates <- filter_by_cip(midfielddegrees,
  keep_cip = group_cips, # <---------------- group_cips again from above
  keep_col = c("id", "cip6"),
  unique_row = TRUE,
  first_degree = TRUE
)
race_sex <- filter_by_id(midfieldstudents,
  keep_id = graduates$id, # <---------------- from graduates just above
  keep_col = c("id", "race", "sex"),
  unique_row = TRUE
)
graduates <- merge(graduates, race_sex, by = "id", all.x = TRUE)
graduates <- merge(graduates, program_group, by = "cip6", all.x = TRUE)

# examine the result
graduates
```

For convenience, the IDs of these graduates are included in midfieldr as the built-in character vector `rep_grad`. View its help page by running

```r
? rep_grad
```
 



<br>
<a href="#top">&#9650; top of page</a>   




## Group, summarize, and join 

To frame our results in terms of program, race/ethnicity, and sex, we assign these variables as our grouping variables. 

```{r}
# assign variables to aggregate by
grouping_variables <- c("program", "race", "sex")
```

We count the number of students in each grouping. The count is assigned to the new `ever` column. 

```{r}
# group and summarize
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]

# examine the result
grouped_enrollees
```

Note the change in the size of the data frame, from `r nrow(enrollees)` in `enrollees` where every row is a student to `r nrow(grouped_enrollees)` in the `grouped_enrollees` below where every row is a group.

Repeat for the graduates, creating the new `grad` column. 

```{r}
# group and summarize
grouped_graduates <- graduates[, .(grad = .N), by = grouping_variables]

# examine the result
grouped_graduates
```

We join the two data frames by our grouping variables, producing a data frame with `ever` and `grad` for each group. Note that we have `r nrow(grouped_enrollees)` groupings of enrollees but only `r nrow(grouped_graduates)` groupings of graduates. Some enrollee groups have no graduates. 


```{r}
# left-join graduates to enrollees
grouped_data <- merge(grouped_enrollees,
  grouped_graduates,
  by = grouping_variables, # <---------------- the grouping variables again 
  all.x = TRUE
)

# examine the result, ordered by program
grouped_data[order(program)]
```







<br>
<a href="#top">&#9650; top of page</a>  





## Compute stickiness 

There are `r nrow(grouped_enrollees) - nrow(grouped_graduates)` NA entries in the `grad` column where we have enrollees but no graduates. To see them more directly:

```{r}
# begin work on computing the metric
stickiness <- grouped_data

# identify NA values
rows_with_degree_NA <- is.na(stickiness$grad)
stickiness[rows_with_degree_NA]
```

We convert the NA values in the `grad` column to zero.

```{r}
# convert grad NA to zero
stickiness[rows_with_degree_NA, grad := 0]

# examine the result
stickiness[rows_with_degree_NA]
```

We omit rows with zero students ever enrolled, if any, to avoid dividing by zero. 

```{r}
# prevent division by zero
rows_we_want <- stickiness$ever > 0
stickiness <- stickiness[rows_we_want]
```

Divide `grad` by `ever` to compute stickiness.  

```{r}
# compute stickiness
stickiness[, stick := round(grad / ever, 2)]

# examine the result
stickiness
```

To see the class of each column: 

```{r}
# name and class of variables (columns)
sapply(stickiness, FUN = class)
```


The stickiness data derived above is the data set `rep_stickiness` in midfieldr.  View its help page by running

```r
? rep_stickiness
```



<br>
<a href="#top">&#9650; top of page</a>   




## Condition the data for display 

Before graphing, we isolate the three multiway variables (program, combined race and sex, and stickiness) and transform the categorical variables into factors with levels that are ordered by median stickiness. 

In the *Explore multiway data* vignette [(link)](explore_multiway.html), we describe this transformation in detail. The transformed multiway data are included with midfieldr as the built-in data set `rep_stickiness_mw`. View its help page by running

```r
? rep_stickiness_mw 
```

The data are loaded with midfieldr. 

```{r}
# condition the data in multiway form (built-in data set)
data_mw <- rep_stickiness_mw
data_mw
```

The attributes of the data frame confirm that the categorical variables are factors and not characters. The median values by which the factor levels are ordered are shown in the `scores` attributes. 

```{r}
# name and class of variables (columns)
sapply(data_mw, FUN = attributes)
```





<br>
<a href="#top">&#9650; top of page</a>   





## Graph the metric

```{r echo = FALSE}
nlevel1 <- nlevels(data_mw$program)
nlevel2 <- nlevels(data_mw$race_sex)
r <- nlevel1 * nlevel2
q <- 32
asp_ratio1 <- (r + 2 * nlevel1) / q
asp_ratio2 <- (r + 2 * nlevel2) / q
```

We use conventional ggplot2 functions to graph the `data_mw` data set in a multiway graph. 

```{r fig1, fig.asp = asp_ratio1}
# graph results
ggplot(data = data_mw, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```
<br>

For more information on multiway data and interpreting multiway graphs, see the *Explore multiway data* vignette [(link)](explore_multiway.html). 






<br>
<a href="#top">&#9650; top of page</a>





## References

<div id="refs"></div>





## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval=FALSE}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# obtain programs (built-in data set)
program_group <- rep_group
group_cips <- program_group$cip6

# gather students ever enrolled in programs
enrollees <- filter_by_cip(midfieldterms,
  keep_cip = group_cips,
  keep_col = c("id", "cip6"),
  unique_row = TRUE
)
feasible_ids <- feasible_subset(id = enrollees$id)
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]
race_sex <- filter_by_id(midfieldstudents,
  keep_id = feasible_ids,
  keep_col = c("id", "race", "sex"),
  unique_row = TRUE
)
enrollees <- merge(enrollees, race_sex, by = "id", all.x = TRUE)
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)

# gather students graduating from programs
graduates <- filter_by_cip(midfielddegrees,
  keep_cip = group_cips,
  keep_col = c("id", "cip6"),
  unique_row = TRUE,
  first_degree = TRUE
)
race_sex <- filter_by_id(midfieldstudents,
  keep_id = graduates$id,
  keep_col = c("id", "race", "sex"),
  unique_row = TRUE
)
graduates <- merge(graduates, race_sex, by = "id", all.x = TRUE)
graduates <- merge(graduates, program_group, by = "cip6", all.x = TRUE)

# group, summarize, and join
grouping_variables <- c("program", "race", "sex")
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]
grouped_graduates <- graduates[, .(grad = .N), by = grouping_variables]
grouped_data <- merge(grouped_enrollees,
  grouped_graduates,
  by = grouping_variables,
  all.x = TRUE
)

# compute the metric
stickiness <- grouped_data
rows_with_degree_NA <- is.na(stickiness$grad)
stickiness[rows_with_degree_NA, grad := 0]
rows_we_want <- stickiness$ever > 0
stickiness <- stickiness[rows_we_want]
stickiness[, stick := round(grad / ever, 2)]

# condition the data in multiway form (built-in data set)
data_mw <- rep_stickiness_mw

# graph results
ggplot(data = data_mw, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```

<br>
<a href="#top"         >&#9650;     top of page </a>     
<a href="../index.html">&#9665;       main page </a> 



