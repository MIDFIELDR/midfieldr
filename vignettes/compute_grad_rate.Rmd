---
title: "Compute graduation rate"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Compute graduation rate}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
link-citations: yes
resource_files:
  - ../man/figures/grad-rate-fig1-1.png
---

```{r setup, echo = FALSE, message = FALSE, purl = FALSE}
knitr::opts_knit$set(root.dir = "../")
knitr::opts_chunk$set(
  echo = TRUE, # varies from one Rmd to another
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = TRUE,
  purl = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center",
  fig.path = "../man/figures/grad-rate-"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
options(tibble.print_min = 5L, tibble.print_max = 12L)

# normally, purl is FALSE. But in some code chunks, I want purl = TRUE so that the code in the vignette is executed to pass R CMD check. These next few lines set that up. In the code chunk header, add opts.label = 'dopurl'
knitr::knit_hooks$set(purl = knitr::hook_purl)
knitr::opts_template$set(dopurl = list(purl = TRUE, error = FALSE))
```

In this vignette, we demonstrate computing the "graduation rate" persistence metric using Civil, Electrical, Industrial, and Mechanical Engineering as our example programs. 



## Introduction 

Despite its flaws, graduation rate is commonly used persistence metric. 

In the US, the Integrated Postsecondary Education Data System (IPEDS) defines "graduation rate" as the fraction of *full-time, first-time,* degree/certificate-seeking undergraduate students in a particular year who *complete the program in which they matriculate* within 150 percent of normal time, i.e., *within 6 years* for a 4-year program [@ipeds2018]. 

The IPEDS definition excludes students who begin college part-time, who enroll mid-year, who transfer from one institution to another, and who change majors. The American Council on Education (ACE) estimates that this definition of graduation rate may exclude up to 60% of students at 4-year institutions [@ace2011]. 

So why use the metric? Do graduation rates really matter? Cook and Hartle say, yes they do ... 

> ... because in the eyes of the public, policy makers, and the media, they provide a clear, simple, and logical---if often misleading---number.

So with these caveats in mind, we provide the tools for determining  program graduation rates per the IPEDS definition. The workflow is: 

- choose the programs to study
- impute starting programs for FYE students, if any  
- gather starters 
- gather graduates 
- apply the IPEDS exclusions 
- compute graduation rate
- create a multiway graph 





<br>
<a href="#top">&#9650; top of page</a>   





## Choose programs

Our case studies continue with Civil, Electrical, Industrial, and Mechanical Engineering.  

```{r message = FALSE}
library("midfieldr")
library("midfielddata")
library("dplyr")
library("stringr")
library("ggplot2")
library("seplyr")
```

The [Gather program data](gather_program_data.html) vignette describes how to obtain the program codes and names for these programs. Their  6-digit CIP codes and names are in the midfieldr data set `case_program_group`. 

```{r}
# information saved from an earlier vignette
program_group <- case_program_group %>% 
        print()
```

There are a total of `r length(unique(program_group[["cip6"]]))` CIP codes for these programs. We have two columns from the `cip` dataset and the `program` column we added using `cip6_select()`. 




<br>
<a href="#top">&#9650; top of page</a>   




## Impute starting majors for FYE students

Some US institutions have first year engineering (FYE) programs---typically a common first year curriculum that is a prerequisite for declaring an engineering major. Because students matriculating in FYE cannot graduate in FYE, they cannot be included in a graduation rate metric without special treatment. 

Note that FYE students are neither undecided nor undeclared. Their institutions admitted them as engineering students. We define their "starting major" as the degree-granting engineering program---Civil, Electrical, Mechanical, etc.---that we predict they would have declared had they not been required to enroll in FYE. 

The prediction process is described in the vignette [Impute FYE starting majors](impute_fye.html). The results are available in the midfieldr data set `case_fye`. The data frame has two columns: the student ID of all FYE students in the midfielddata, and the 6-digit CIP of their imputed starting engineering major. 

```{r}
print(case_fye)
```




<br>
<a href="#top">&#9650; top of page</a> 




## Gather starters

We extract the vector of 6-digit CIP codes for our programs. 

```{r}
# obtain the cip6 codes 
program_series <- program_group[["cip6"]]
```

We use `starter_filter()` to extract students from `case_fye` data who start in  one of the programs in `program_series`. The `starter_filter()` function has two main arguments:

- `data` data frame with ID and 6-digit CIP codes
- `codes` atomic character vector of 6-digit CIP codes

```{r}
# extract starters from FYE
fye <- starter_filter(data = case_fye, codes = program_series) %>%
        print()
```

```{r echo=FALSE}
n_fye <- 100 * ceiling(nrow(fye)/100)
```

Thus we have nearly `r n_fye` FYE students imputed to have matriculated in one of our case study programs. 

We use `starter_filter()` again on the `midfieldterms` data to obtain non-FYE starters in our programs. The `data` argument default value is `midfieldterms`, so the following two code chunks yield the same result. 

```{r}
# explicit value for the data argument 
non_fye <- starter_filter(data = midfieldterms, codes = program_series)

# implicit value for the data argument is midfieldterms
non_fye <- starter_filter(codes = program_series)

print(non_fye)
```


 

<br>
<a href="#top">&#9650; top of page</a>  



## starter_filter() 

We use `starter_filter()` to collect all students starting in the programs we are studying. 

The `codes` argument in this case is an atomic vector of the 6-digit CIP codes in our `program_group`. The function uses these codes to search `midfieldstudents`, the default data set. Use `print()` to check the result.  

```{r}
program_series <- program_group[["cip6"]] %>%
        unique() %>%
        sort() %>%
        print()
```

Extract all students from `midfieldstudents` starting in these programs. 

```{r}
students <- starter_filter(codes = program_series) %>%
        print()
```

Open the help page by running 

```r
? starter_filter()
```



When studying engineering programs, we must account for the [imputed starting majors](impute_fye.html) of students at institutions with a required first year engineering (FYE) program. For the data in this package, the imputed values are saved in the `case_fye` data set. Use `starter_filter()` again with `case_fye` as the `data` argument. 

```{r}
fye <- starter_filter(data = case_fye, codes = program_series) %>%
        print()
```

Then bind the two data frames. 

```{r}
started <- bind_rows(students, fye) %>%
          ()
```

Confirm that the CIPs are the ones we expect and that no student ID has been inadvertently duplicated. 

```{r}
# should be a subset of the program_group CIP we started with
sort(unique(started[["cip6"]]))

# should match the dimension of starters
isTRUE(nrow(started) == length(unique(started[["id"]])))
```



<br>
<a href="#top">&#9650; top of page</a>   




## grad_filter()

Next we gather the graduates in our program group, but restrict ourselves to students who graduate in the same program in which they started. 

We use `grad_filter()` to search the  `midfielddegrees` dataset using the  programs listed in `program_series`.

```{r}
# count students graduating from programs
graduated <- grad_filter(codes = program_series) %>%
        print()
```

Open the help page by running 

```r
? grad_filter()
```



<br>
<a href="#top">&#9650; top of page</a>   




## Graduates must be starters

Again, only students who graduate from the program in which they start are counted when computing graduation rate per the IPEDS definition. Thus we keep only those graduates who graduate in the program in which they started. 

Before joining, we first change the `cip6` variable to `start` and `grad` in their respective data frames. 

```{r}
# started <- rename(started, start = cip6)
# graduated <- rename(graduated, grad = cip6)
```

In the join, we keep all starters and we keep only those graduates whose ID is also in the starters. 

```{r}
start_series <- started[["id"]] %>%
        glimpse()

collapse_series <- str_c(start_series, collapse = "|")

graduated <- filter(graduated, str_detect(id, collapse_series)) %>%
        print()
```

Join race and sex to both data frames, and the program names.  

```{r}
# assign the variables for grouping
grouping_variables <- c("program", "race", "sex")

# count students
started <- started %>%
        race_sex_join() %>%
        left_join(., program_group, by = "cip6") %>%
        group_summarize(., grouping_variables, "start" = n()) %>%
        print()

graduated <- graduated %>%
        race_sex_join() %>%
        left_join(., program_group, by = "cip6") %>%
        group_summarize(., grouping_variables, "grad" = n()) %>%
        print()
```

And join the two data frames

```{r}
# tally stickiness, by group
grad_rate <- left_join(started, graduated, by = grouping_variables) %>%
        filter(start > 5) %>%
        mutate(rate = round(grad / start, 2)) %>%
        print()
```



<br>
<a href="#top">&#9650; top of page</a>   




## Graph the multiway

As we've done in other vignettes, we prepare the multiway data and use conventional ggplot2 functions to create the multiway graph. 

```{r fig1, fig.asp = 2/1.6}
# prepare data for graph
grad_rate_mw <- grad_rate %>%
        filter(!race %in% c("Unknown", "International", "Other")) %>%
        filter(!sex %in% "Unknown") %>%
        mutate(race_sex = str_c(race, sex, sep = " ")) %>%
        select(program, race_sex, rate) %>%
        multiway_order()

# graph
ggplot(grad_rate_mw, aes(x = rate, y = race_sex)) +
        facet_wrap(vars(program), ncol = 1, as.table = FALSE) +
        geom_point(na.rm = TRUE) +
        labs(x = "Graduation rate (IPEDS definition)", y = "") +
        theme_midfield()
```



<br>
<a href="#top">&#9650; top of page</a>   




## References

<div id="refs"></div>


## Appendix

### Complete script

In response to requests from some of our workshop attendees, we collect the vignette code chunks in one script. We condense the script by omitting exploratory steps so we can focus on the steps that produce the results. 

```{r eval=FALSE}
# TBD
```

<br>
<a href="#top"         >&#9650;     top of page </a>     
<a href="../index.html">&#9665;       main page </a> 

