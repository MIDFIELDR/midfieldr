---
title: "Stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
resource_files:
  - ../man/figures/vignette-stickiness-metric-fig1-1.png
---

```{r include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-stickiness-metric-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
asp_ratio_mw <- function(data, categories) {
  cat1 <- categories[1] # panels
  cat2 <- categories[2] # rows
  nlevel1 <- nlevels(data[, get(cat1)])
  nlevel2 <- nlevels(data[, get(cat2)])
  r <- nlevel1 * nlevel2
  q <- 32
  asp_ratio1 <- (r + 2 * nlevel1) / q
  asp_ratio2 <- (r + 2 * nlevel2) / q
  ratios <- c(asp_ratio1, asp_ratio2)
}
```

## Introduction 

Longitudinal "stickiness" is the ratio of the number of students graduating in a program to the number of students ever enrolled in that program [@Ohland+Orr+others:2012]. 

Unlike the graduation rate metric, stickiness does not require that students matriculate and graduate in the same program. Every student counted in a program's stickiness metric was enrolled in that program for at least one term. The program succeeded in attracting these students---stickiness tells us how well the program succeeded in retaining them.

### This vignette uses

midfieldr functions 
 
- `subset_feasible()` described in [Feasible completion](feasible_completion.html) 
- `prepare_multiway()` described in [Multiway graphs and tables](multiway_graphs.html) 

midfieldr built-in data sets 

- `rep_group` described in [Identify programs](identify_programs.html) 
- `fye_start` described in [Handle FYE programs](handle_fye.html)

packages

```{r}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# print max 20 rows, otherwise 10 rows each head/tail
options(datatable.print.nrows = 20, datatable.print.topn = 10)
``` 




## Choose programs

The programs in this case study are available as the built-in data set `rep_group`. 

```{r}
# examine the built-in data 
rep_group
```

You may view its help page by running

```
? rep_group
```

For readability we assign the program group to a new name. 

```{r}
# create a new memory location 
program_labels <- copy(rep_group)
```

We extract the CIP codes as a vector for subsetting data. 

```{r}
# vector of CIP codes for subsetting
cip6_we_want <- program_labels$cip6
```




## Gather enrollees

We use the vector of CIP codes to filter `midfieldstudents`, `midfieldterms`, and `midfielddegrees` to obtain the IDs students ever enrolled in the group of programs. We access all three datasets to ensure we obtain all students ever enrolled. Duplicates are expected but only unique observations will be retained. 

```{r}
# two columns we want from each data set 
cols_we_want <- c("id", "cip6") 

# subset students
rows_we_want <- midfieldstudents$cip6 %chin% cip6_we_want
students <- midfieldstudents[rows_we_want, ..cols_we_want]

# subset terms 
rows_we_want <- midfieldterms$cip6 %chin% cip6_we_want
terms <- midfieldterms[rows_we_want, ..cols_we_want]

# subset degrees 
rows_we_want <- midfielddegrees$cip6 %chin% cip6_we_want
degrees <- midfielddegrees[rows_we_want, ..cols_we_want]
```

When studying engineering students we have to account for students enrolled in first-year engineering (FYE) programs. The predicted starting programs of FYE students in midfielddata are available as the built-in data set `fye_start`. 

```{r}
# examine fye data
fye_start
```

You may view its help page by running

```
? fye_start
```

Subset these data for our program group. 

```{r}
# subset FYE
rows_we_want <- fye_start$start %chin% cip6_we_want
cols_we_want <- c("id", "start")
fye <- fye_start[rows_we_want, ..cols_we_want]
```

Rename the `start` variable to `cip6` to match the students, terms, and degrees data. 

```{r}
# edit variable name before combining data
setnames(fye, old = "start", new = "cip6")

# examine the result
fye
```

Next we bind the four sets of IDs in a data frame named `ever` (for "ever enrolled") and reduce the data frame to its unique values. 

```{r}
# combine four data frames
data_to_bind <- list(students, terms, degrees, fye)
ever <- rbindlist(data_to_bind)
ever <- unique(ever)

# examine the result
ever
```

```{r include = FALSE, eval = FALSE}
# run this manually to save external data
rep_ever <- ever$id
usethis::use_data(
  rep_ever,
  internal  = FALSE,
  overwrite = TRUE
)
```

We subset our data for program completion feasibility. 

```{r}
# students for whom completion is feasible   
feasible_ids <- subset_feasible(id = ever$id)

# subset for feasible completion
rows_we_want <- ever$id %chin% feasible_ids
ever <- ever[rows_we_want]

# examine the result
ever
```

We extract the unique IDs as a vector for subsetting data.  

```{r}
# vector of IDs for subsetting
ever_id <- unique(ever$id)
```



## Gather graduates 

Graduates are filtered from the degree data by ID and CIP.  

```{r}
# subset graduates
rows_we_want <- midfielddegrees$id   %chin% ever_id & 
                midfielddegrees$cip6 %chin% cip6_we_want 
cols_we_want <- c("id", "cip6", "term_degree")
grad <- midfielddegrees[rows_we_want, ..cols_we_want]

# examine the result
grad
```

We retained the `term_degree` variable because some students might have earned a second degree in a term after their first degree(s). We want to retain only those degrees earned in a student's first degree term. 

```{r}
# keep the first degree term only
grad <- grad[, .SD[term_degree == min(term_degree)], by = id]

# select columns
grad <- grad[, .(id, cip6)]

# examine the result
grad
```

In this case, the number of graduates did not change after checking for subsequent degrees, but it is always a possibility and should be examined. 



## Subset with demographics 

Obtain race/ethnicity and sex variables keyed by ID. We will retain only those students for whom this information is known. 

```{r}
# obtain race/ethnicity and sex
rows_we_want <- midfieldstudents$id %chin% ever_id
cols_we_want <- c("id", "race", "sex")
demographics <- midfieldstudents[rows_we_want, ..cols_we_want]
demographics <- unique(demographics)

# examine the result
demographics
```

Examine the values for race and sex to determine which, if any, to omit from analysis. 

```{r}
unique(demographics$race)
unique(demographics$sex)
```

For our case study, we make the arbitrary decision to drop students identified as  International, Other, and Unknown. 

```{r}
# filter for specific race/ethnicity categories
rows_we_want <- demographics$race %chin% 
  c("Asian", "Black", "Hispanic", "Native American", "White")
demographics <- demographics[rows_we_want]

# examine the result
demographics
```

Subset enrollees and graduates, retaining only those IDs for whom we have demographic information. 

```{r}
# subset for known race/ethnicity and sex
rows_we_want <- ever$id %chin% demographics$id
ever <- ever[rows_we_want]

rows_we_want <- grad$id %chin% demographics$id
grad <- grad[rows_we_want]
```



## Join, group, and summarize

Join the demographics to the ever-enrolled and graduates data. 

```{r}
# join demographics
ever <- merge(ever, demographics, by = "id", all.x = TRUE)
grad <- merge(grad, demographics, by = "id", all.x = TRUE)

# examine the result
ever
grad
```

Join the program labels. 

```{r}
# join program labels
ever <- merge(ever, program_labels, by = "cip6", all.x = TRUE)
grad <- merge(grad, program_labels, by = "cip6", all.x = TRUE)

# examine the result
ever
grad
```

In preparation for counting, we drop the ID variable. 

```{r}
# assign aggregation variables
grouping_variables <- c("program", "race", "sex")

# select columns
ever <- ever[, ..grouping_variables]
grad <- grad[, ..grouping_variables]

# examine the result
ever
grad
```

Count the number of students enrolled by the grouping variables with the count  reported in the `ever` column. Repeat for graduates with the count reported in the `grad` column. 

```{r}
# summarize by grouping variables 
ever_group <- ever[, .(ever = .N), by = grouping_variables]
grad_group <- grad[, .(grad = .N), by = grouping_variables]

# examine the result
ever_group
grad_group
```

We join the two data frames by our grouping variables, producing the data frame in which stickiness can be computed. 

```{r}
# join graduates to enrollees
stickiness <- merge(ever_group, grad_group, by = grouping_variables, all.x = TRUE)

# examine the result
stickiness
```




## Compute stickiness 

Some groupings may have enrollees but no graduates. Such cases will have an NA in the `grad` column. We want to find them and convert NA to zero. 

```{r}
# find rows with grad NA
rows_with_NA_grad <- is.na(stickiness$grad)
stickiness[rows_with_NA_grad]

# convert NA to zero
stickiness[rows_with_NA_grad, grad := 0]

# examine the result
stickiness[rows_with_NA_grad]
```

Stickiness is the ratio of `grad` to `ever`.  We omit rows with zero students ever enrolled, if any, to avoid dividing by zero. 

```{r}
# prevent division by zero
rows_we_want <- stickiness$ever > 0
stickiness <- stickiness[rows_we_want]

# examine the result
stickiness
```

To protect confidentiality, we further restrict the number of students ever enrolled by omitting observations with 10 or fewer students. 

```{r}
# protect confidentiality
rows_we_want <- stickiness$ever > 10
stickiness   <- stickiness[rows_we_want]

# examine the result
stickiness
```

Compute stickiness. 

```{r}
# compute stickiness
stickiness[, stick := round(grad / ever, 2)]

# examine the result
stickiness
```

```{r include = FALSE, eval = FALSE}
# run this manually to save external data
rep_stickiness <- copy(stickiness)
usethis::use_data(
  rep_stickiness,
  internal  = FALSE,
  overwrite = TRUE
)
```



## Condition data for display 

Data that are ready to be conditioned as multiway data can be considered "pre-multiway". Thus we assign `pre_mw` as the new name of the data frame. 

```{r}
# create a new memory location 
pre_mw <- copy(stickiness)
```

Before graphing, we isolate the three multiway variables (program, combined race and sex, and stickiness).

```{r}
# create a combined race/ethnicity/sex variable
pre_mw[, race_sex := paste(race, sex)]

# select columns
columns_we_want <- c("program", "race_sex", "stick")
pre_mw <- pre_mw[, ..columns_we_want]
```

Transform the categorical variables into factors with levels that are ordered by median stickiness. The multiway-ready data frame is assigned the name `ready_mw`.  

```{r}
# convert the categorical variables to factors ordered by the stickiness value
ready_mw <- prepare_multiway(pre_mw)

# examine the result
ready_mw
```



## Graph the metric

```{r include = FALSE}
asp_ratio <- asp_ratio_mw(ready_mw, categories = c("program", "race_sex"))
```

We use conventional ggplot2 functions to graph the `ready_mw` data set in a multiway graph. Rows with no data marker are those we omitted for confidentiality. 

*Reminder:* These are practice data, not suitable for drawing inferences about student performance, i.e., not for research.

```{r fig1, fig.asp = asp_ratio[1]}
# multiway graph of practice data
ggplot(data = ready_mw, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", 
       y = "", 
       title = "Practice data (not for research)", 
       caption = "Source: midfielddata")
```




## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval=FALSE}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# choose programs
program_labels <- rep_group
cip6_we_want <- program_labels$cip6

# gather enrollees
cols_we_want <- c("id", "cip6") 
rows_we_want <- midfieldstudents$cip6 %chin% cip6_we_want
students <- midfieldstudents[rows_we_want, ..cols_we_want]
rows_we_want <- midfieldterms$cip6 %chin% cip6_we_want
terms <- midfieldterms[rows_we_want, ..cols_we_want]
rows_we_want <- midfielddegrees$cip6 %chin% cip6_we_want
degrees <- midfielddegrees[rows_we_want, ..cols_we_want]
rows_we_want <- fye_start$start %chin% cip6_we_want
cols_we_want <- c("id", "start")
fye <- fye_start[rows_we_want, ..cols_we_want]
setnames(fye, old = "start", new = "cip6")
data_to_bind <- list(students, terms, degrees, fye)
ever <- rbindlist(data_to_bind)
ever <- unique(ever)
feasible_ids <- subset_feasible(id = ever$id)
rows_we_want <- ever$id %chin% feasible_ids
ever <- ever[rows_we_want]
ever_id <- unique(ever$id)

# gather graduates
rows_we_want <- midfielddegrees$id   %chin% ever_id & 
                midfielddegrees$cip6 %chin% cip6_we_want 
cols_we_want <- c("id", "cip6", "term_degree")
grad <- midfielddegrees[rows_we_want, ..cols_we_want]
grad <- grad[, .SD[term_degree == min(term_degree)], by = id]
grad <- grad[, .(id, cip6)]

# subset with demographics
rows_we_want <- midfieldstudents$id %chin% ever_id
cols_we_want <- c("id", "race", "sex")
demographics <- midfieldstudents[rows_we_want, ..cols_we_want]
demographics <- unique(demographics)
rows_we_want <- demographics$race %chin% 
  c("Asian", "Black", "Hispanic", "Native American", "White")
demographics <- demographics[rows_we_want]
rows_we_want <- ever$id %chin% demographics$id
ever <- ever[rows_we_want]
rows_we_want <- grad$id %chin% demographics$id
grad <- grad[rows_we_want]

# join, group, and summarize
ever <- merge(ever, demographics, by = "id", all.x = TRUE)
grad <- merge(grad, demographics, by = "id", all.x = TRUE)
ever <- merge(ever, program_labels, by = "cip6", all.x = TRUE)
grad <- merge(grad, program_labels, by = "cip6", all.x = TRUE)
grouping_variables <- c("program", "race", "sex")
ever <- ever[, ..grouping_variables]
grad <- grad[, ..grouping_variables]
ever_group <- ever[, .(ever = .N), by = grouping_variables]
grad_group <- grad[, .(grad = .N), by = grouping_variables]
stickiness <- merge(ever_group, grad_group, by = grouping_variables, all.x = TRUE)

# compute stickiness
rows_with_NA_grad <- is.na(stickiness$grad)
stickiness[rows_with_NA_grad, grad := 0]
rows_we_want <- stickiness$ever > 10
stickiness   <- stickiness[rows_we_want]
stickiness[, stick := round(grad / ever, 2)]

# condition data for display
stickiness[, race_sex := paste(race, sex)]
columns_we_want <- c("program", "race_sex", "stick")
stickiness <- stickiness[, ..columns_we_want]
stickiness <- prepare_multiway(stickiness)

# graph the metric
ggplot(data = stickiness, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", 
       y = "", 
       title = "Practice data (not for research)", 
       caption = "Source: midfielddata")
```





