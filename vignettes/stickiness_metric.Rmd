---
title: "Stickiness metric"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Stickiness metric}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
resource_files:
  - ../man/figures/vignette-stickiness-metric-fig1-1.png
---

```{r include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-stickiness-metric-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
asp_ratio_mw <- function(data, categories) {
  cat1 <- categories[1] # panels
  cat2 <- categories[2] # rows
  nlevel1 <- nlevels(data[, get(cat1)])
  nlevel2 <- nlevels(data[, get(cat2)])
  r <- nlevel1 * nlevel2
  q <- 32
  asp_ratio1 <- (r + 2 * nlevel1) / q
  asp_ratio2 <- (r + 2 * nlevel2) / q
  ratios <- c(asp_ratio1, asp_ratio2)
}
```

## Introduction 

Longitudinal "stickiness" is the ratio of the number of students graduating in a program to the number of students ever enrolled in that program [@Ohland+Orr+others:2012]. 

The stickiness metric accounts for all students in a program. Unlike the graduation rate metric, stickiness includes students who begin college part-time, who enroll mid-year, and who switch majors or transfer between institutions. 

Every student counted in a program's stickiness metric was enrolled in that program for at least one term. The program succeeded in attracting these students---stickiness tells us how well the program succeeded in retaining them.

### This vignette uses

midfieldr functions 
 
- `subset_feasible()` 

packages

```{r}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# print max 20 rows, otherwise 10 rows each head/tail
options(datatable.print.nrows = 20, datatable.print.topn = 10)
``` 

## Choose the programs to study

In the *Identify programs* vignette [(link)](identify_programs.html), we create the program group of 6-digit codes and user-defined program names  for the engineering case study. These data are included with midfieldr as the built-in data set `rep_group`. View its help page by running

```r
? rep_group 
```

The data are loaded with midfieldr. 

```{r}
# obtain programs (built-in data set)
program_group <- copy(rep_group)

# examine the result
program_group
```

We extract the `cip6` column as a character vector to gather student data. 

```{r}
# extract a vector of 6-digit CIP codes
group_cip <- program_group$cip6

# examine the result
group_cip
```

## Gather the students ever enrolled

We access `midfieldterms` to obtain the IDs of all students ever enrolled in these programs.  

```{r}
# extract students ever enrolled
cols_we_want <- c("id", "cip6")
rows_we_want <- midfieldterms$cip6 %in% group_cip
enrollees <- midfieldterms[rows_we_want, ..cols_we_want]
enrollees <- unique(enrollees)

# examine the result
enrollees[order(id)]
```

There may be FYE students who are imputed to have started in one of these programs as well. In the *Handle FYE programs* vignette [(link)](handle_fye.html), we derive the starting programs for all FYE students in midfielddata. This `fye_start` data is included in midfieldr. Again, we filter by the program group CIP codes. 

```{r}
# gather FYE students predicted to start in these programs
rows_we_want <- fye_start$start %in% group_cip
cols_we_want <- c("id", "start")
fye_starters <- fye_start[rows_we_want, ..cols_we_want]
fye_starters <- unique(fye_starters)
setnames(fye_starters, old = "start", new = "cip6")

# examine the result
fye_starters[order(id)]
```

Bind the two data frames

```{r}
enrollees <- rbind(enrollees, fye_starters)
enrollees <- unique(enrollees)

# examine the result
enrollees[order(id)]
```

```{r include = FALSE, eval = FALSE}
# run this manually to save external data
rep_ever <- enrollees$id
usethis::use_data(
  rep_ever,
  internal  = FALSE,
  overwrite = TRUE
)
```

The enrollee data derived above is the data set `rep_ever` in midfieldr.  View its help page by running

```r
? rep_ever
```

For some of these students, completing their program may not be feasible given the range of data available. `subset_feasible()` subsets the student IDs, retaining those who matriculate at least six years before the last term in the data. 

```{r}
# apply the feasible completion filter
feasible_ids <- subset_feasible(id = enrollees$id)

# examine the result
str(feasible_ids)
```

See the *Feasible completion* vignette [(link)](feasible_completion.html) for a detailed explanation of how completion feasibility is determined.

```{r}
# subset the enrollees
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]

# examine the result
enrollees[order(id)]
```

We access `midfieldstudents` to obtain the race/ethnicity and sex of the enrollees. 

```{r}
# obtain race/ethnicity and sex at matriculation
rows_we_want <- midfieldstudents$id %in% feasible_ids
cols_we_want <- c("id", "race", "sex")
race_sex <- midfieldstudents[rows_we_want, ..cols_we_want]
race_sex <- unique(race_sex)

# examine the result
race_sex[order(id)]
```

Now we can join the race/ethnicity and sex data frame to the enrollees data frame. 

```{r}
# left-join demographics to enrollees
enrollees <- merge(enrollees, race_sex, by = "id", all.x = TRUE)

# examine the result
enrollees[order(id)]
```

We join the program names from `program_group` to our working data frame so we can aggregate by groups in a future step.  

```{r}
# left-join program_group to enrollees
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)

# examine the result
enrollees[order(id)]
```

## Gather the students graduating 

We access `midfielddegrees` to obtain the IDs of all students graduating from these programs.  We skip the feasible completion step because for  graduates, the question of completion feasibility is moot---graduation itself establishes feasibility. 

```{r}
# extract graduates
cols_we_want <- c("id", "cip6", "term_degree")
rows_we_want <- midfielddegrees$cip6 %in% group_cip
graduates <- midfielddegrees[rows_we_want, ..cols_we_want]

# examine the result
graduates[order(id)]
```

Some students might have earned a second degree in a term after their first degree. To ensure we count only the first degree, we the minimum value of `term_degree` grouped by `id`, using the data.table `.SD` syntax. 

```{r}
# keep the first degree term if more than one
graduates <- graduates[, .SD[term_degree == min(term_degree)], by = id]

# examine the result
graduates[order(id)]
```

We can remove the `term_degree` column and then we access `midfieldstudents` for student race/ethnicity and sex. 

```{r}
# finished with term_degree column
graduates[, term_degree := NULL]

# join race sex
rows_we_want <- midfieldstudents$id %in% graduates$id
cols_we_want <- c("id", "race", "sex")
race_sex <- midfieldstudents[rows_we_want, ..cols_we_want]
race_sex <- unique(race_sex)
graduates <- merge(graduates, race_sex, by = "id", all.x = TRUE)

# join program labels
graduates <- merge(graduates, program_group, by = "cip6", all.x = TRUE)

# examine the result
graduates[order(id)]
```

## Group, summarize, and join 

To frame our results in terms of program, race/ethnicity, and sex, we assign these variables as our grouping variables. 

```{r}
# assign variables to aggregate by
grouping_variables <- c("program", "race", "sex")
```

We count the number of students in each grouping. The count is assigned to the new `ever` column. 

```{r}
# group and summarize
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]

# examine the result
grouped_enrollees
```


Repeat for the graduates, creating the new `grad` column. 

```{r}
# group and summarize
grouped_graduates <- graduates[, .(grad = .N), by = grouping_variables]

# examine the result
grouped_graduates
```

We join the two data frames by our grouping variables, producing a data frame with `ever` and `grad` for each group. Note that we have `r nrow(grouped_enrollees)` groupings of enrollees but only `r nrow(grouped_graduates)` groupings of graduates. Some enrollee groups have no graduates. 


```{r}
# left-join graduates to enrollees
grouped_data <- merge(grouped_enrollees,
  grouped_graduates,
  by = grouping_variables,
  all.x = TRUE
)

# examine the result, ordered by program
grouped_data[order(program)]
```

## Compute stickiness 

There are `r nrow(grouped_enrollees) - nrow(grouped_graduates)` NA entries in the `grad` column where we have enrollees but no graduates. To see them more directly:

```{r}
# begin work on computing the metric
stickiness <- copy(grouped_data)

# identify NA values
rows_with_degree_NA <- is.na(stickiness$grad)
stickiness[rows_with_degree_NA]
```

We convert the NA values in the `grad` column to zero.

```{r}
# convert grad NA to zero
stickiness[rows_with_degree_NA, grad := 0]

# examine the result
stickiness[rows_with_degree_NA]
```

We omit rows with zero students ever enrolled, if any, to avoid dividing by zero. 

```{r}
# prevent division by zero
rows_we_want <- stickiness$ever > 0
stickiness <- stickiness[rows_we_want]
```

Stickiness is the ratio of `grad` to `ever`.  

```{r}
# compute stickiness
stickiness[, stick := round(grad / ever, 2)]

# examine the result
stickiness
```

To see the class of each column: 

```{r}
# name and class of variables (columns)
unlist(lapply(stickiness, FUN = class))
```

```{r include = FALSE, eval = FALSE}
# run this manually to save external data
rep_stickiness <- copy(stickiness)
usethis::use_data(
  rep_stickiness,
  internal  = FALSE,
  overwrite = TRUE
)
```

The stickiness data derived above is the data set `rep_stickiness` in midfieldr.  View its help page by running

```r
? rep_stickiness
```

## Condition the data for display 

Before graphing, we isolate the three multiway variables (program, combined race and sex, and stickiness) and transform the categorical variables into factors with levels that are ordered by median stickiness. 

The *Multiway graphs and tables* vignette [(link)](multiway_graphs.html) describes this process for the stickiness data in detail. The result is included as a data set `rep_stickiness_mw` in midfieldr. View its help page by running 

```r
? rep_stickiness_mw
```

This data set is loaded with midfieldr. 

```{r}
# condition the data in multiway form (built-in data set)
data_mw <- copy(rep_stickiness_mw)

# examine the result
data_mw
```

The attributes of the data frame confirm that the categorical variables are factors and not characters. The median values by which the factor levels are ordered are shown in the `scores` attributes. 

```{r}
# name and class of variables (columns)
lapply(data_mw, FUN = attributes)
```

## Graph the metric

```{r include = FALSE}
asp_ratio <- asp_ratio_mw(data_mw, categories = c("program", "race_sex"))
```

We use conventional ggplot2 functions to graph the `data_mw` data set in a multiway graph. 

```{r fig1, fig.asp = asp_ratio[1]}
# graph results
ggplot(data = data_mw, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```
<br>

For more information on multiway data and interpreting multiway graphs, see the *Multiway graphs and tables* vignette [(link)](multiway_graphs.html). 

## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval=FALSE}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# obtain programs (built-in data set)
program_group <- rep_group
group_cip <- program_group$cip6

# gather students ever enrolled in programs
cols_we_want <- c("id", "cip6")
rows_we_want <- midfieldterms$cip6 %in% group_cip
enrollees <- midfieldterms[rows_we_want, ..cols_we_want]
enrollees <- unique(enrollees)

# gather FYE students predicted to start in these programs
rows_we_want <- fye_start$start %in% group_cip
cols_we_want <- c("id", "start")
fye_starters <- fye_start[rows_we_want, ..cols_we_want]
fye_starters <- unique(fye_starters)
setnames(fye_starters, old = "start", new = "cip6")
enrollees <- rbind(enrollees, fye_starters)
enrollees <- unique(enrollees)

# apply the feasible completion filter
feasible_ids <- subset_feasible(id = enrollees$id)
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]

# obtain race/ethnicity and sex at matriculation
rows_we_want <- midfieldstudents$id %in% feasible_ids
cols_we_want <- c("id", "race", "sex")
race_sex <- midfieldstudents[rows_we_want, ..cols_we_want]
race_sex <- unique(race_sex)

# join data frames
enrollees <- merge(enrollees, race_sex, by = "id", all.x = TRUE)
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)

# gather students graduating from programs
cols_we_want <- c("id", "cip6", "term_degree")
rows_we_want <- midfielddegrees$cip6 %in% group_cip
graduates <- midfielddegrees[rows_we_want, ..cols_we_want]
graduates <- graduates[, .SD[term_degree == min(term_degree)], by = id]

# join race/ethnicity, sex, and program labels
rows_we_want <- midfieldstudents$id %in% graduates$id
cols_we_want <- c("id", "race", "sex")
race_sex <- midfieldstudents[rows_we_want, ..cols_we_want]
race_sex <- unique(race_sex)
graduates <- merge(graduates, race_sex, by = "id", all.x = TRUE)
graduates <- merge(graduates, program_group, by = "cip6", all.x = TRUE)

# group, summarize, and join
grouping_variables <- c("program", "race", "sex")
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]
grouped_graduates <- graduates[, .(grad = .N), by = grouping_variables]
grouped_data <- merge(grouped_enrollees,
  grouped_graduates,
  by = grouping_variables,
  all.x = TRUE
)

# compute the metric
stickiness <- grouped_data
rows_with_degree_NA <- is.na(stickiness$grad)
stickiness[rows_with_degree_NA, grad := 0]
rows_we_want <- stickiness$ever > 0
stickiness <- stickiness[rows_we_want]
stickiness[, stick := round(grad / ever, 2)]

# condition the data in multiway form (built-in data set)
data_mw <- rep_stickiness_mw

# graph results
ggplot(data = data_mw, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```
