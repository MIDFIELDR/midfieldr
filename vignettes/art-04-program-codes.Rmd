---
title: "Program codes"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Program codes}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/art-04-program-codes-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
```

## Introduction

In studying student records, a common first step is to subset the data, retaining some instructional programs and dropping others. In the US, instructional programs are encoded by "CIP" codes. 

CIP is the acronym for *Classification of Instructional Programs*, a taxonomy of academic programs curated by the US Department of Education [@NCES:2010]. A CIP code is a 6-digit integer assigned to an instructional program. The 2010 CIP codes are included with midfieldr in the data set `cip`. 

We explore the `cip` data set using several search strategies and we conclude by constructing an example data set used in subsequent vignettes.

### This vignette uses

midfieldr functions 

- `subset_text()` 

midfieldr built-in data sets 

- `cip`  

packages

```{r}
# packages used
library(midfieldr)
library(data.table)
```

```{r}
# optional code to control data.table printing
options(datatable.print.nrows = 10, datatable.print.topn = 5)
```


## Taxonomy of programs

Academic programs have three levels of codes and names:

- 6-digit code, a specific program
- 4-digit code, a group of 6-digit programs of comparable content 
- 2-digit code, a grouping of 4-digit groups of related content 

Loosely, the 6-digit level can be thought of as a specialty within a discipline, the 4-digit level is often equivalent to an academic department, and the 2-digit level is roughly equivalent to an academic college. For example, Geotechnical Engineering (140802) is a specialty in  Civil Engineering (1408) which is a department in the college of Engineering (14). 

```{r echo = FALSE}
df <- subset_text(cip, "^41")
n41 <- nrow(df)
n4102 <- nrow(subset_text(df, "^4102"))
n4103 <- nrow(subset_text(df, "^4103"))
name41 <- unique(df$cip2name)

df24 <- subset_text(cip, "^24")
n24 <- nrow(df24)
name24 <- unique(df24$cip2name)

df51 <- subset_text(cip, "^51")
n51 <- nrow(df51)
name51 <- unique(df51$cip2name)

df1313 <- subset_text(cip, "^1313")
n1313 <- nrow(df1313)
name1313 <- unique(df1313$cip2name)

cip <- subset_text(cip) # removes data.frame class if present
```

In the table below, we show all programs in the broad area of "`r name41`" (code 41) to illustrate the relationships among 2-, 4-, and 6-digit program codes and names in more detail. This 2-digit grouping is subdivided into `r length(unique(df$cip4))` groups at the 4-digit level (codes 4100--4199) which are further subdivided into `r n41` programs at the 6-digit level (codes 410000--419999). 

```{r echo=FALSE}
sub_cip <- subset_text(cip, "^41")
kable2html(sub_cip)
```
<br>

The number of 6-digit programs in a 4-digit group varies by program. Four-digit groupings include anywhere from 1 program (code 4100 above for example) to `r n1313` programs (code 1313 `r name1313`). 

Similarly, 2-digit groupings include anywhere from four 4-digit programs  (code 24 `r name24`) to `r n51` programs (code 51 `r name51`).

## `cip`

Data set that loads with midfieldr. For definitions of variables, view the help page by running 

```r
? cip
```

To see the data structure, run

```{r}
str(cip)
```

To see a few of the observations, run 

```{r}
cip
```

The number of unique programs, 

```{r}
# at the 2-digit level
sort(unique(cip[, cip2]))

# at the 4-digit level
length(unique(cip[, cip4]))

# at the 6-digit level
length(unique(cip[, cip6]))
```

A sample of program names, 

```{r}
set.seed(20210529)
some_programs <- cip[, .(cip4name)]
print(some_programs[sample(1:300, 20)], nrows = 20)
```


## `subset_text()`

`subset_text()` is the midfieldr function for searching the `cip` data set for program codes and names. View the help page by running

```r
? subset_text()
```

The variables in `cip` are all characters and `subset_text()` subsets a data frame using character search terms. The arguments are: 

- `data` data frame to be subsetted
- `keep_text` character vector of search patterns for retaining rows, not case-sensitive 
- `drop_text` (optional) character vector of search patterns for dropping rows

For example, filtering the CIP data for all programs containing the word "engineering" yields `r nrow(subset_text(cip, "engineering"))` observations. 

```{r}
# filter basics
subset_text(data = cip, keep_text = "engineering")
```

The first two argument names can be omitted. The optional `drop_text` argument, however, must be named if used.

```{r}
# only the drop_text argument must be named
subset_text(cip, "civil engineering", drop_text = "technology")
```

## Filter using keywords

Suppose we want to find the CIP codes and names for all programs in Civil Engineering. The search is case-insensitive, so we start with the following code chunk. 

```{r}
# example 1 filter using keywords
subset_text(cip, "civil")
```

The same information is tabulated below to help you see the structure.  In the examples that follow, we show a table like this one instead of the R output. 

```{r echo = FALSE}
sub_cip <- subset_text(cip, "civil")
# using kable_styling() for output but conceal from novice user
kable2html(sub_cip)
```
<br>

The search returns some programs with Civilization in their names as well as Engineering Technology. If we wanted Civil Engineering only, we can use a sequence of function calls, where the outcome of the one operation is assigned to the first argument of the next operation.  

The following code chunk could be read as, "Start with the `cip` data frame, then keep any rows in which 'civil' is detected, then keep any rows in which 'engineering' is detected, then drop any rows in which 'technology' is detected."

```{r results = "hide"}
# first search
first_pass <- subset_text(cip, "civil")

# refine the search
second_pass <- subset_text(first_pass, "engineering")

# refine further
third_pass <- subset_text(second_pass, drop_text = "technology")
```

```{r echo = FALSE}
kable2html(third_pass)
```
<br>

Seeing that all Civil Engineering programs have the same `cip4name`, we could have combined our arguments and obtained the same result. 

```r 
subset_text(cip, "civil engineering", drop_text = "technology")
```

## Filter using numerical codes

Suppose we want to study programs relating to German culture, language, and literature. Using  "german" for the `keep_text` value yields 

```{r results = "hide"}
# example 2 filter using numerical codes
subset_text(cip, "german")
```

```{r echo = FALSE}
sub_cip <- subset_text(cip, "german")
kable2html(sub_cip)
```
<br>

From the 6-digit program names we find only two that are of interest, German Studies (050125) and German Language and Literature (160501). We use a character vector to assign these two codes to the `keep_text` argument. 
 
```r
# character vector of search terms 
subset_text(cip, c("050125", "160501"))
```

```{r echo = FALSE}
sub_cip <- subset_text(cip, c("050125", "160501"))
kable2html(sub_cip)
```
<br>

If the 6-digit codes are entered as integers, they produce an error. 
 
```{r error = TRUE, purl = FALSE}
subset_text(cip, c(050125, 160501))
```

## Filter using regular expressions

Specifying 4-digit codes yields a data frame all 6-digit programs containing the 4-digit string. We use the regular expression notation `^` to match the start of the strings.

```r
# example 3 filter using regular expressions
subset_text(cip, c("^1407", "^1408"))
```

```{r echo = FALSE}
sub_cip <- subset_text(cip, c("^1407", "^1408"))
kable2html(sub_cip)
```
<br>

The 2-digit series represent the most general groupings of related programs. Here, the result includes all History programs. 

```r
# 2-digit example
subset_text(cip, "^54")
```

```{r echo = FALSE}
sub_cip <- subset_text(cip, "^54")
kable2html(sub_cip)
```
<br>

The series argument can include any combination of 2, 4, and 6-digit codes. It can also be passed to the function as a character vector. 

```{r results = "hide"}
# character vector of search terms 
codes_we_want <- c("^24", "^4102", "^450202")

# a series with 2, 4, and 6-digits specified
subset_text(cip, codes_we_want)
```

```{r echo = FALSE}
sub_cip <- subset_text(cip, codes_we_want)
kable2html(sub_cip)
```
<br>

## When search terms cannot be found

If the `keep_text` argument includes terms that cannot be found in the CIP data frame, the unsuccessful terms are identified in a message and the successful terms produce the usual output. 

For example, the following `keep_text` argument includes three search terms that are not present in the CIP data ("111111", "^55", and "Bogus") and two that are ("050125" and "160501").  

```{r message = TRUE}
# unsuccessful terms produce a message
sub_cip <- subset_text(cip, c("050125", "111111", "160501", "Bogus", "^55"))

# but the successful terms are returned
sub_cip
```

However, as seen earlier, if none of the search terms are found, an error occurs. 

```{r error = TRUE, purl = FALSE}
subset_text(cip, c("111111", "Bogus", "^55"))
```

## Optional arguments 

`subset_text()` has two additional optional arguments. 

- `keep_col` 
- `unique_row`  

As seen in the previous examples, the default setting for `keep_col` returns all columns. We can select columns by name, 

```{r}
# selecting columns
subset_text(cip,
  keep_text = "^54",
  keep_col = c("cip4", "cip4name")
)
```

The default setting for `unique_row` returns all rows. The default TRUE  argument removes duplicate rows after subsetting is complete. 

```{r}
# remove duplicate rows
subset_text(cip,
  keep_text = "^54",
  keep_col = c("cip4", "cip4name"),
  unique_row = TRUE
)
```


## CIP data from another source

If you use a CIP data set from another source, it must have the same structure as `cip`: six character columns named as follows,  

```{r}
# name and class of variables (columns) in cip
unlist(lapply(cip, FUN = class))
```





## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script. 

```{r eval=FALSE}
# packages used
library(midfieldr)
library(data.table)

# cip
str(cip)
sort(unique(cip[, cip2]))
length(unique(cip[, cip4]))
length(unique(cip[, cip6]))
set.seed(20210529)
some_programs <- cip[, .(cip4name)]
print(some_programs[sample(1:300, 20)], nrows = 20)

# subset_text()
subset_text(data = cip, keep_text = "engineering")
subset_text(cip, "civil engineering", drop_text = "technology")

# filter using keywords
subset_text(cip, "civil")
first_pass <- subset_text(cip, "civil")
second_pass <- subset_text(first_pass, "engineering")
third_pass <- subset_text(second_pass, drop_text = "technology")
subset_text(cip, "civil engineering", drop_text = "technology")

# filter using numerical codes
subset_text(cip, "german")
subset_text(cip, c("050125", "160501"))
subset_text(cip, c("^1407", "^1408"))
subset_text(cip, "^54")
codes_we_want <- c("^24", "^4102", "^450202")
subset_text(cip, codes_we_want)

# when search terms cannot be found
sub_cip <- subset_text(cip, c("050125", "111111", "160501", "Bogus", "^55"))
sub_cip

# optional arguments
subset_text(cip, "^54", keep_col = c("cip4", "cip4name"))
subset_text(cip, "^54", 
            keep_col = c("cip4", "cip4name"), 
            unique_row = TRUE)
```
