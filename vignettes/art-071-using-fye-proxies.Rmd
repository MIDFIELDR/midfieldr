---
title: "Using FYE proxies"
date: "`r Sys.Date()`"
link-citations: yes
bibliography: ../inst/REFERENCES.bib
output: rmarkdown::html_vignette
csl: ../inst/information-science-and-technology.csl
vignette: >
  %\VignetteIndexEntry{Using FYE proxies}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
nocite: |
resource_files: |
---

```{r setup}
#| include: false

# code chunks
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = FALSE,
  comment = "#>",
  error = FALSE
)

# figures
knitr::opts_chunk$set(
  fig.path = "../man/figures/art-071-using-fye-proxies-",
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)

# inline numbers
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
```


Part 2 of 2 parts illustrating how we work with First-Year Engineering (FYE) programs when a count of "starters" is needed. 

1. [Creating FYE proxies](art-070-creating-fye-proxies.html) Estimating the 6-digit CIP codes of the degree-granting engineering programs that FYE students would have declared in their first term had they not been required to enroll in FYE. 

2. Using FYE proxies (this page). Incorporating a set of prepared FYE proxies with other first-term CIP codes when a count of starters in degree-granting engineering programs is required.  






## Definitions

FYE

: First-Year Engineering program, a common-first-year curriculum that is a prerequisite for declaring an engineering major at some US institutions. 

FYE proxy

: The degree-granting engineering program we estimate an FYE student would have declared had they not been required to enroll in FYE. The proxy, a 6-digit CIP code, acts as a substitute for the FYE CIP code as needed. Applies only to students enrolled in FYE in their first term.

multiple imputation

: Method of imputing missing categorical data, in this case, the 6-digit CIP codes of FYE proxy programs. 






## Method

The procedure in this section requires that you have a prepared data set of FYE proxies from one of three possible sources: 

1. The `fye_proxy` data set, included with midfieldr, contains estimated starting programs for all first-term FYE students in the midfielddata practice data. Use with the midfielddata practice data only. This is the simplest case and is used here to illustrate our procedure.

2. A custom FYE proxy data set based on the midfielddata practice data,  created by following the guidelines in [Creating FYE proxies](art-070-creating-fye-proxies.html). Use with the midfielddata practice data only. 

3. A custom FYE proxy data set based on MIDFIELD research data to which you have access, created by following the guidelines in [Creating FYE proxies](art-070-creating-fye-proxies.html). Use with your MIDFIELD research data only. 

For practice in this section, we use the first case: the `fye_proxy` data set included with midfieldr. Our goal is to identify starters of the case study programs (Civil, Electrical, Industrial/Systems, and Mechanical Engineering) as if we were preparing to compute graduation rates.

In this example, the basic steps are to start with all students ever enrolled in the case study programs, filter for first-term information only, replace first-term FYE program codes with the prepared FYE proxies, and filter the result to retain the case study programs only. 

If you are writing your own script to follow along, we start with these packages:

```{r}
# Packages
library("midfieldr")
library("midfielddata")
suppressPackageStartupMessages(library("data.table"))

# Printing options for data.table
options(
  datatable.print.nrows = 17,
  datatable.print.topn = 5,
  datatable.print.class = TRUE
)
```








## Data

**Loading.** Data files included with with midfieldr.  

`study_mcid`

: IDs of students ever enrolled in four programs (Civil, Electrical, Industrial/Systems, and Mechanical Engineering) after filtering for data sufficiency, degree seeking, and program. (Deriving these data from the source data tables is described in [Case study: Data](art-002-case-data.html)).

```{r}
#| collapse: true
study_mcid
```

`study_programs`

: CIP codes and abbreviated labels for the case study programs. (Deriving these data from the source data tables is described in [Case study: Data](art-002-case-data.html)).

```{r}
#| collapse: true
study_programs
```

`fye_proxy`

: Proxy programs for all first-term FYE students in the practice data set. The `proxy` variable gives the estimated 6-digit CIP code. (Deriving these data from the source data tables is described in [Creating FYE proxies](art-070-creating-fye-proxies.html).)

```{r}
#| collapse: true
fye_proxy
```

**Importing.** Load the `term` data table. We use the `term` and `cip6` variables, keyed by student ID. 

```{r}
# Load data from midfielddata
data(term)

# Display selected columns
term[, .(mcid, term, cip6)]
```

You can view the help pages (and data dictionaries) by running

```{r}
#| eval: false

# Run in Console
? study_mcid
? study_programs
? fye_proxy
? term
```





## Obtain first-term records

**Adding variables.**  Starting with the IDs as our working data frame, we join the `term` and `cip6` columns from the `term` table, creating one row per term per student ID. 

```{r}
# Create working data frame
DT <- copy(study_mcid)

# Left-outer join, term into IDs
DT <- term[DT, .(mcid, term, cip6), on = c("mcid")]

# Display the result
DT[]
```

**Filtering.**  To identify starters for a graduation rate calculation, we are interested in the programs to which students are first admitted. Therefore, we order the rows by ID and term, then filter to retain their first term only. The resulting `cip6` column contains students' first-term CIP program codes. 

```{r}
# Retain initial term
setorderv(DT, cols = c("mcid", "term"))
DT <- DT[, .SD[1], by = c("mcid")]

# Display the result
DT[]
```







## Create start variable 

**Merging.** Merge `fye_proxy` with the working data frame `DT` and drop the `term` variable. Because a proxy is associated with first-term FYE students only, the left-outer join introduces NA values in the `proxy` column for all other students. 

```{r}
# Join the proxies to the working data frame
DT <- fye_proxy[DT, .(mcid, cip6, proxy), on = c("mcid")]

# Display the result
DT[]
```

**Creating a variable.**  Estimated starting programs for FYE students are in the `proxy` column. Actual, recorded starting programs for non-FYE students are in the `cip6` column. Create the `start` column to combine the two. 

```{r}
# Combine all starting CIPs
DT[, start := fcase(
  cip6 == "140102", proxy,
  cip6 != "140102", cip6
)]

# Display the result
DT[]
```

**Adding variables.** Add the case study program labels and drop unnecessary columns. The left-outer join introduces NA values in the `program` column for students not enrolled in one of the four study programs. 

```{r}
# New memory location for labels
join_labels <- copy(study_programs)

# Left-outer join, match by the CIPs in start
setnames(join_labels, old = "cip6", new = "start")
DT <- join_labels[DT, on = c("start")]

# Display the result
DT[order(program)]
```

**Filtering.** We retain students starting in one of the four majors in the case study. The result is ready to be used as the starting pool for a graduation rate calculation.

```{r}
# Keep the programs in the study
DT <- DT[!is.na(program)]
setcolorder(DT, c("mcid", "cip6", "proxy", "start"))

# Display the result
DT[order(program)]
```

**Data set-aside.** The case study direct matriculants are set aside for use in [Assessing FYE proxies]. 

```{r}
# Direct matriculants
direct_start <- DT[is.na(proxy), .(mcid, start, program)]

# Display the result
direct_start[order(start)]
```

**Drop unnecessary columns.**

```{r}
# Retain required columns
DT <- DT[, .(mcid, start, program)]

# Display the result
DT[]
```

For convenience, data in this form are included with midfieldr as `study_starters`. You can view the help page (and data dictionary) by running

```{r}
#| eval: false
#| echo: false

# Run manually if necessary for reproducibility
# Writing external file study_starters

study_starters <- copy(DT)
usethis::use_data(study_starters, overwrite = TRUE)
```

```{r}
#| eval: false

# Run in Console
? study_starters
```

**Confirming results.** Verify the results agree with the data included with midfieldr.

```{r}
#| collapse: true

# Verify results
all.equal(DT, study_starters)
```

*This step concludes the procedure for using prepared FYE proxy data.* 













## Assessing FYE proxies

### Starter miscounts

The main goal of estimating FYE proxies is to prevent starter miscounts. Here, we use two data sets developed earlier to assess the potential for miscounts if FYE records are not treated as recommended. The data sets are:

`direct_start`

: First-term direct starters in the case study programs. Excludes FYE students. 

`study_starters`

: All first-term starters---direct and FYE proxy---in the case study programs. 

**Data set `direct_start`**

```{r}
# Display the data set
direct_start[]
```

Summarizing by program. 

```{r}
# Count by program
direct <- direct_start[, .(direct_start = .N), by = "program"]

# Display the result
direct[]
```

**Data set `study_starters`** includes all direct starters and all FYE proxy starters in the case study. 

```{r}
# Display the data set
study_starters[]
```

Summarizing the `study_starters` data set. 

```{r}
# Count by program
estimated <- study_starters[, .(all_start = .N), by = "program"]

# Display the result
estimated[]
```

**Results.** Merging the data frames for comparison. 

```{r}
# Join
starter_subsets <- merge(direct, estimated, by = "program", all.x = TRUE)

# Display the result
starter_subsets[]
```

To quantify the potential for miscounts, we compute the percentage of starters represented by the FYE proxies.  

```{r}
# FYE percentage of all starters
starter_subsets[, FYE_pct := round(100 * (all_start - direct_start) / all_start, 1)]

# Display the result
starter_subsets[]
```

The results indicate (for these practice data at least) an under-count of 17% to 30% if FYE proxies are excluded when counting starters.  





### Credibility

Here we summarize the FYE proxy data set to see how many students our algorithm assigned to which engineering majors. Start by extracting the unique set of CIP codes from the proxy data set. 

```{r}
# Identify unique CIP codes in the proxy data
proxy_cips <- sort(unique(fye_proxy$proxy))

# Display the results
proxy_cips
```

Obtain the program names from the `cip` data set (provided with midfieldr). We use the 4-digit names that in engineering generally represent  department-level programs. 

```{r}
# Obtain the 4-digit program names corresponding to these codes
proxy_program_names <- filter_search(cip, keep_text = proxy_cips)
proxy_program_names <- proxy_program_names[, .(cip6, program = cip4name)]
proxy_program_names[]
```

Join these names to the proxy data set, summarize by program, and order the rows by descending N.  

```{r}
# Join these program names to the proxy data
proxy_programs <- proxy_program_names[fye_proxy[, .(cip6 = proxy)], .(program), on = c("cip6")]

# Count by program and order rows in descending magnitude
proxy_programs <- proxy_programs[, .N, by = c("program")]
setorderv(proxy_programs, order = -1, cols = c("N"))

# Display the result
proxy_programs[]
```

For comparison, the National Science Foundation (NSF) reports that in 2012, the top seven US engineering majors ranked by enrollment were [@NSF:2014]: 

- Mechanical
- Electrical
- Civil
- Chemical
- Industrial
- Aerospace
- Materials 

The NSF data table does not break out Computer Engineering as a separate observation---if we can assume that Computer Engineering is combined with  Electrical Engineering (a practice followed at many Engineering colleges), we obtain the following programs in order of enrollment, 

```{r}
# Combine Electrical and Computer Engineering
new_row <- data.table(
  program = "Electrical/Computer Engineering",
  N = sum(proxy_programs[program %ilike% "Electrical|Computer", N])
)

# New location in memory
rev_proxy <- copy(proxy_programs)

# Drop the separate Electrical and Computer rows
rev_proxy <- rev_proxy[!program %ilike% "Electrical|Computer"]

# Bind the new row and order
rev_proxy <- rbindlist(list(rev_proxy, new_row))
setorderv(rev_proxy, c("N"), -1)

# Display the top 7 rows
rev_proxy[1:7]
```

The NSF results are for a single year while the practice data used in our analysis span 30 years (1987--2016), so some differences are to be expected. Nevertheless, this listing matches the top six programs in the NSF list in nearly the same order (rows 5 and 6 have swapped places). 

We conclude that the imputation is credible at least to the extent that the ranking of the majors is consistent with expectations.







## Closing

For the practice data used in this example, results indicate a possible under-count of 17% to 30% if FYE proxies are excluded when counting starters.

The estimation/imputation process is credible at least to the extent that the ranking of the majors by enrollment is consistent with the 2012 rankings  reported by the NSF. 








## References

<div id="refs"></div>






## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script. 

```{r}
#| eval: false

# Obtain first-term records
DT <- copy(study_mcid)
DT <- term[DT, .(mcid, term, cip6), on = c("mcid")]
setorderv(DT, cols = c("mcid", "term"))
DT <- DT[, .SD[1], by = c("mcid")]

# Merge proxies 
DT <- fye_proxy[DT, .(mcid, cip6, proxy), on = c("mcid")]

# Create start variable
DT[, start := fcase(
  cip6 == "140102", proxy,
  cip6 != "140102", cip6
)]

# Filter desired programs
join_labels <- copy(study_programs)
setnames(join_labels, old = "cip6", new = "start")
DT <- join_labels[DT, on = c("start")]
DT <- DT[!is.na(program)]
setcolorder(DT, c("mcid", "cip6", "proxy", "start"))

# Data set-aside
direct_start <- DT[is.na(proxy), .(mcid, start, program)]

# Confirm results
DT <- DT[, .(mcid, start, program)]
all.equal(DT, study_starters)

# Assessing FYE proxies
direct <- direct_start[, .(direct_start = .N), by = "program"]
estimated <- study_starters[, .(all_start = .N), by = "program"]
starter_subsets <- merge(direct, estimated, by = "program", all.x = TRUE)
starter_subsets[, FYE_pct := round(100 * (all_start - direct_start) / all_start, 1)]

# Credibility
proxy_cips <- sort(unique(fye_proxy$proxy))
proxy_program_names <- filter_search(cip, keep_text = proxy_cips)
proxy_program_names <- proxy_program_names[, .(cip6, program = cip4name)]
proxy_programs <- proxy_program_names[fye_proxy[, .(cip6 = proxy)], .(program), on = c("cip6")]
proxy_programs <- proxy_programs[, .N, by = c("program")]
setorderv(proxy_programs, order = -1, cols = c("N"))

# Combine Electrical and Computer Engineering
new_row <- data.table(
  program = "Electrical/Computer Engineering",
  N = sum(proxy_programs[program %ilike% "Electrical|Computer", N])
)
rev_proxy <- copy(proxy_programs)
rev_proxy <- rev_proxy[!program %ilike% "Electrical|Computer"]
rev_proxy <- rbindlist(list(rev_proxy, new_row))
setorderv(rev_proxy, c("N"), -1)
rev_proxy[1:7]
```

```{r}
#| echo: false
# to change the CSS file for block quotes
# per https://github.com/rstudio/rmarkdown/issues/732
knitr::opts_chunk$set(echo = FALSE)
```

```{css}
blockquote {
    padding: 10px 20px;
    margin: 0 0 20px;
    border-left: 0px
}
```
