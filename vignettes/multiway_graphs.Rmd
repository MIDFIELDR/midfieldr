---
title: "Multiway graphs and tables"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multiway graphs and tables}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
resource_files:
  - ../man/figures/vignette-multiway-graphs-fig1-1.png
  - ../man/figures/vignette-multiway-graphs-fig2-1.png
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-multiway-graphs-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
asp_ratio_mw <- function(data, categories) {
  cat1 <- categories[1] # panels
  cat2 <- categories[2] # rows
  nlevel1 <- nlevels(data[, get(cat1)])
  nlevel2 <- nlevels(data[, get(cat2)])
  r <- nlevel1 * nlevel2
  q <- 32
  asp_ratio1 <- (r + 2 * nlevel1) / q
  asp_ratio2 <- (r + 2 * nlevel2) / q
  ratios <- c(asp_ratio1, asp_ratio2)
}
```

## Introduction 

For initial exploration of possible stories in the data, the most common graph design used by the MIDFIELD team is the multiway graph. We examine multiway data here, in this initial tutorial, because as Wickham states [@Wickham+Grolemund:2017], 

>  Visualization is a great place to start with R programming, because the payoff is so clear; you get to make elegant and informative plots that help you understand the data. 

Many persistence metrics can be organized as *multiway data* in which there is is one quantitative variable and two categorical variables. As explained by its inventor [@Cleveland:1993], 

> ... the quantitative variable is a response, and the goal is to study how it depends on the categorical variables, which are factors. What distinguishes multiway data is the cross-classification of the categorical variables; there is a value of the response for each combination of levels of the two categorical variables. 


`prepare_multiway()` is used to transform multiway data such that the two categorical variables are factors with levels ordered by the third, quantitative variable. In this vignette we explore its arguments using a case study in four engineering programs.

### This vignette uses

midfieldr functions 
 
- `prepare_multiway()` 

data.table syntax

- `copy()` prevent changing a source by reference
- `DT[rows_we_want]` subset rows 
- `DT[, ..cols_we_want]` select columns
- `DT[, new_col := FUN]` create new column as a function of old columns 
- `dcast(DT, row_coord ~ col_coord, values)` reshape block-record form to row-record form 

packages

```{r}
# packages used
library(midfieldr)
library(data.table)
library(ggplot2)

# print max 20 rows, otherwise 10 rows each head/tail
options(datatable.print.nrows = 20, datatable.print.topn = 10)
```

## Preparing the multiway data 

In the *Stickiness metric* vignette [(link)](stickiness_metric.html), we construct the data frame with the numbers of students ever enrolled in the case study programs, the number graduating, and the resulting program stickiness grouped by race/ethnicity, sex, and program. These data are included with midfieldr as the built-in data set `rep_stickiness`. View its help page by loading midfieldr and running

```r
? rep_stickiness 
```

The data are loaded with midfieldr. We assign it to the "pre-multiway" object `pre-mw`. 

```{r}
# load stickiness data from case study
pre_mw <- copy(rep_stickiness)

# examine the result
pre_mw
```

To protect confidentiality and prevent identification of individuals or institutions with small sub-populations, we typically omit rows with a small population. Using the larger MIDFIELD database, we usually set this limit to 10. Here, using the midfielddata sample, we'll use 5. 

```{r}
# prepare rows
rows_we_want <- pre_mw$ever >= 5
pre_mw <- pre_mw[rows_we_want]

# examine the result
pre_mw
```

We typically delete ambiguous levels of race/ethnicity. And because of its sparse representation in the data, we often omit the Native American population as well. 

```{r}
# remove rows of ambiguous or underrepresented populations
rows_we_want <- !pre_mw$race %in% c(
  "Unknown",
  "International",
  "Other",
  "Native American"
)
pre_mw <- pre_mw[rows_we_want]

# examine the result
unique(pre_mw$race)
```

We combine the race/ethnicity and sex column to create one of the multiway categorical variables. 

```{r}
# begin transformation to multiway form
data_mw <- copy(pre_mw)

# create a new combined framing variable
data_mw[, race_sex := paste(race, sex, sep = " ")]

# examine the result
data_mw
```

To complete the transformation to multiway form, we select the three multiway variables.  

```{r}
# select the multiway variables
cols_we_want <- c("program", "race_sex", "stick")
data_mw <- data_mw[, ..cols_we_want]

# examine the result
data_mw
```

Then we use `prepare_multiway()` to convert the character columns to factors ordered by the median stickiness.

```{r}
# transform characters to factors ordered by median stickiness
data_mw <- prepare_multiway(data_mw)

# examine the result
data_mw
```

```{r include = FALSE, eval = FALSE}
# run this manually to save external data
rep_stickiness_mw <- copy(data_mw)
usethis::use_data(
  rep_stickiness_mw,
  internal  = FALSE,
  overwrite = TRUE
)
```

The multiway data derived above is the data set `rep_stickiness_mw` in midfieldr.  View its help page by running

```r
? rep_stickiness_mw
```

## A multiway dot plot  

```{r include = FALSE}
asp_ratio <- asp_ratio_mw(data_mw, categories = c("program", "race_sex"))
```

We use conventional ggplot2 functions to create the multiway graphs. By previously ordering the levels of the factors, we have structured the data so that the rows and panels of the multiway graph are ordered by the appropriate medians. 

```{r fig1, fig.asp = asp_ratio[1]}
# create one multiway graph
ggplot(data = data_mw, aes(x = stick, y = race_sex)) +
  facet_wrap(vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```
<br>

This graph permits a direct visual comparison of how stickiness varies by race and sex within a particular major. 

Reading a multiway graph

- We can more effectively compare values within a panel than between panels.
- Because rows are ordered, one expects a generally increasing trend within a panel. A response greater or smaller than expected creates a visual asymmetry. The interesting stories are often in these visual anomalies.
- To explore the comparison between panels, we swap the row and panel categories, creating the dual multiway.

## The dual multiway dot plot 

The previous graph does not facilitate visual comparisons of members of the same race-sex group. As Cleveland says,

> Because of this asymmetry, it is often important to explore multiway data by as many multiway dot plots as there are categorical variables, with each variable assigned once to the levels.

To create the *dual multiway* graph, we swap the roles of the rows and panels. 

- `y = race_sex` becomes `y = program`
- `facet_wrap(vars(program) ...`  becomes `facet_wrap(vars(race_sex) ...` 

```{r fig2, fig.asp = asp_ratio[2]}
# create the dual multiway graph
ggplot(data = data_mw, aes(x = stick, y = program)) +
  facet_wrap(vars(race_sex), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```
<br>

This graph permits a direct visual comparison of how stickiness varies by major for one group of students. 

Both multiways should be created for discussion. Usually one or the other will convey a more compelling visual story that gets included in the published findings. 

## Creating a data table

Data tables are useful in discussions with one's research team and are often included in publications for editors or reviewers who want to see the values underlying the data graphics. The first thing to do before tabulating is to limit the significant figures of floating-point numbers. 

```{r results = "hide"}
# tabulate data in block record ("long") form
blockf <- copy(data_mw)

# limit significant digits
blockf[, stick := round(stick, 2)]

# examine the result
blockf
```

These data are laid out in "block record" form [@Mount+Zumel:2019:fluid-data], where the `race_sex` key and the `program` key are both in columns and the finding is in the last column. This layout is also called "tidy data"  [@Wickham+Grolemund:2017]. 

The graphing package we use, ggplot2, is designed to work most effectively with block-record data, thus the block-record ("long") form is the default layout in midfieldr. 

```{r echo = FALSE}
kable2html(blockf, caption = "Table 1: Stickiness (block records)")
```
<br>

However, the visual convention preferred by publishers and readers is a row-record ("wide") form, as illustrated by Table 2. The `race_sex` key is in the left column and the `program` key is in the column names. The stickiness findings lie at the row-column intersections. 

```{r echo = FALSE}
temp <- copy(blockf)
temp <- temp[, race_sex := as.character(race_sex)]
temp <- temp[, program := as.character(program)]
temp <- dcast(temp, race_sex ~ program, value.var = "stick")
names(temp) <- gsub("engineering", "", names(temp), ignore.case = TRUE)
names(temp) <- gsub("race_sex",
  "Race/ethnicity/sex",
  names(temp),
  ignore.case = TRUE
)
names(temp) <- gsub(" ", "", names(temp))
kable2html(temp, caption = "Table 2: Stickiness (row records)")
```
<br>

Depending on your software background, you may have encountered a block-record/row-record transformation using any of these function pairs---a list adapted from [@Mount+Zumel:2019:fluid-data]. 

- pivot / anti-pivot or crosstab / shred (databases)
- pivot_to_rowrecs / unpivot_to_blocks (cdata)
- reshape "wide" / reshape "long" (R)
- pivot_wider / pivot_longer (tidyr)
- pivot / unpivot (Microsoft Excel)
- dcast / melt (data.table)
- cast / melt (reshape2)

Before reshaping, we convert factors to characters so that the rows and columns are in alphabetical order after reshaping. 

```{r}
# convert factors to characters
temp <- copy(blockf)
temp <- temp[, race_sex := as.character(race_sex)]
temp <- temp[, program := as.character(program)]
```

`dcast()` is used here to reshape the data frame from block-record form to row-record form. 

```{r}
# reshape
rowf <- dcast(temp, race_sex ~ program, value.var = "stick")
```

Lastly, we shorten the new column names. The result is the source for Table 2 above. 

```{r}
# shorten column names
names(rowf) <- gsub("engineering", "", names(rowf), ignore.case = TRUE)

# remove white space
names(rowf) <- gsub(" ", "", names(rowf))

# edit the first column name
names(rowf) <- gsub("race_sex",
  "Race/ethnicity/sex",
  names(rowf),
  ignore.case = TRUE
)

# examine the result
rowf
```

Other good tools for reshaping are provided in packages such as cdata  [@Mount+Zumel:2020:cdata] and tidyr [@Wickham+Henry:2020:tidyr]. Base R provides  the `reshape()` function but the arguments in `dcast()` seem easier to understand in this instance. 

## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script. 

```{r eval=FALSE}
# packages used
library(midfieldr)
library(data.table)
library(ggplot2)

# load stickiness data from case study
pre_mw <- copy(rep_stickiness)

# prepare rows
rows_we_want <- pre_mw$ever >= 5
pre_mw <- pre_mw[rows_we_want]

rows_we_want <- !pre_mw$race %in% c(
  "Unknown",
  "International",
  "Other",
  "Native American"
)
pre_mw <- pre_mw[rows_we_want]


# complete the transformation to multiway form
data_mw <- copy(pre_mw)
data_mw[, race_sex := paste(race, sex, sep = " ")]
cols_we_want <- c("program", "race_sex", "stick")
data_mw <- data_mw[, ..cols_we_want]

# transform characters to factors ordered by median stickiness
data_mw <- prepare_multiway(data_mw)

# create one multiway graph
ggplot(data = data_mw, aes(x = stick, y = race_sex)) +
  facet_wrap(vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")

# create the dual multiway graph
ggplot(data = data_mw, aes(x = stick, y = program)) +
  facet_wrap(vars(race_sex), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")

# tabulate data in block record ("long") form
blockf <- copy(data_mw)
blockf[, stick := round(stick, 2)]
blockf

# tabulate data in row record ("wide") form
temp <- copy(blockf)
temp <- temp[, race_sex := as.character(race_sex)]
temp <- temp[, program := as.character(program)]
rowf <- dcast(temp, race_sex ~ program, value.var = "stick")
names(rowf) <- gsub("engineering", "", names(rowf), ignore.case = TRUE)
names(rowf) <- gsub(" ", "", names(rowf))
names(rowf) <- gsub("race_sex",
  "Race/ethnicity/sex",
  names(rowf),
  ignore.case = TRUE
)
```
