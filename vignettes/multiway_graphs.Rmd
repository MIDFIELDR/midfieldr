---
title: "Multiway graphs and tables"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Multiway graphs and tables}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/body-and-society.csl
link-citations: yes
resource_files:
  - ../man/figures/vignette-multiway-graphs-fig1-1.png
  - ../man/figures/vignette-multiway-graphs-fig2-1.png
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-multiway-graphs-")
knitr::opts_chunk$set(
  echo = TRUE,
  message = FALSE,
  warning = FALSE,
  collapse = TRUE,
  comment = "#>",
  error = FALSE,
  fig.width = 6,
  fig.asp = 1 / 1.6,
  out.width = "70%",
  fig.align = "center"
)
knitr::knit_hooks$set(inline = function(x) {
  if (!is.numeric(x)) {
    x
  } else if (x >= 10000) {
    prettyNum(round(x, 2), big.mark = ",")
  } else {
    prettyNum(round(x, 2))
  }
})
kable2html <- function(x, font_size = NULL, caption = NULL) {
  font_size <- ifelse(is.null(font_size), 11, font_size)
  kable_in <- knitr::kable(x, format = "html", caption = caption)
  kableExtra::kable_styling(kable_input = kable_in, font_size = font_size)
}
asp_ratio_mw <- function(data, categories) {
  cat1 <- categories[1] # panels
  cat2 <- categories[2] # rows
  nlevel1 <- nlevels(data[, get(cat1)])
  nlevel2 <- nlevels(data[, get(cat2)])
  r <- nlevel1 * nlevel2
  q <- 32
  asp_ratio1 <- (r + 2 * nlevel1) / q
  asp_ratio2 <- (r + 2 * nlevel2) / q
  ratios <- c(asp_ratio1, asp_ratio2)
}
```

## Introduction 

For initial exploration of possible stories in the data, the most common graph design used by the MIDFIELD team is the multiway graph. We examine multiway data here, in this initial tutorial, because as Wickham states [@Wickham+Grolemund:2017], 

>  Visualization is a great place to start with R programming, because the payoff is so clear; you get to make elegant and informative plots that help you understand the data. 

Many persistence metrics can be organized as *multiway data* in which there is is one quantitative variable and two categorical variables. As explained by its inventor [@Cleveland:1993], 

> ... the quantitative variable is a response, and the goal is to study how it depends on the categorical variables, which are factors. What distinguishes multiway data is the cross-classification of the categorical variables; there is a value of the response for each combination of levels of the two categorical variables. 

The structure of multiway data is specific: one categorical variable with $m$ levels, an independent second categorical variable with $n$ levels, and a single  quantitative value associated with every combinations of levels of the two categories. Multiway data are typically organized as three columns with $m \times n$ rows. 

The categorical variables can also be considered keys to the values of the quantitative variable. 




### This vignette uses

midfieldr functions 
 
- `prepare_multiway()` described in this vignette

midfieldr built-in data sets 

- `rep_stickiness` described in [Stickiness metric](stickiness_metric.html) 

packages

```{r}
# packages used
library(midfieldr)
library(data.table)
library(ggplot2)

# print max 20 rows, otherwise 10 rows each head/tail
options(datatable.print.nrows = 20, datatable.print.topn = 10)
```




## Conditioning multiway data 

Longitudinal "stickiness" is the ratio of the number of students graduating in a program to the number of students ever enrolled in that program [@Ohland+Orr+others:2012]. 

The stickiness data in this case study are available as the built-in data set `rep_stickiness`. 

```{r}
# examine the built-in data 
rep_stickiness
```

You may view its help page by running

```
? rep_stickiness
```

In general, data like these---ready to be conditioned as multiway data---can be considered "pre-multiway", denoted by the new name assignment, `pre_mw`. 

```{r}
# create a new memory location 
pre_mw <- copy(rep_stickiness)
```

The quantitative variable is `stick` (stickiness); the first categorical variable is `program`; the second categorical variable is race/ethnicity/sex. We construct the `race_sex` variable by combining two columns. 

```{r}
# create a combined race/ethnicity/sex variable
pre_mw[, race_sex := paste(race, sex)]
```

We select the three multiway variables, dropping the other columns. 

```{r}
# select columns
columns_we_want <- c("program", "race_sex", "stick")
pre_mw <- pre_mw[, ..columns_we_want]

# examine the result
pre_mw
```

To confirm that the data are in the form we want, 

```{r}
# number of levels of the two categories
m_levels_program  <- length(unique(pre_mw$program))
n_levels_race_sex <- length(unique(pre_mw$race_sex))

# examine the result
m_levels_program
n_levels_race_sex
```

Thus we expect $m \times n$ = `r m_levels_program*n_levels_race_sex` observations. Instead, as described in the stickiness vignette, some rows are omitted to preserve confidentiality, leaving us with `r dim(pre_mw)[1]` observations.

Now we apply `prepare_multiway()` to argument `pre_mw` to transform the data  such that the two categorical variables are factors with levels ordered by medians of the quantitative variable.  

You may view its help page by running

```
? prepare_multiway()
```

The result is ready for multiway graphing, so we name it `ready_mw`.

```{r}
# convert pre-multiway data to multiway data 
ready_mw <- prepare_multiway(pre_mw)

# examine the result
ready_mw
```

Confirming that the categorical variables are factors. 

```{r}
# categorical variables are factors
class(ready_mw$program)
class(ready_mw$race_sex)
```

Confirming that the factor levels are ordered by stickiness (not alphabetically).

```{r}
# the levels are from low stickiness to high stickiness
levels(ready_mw$program)
levels(ready_mw$race_sex)
```



## Creating a multiway graph

```{r include = FALSE}
asp_ratio <- asp_ratio_mw(ready_mw, categories = c("program", "race_sex"))
```

We use conventional ggplot2 functions to create the multiway graphs. By previously ordering the levels of the factors, we have structured the data so that the rows and panels of the multiway graph are ordered by the appropriate medians. 

*Reminder:* These are practice data, not suitable for drawing inferences about student performance, i.e., not for research.

```{r fig1, fig.asp = asp_ratio[1]}
# create one multiway graph
ggplot(data = ready_mw, aes(x = stick, y = race_sex)) +
  facet_wrap(vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", 
       y = "", 
       title = "Practice data (not for research)", 
       caption = "Source: midfielddata")
```
<br>

This graph permits a direct visual comparison of how stickiness varies by race and sex within a particular major. 

Reading a multiway graph

- We can more effectively compare values within a panel than between panels.
- Because rows are ordered, one expects a generally increasing trend within a panel. A response greater or smaller than expected creates a visual asymmetry. The interesting stories are often in these visual anomalies.
- To explore the comparison between panels, we swap the row and panel categories, creating the dual multiway.



## Creating the dual multiway graph

The previous graph does not facilitate visual comparisons of members of the same race-sex group. As Cleveland says,

> Because of this asymmetry, it is often important to explore multiway data by as many multiway dot plots as there are categorical variables, with each variable assigned once to the levels.

To create the *dual multiway* graph, we swap the roles of the rows and panels. 

- `y = race_sex` becomes `y = program`
- `facet_wrap(vars(program) ...`  becomes `facet_wrap(vars(race_sex) ...` 

```{r fig2, fig.asp = asp_ratio[2]}
# create the dual multiway graph
ggplot(data = ready_mw, aes(x = stick, y = program)) +
  facet_wrap(vars(race_sex), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", 
       y = "", 
       title = "Practice data (not for research)", 
       caption = "Source: midfielddata")
```
<br>

This graph permits a direct visual comparison of how stickiness varies by major for one group of students. 

Both multiways should be created for discussion. Usually one or the other will convey a more compelling visual story that gets included in the published findings. 




## Data tables: two formats

Data tables are useful in discussions with one's research team and are often included in publications for editors or reviewers who want to see the values underlying the data graphics. 

Our data are currently laid out in "block record" form [@Mount+Zumel:2019:fluid-data], where the `race_sex` key and the `program` key are both in columns and the finding is in the last column. This layout is also called "tidy data"  [@Wickham+Grolemund:2017]. 

The graphing package we use, ggplot2, is designed to work most effectively with block-record data, thus the block-record ("long") form is the default layout in midfieldr. 

```{r echo = FALSE}
temp <- copy(ready_mw)
temp[, stick := round(stick, 2)]
kable2html(temp, caption = "Table 1: Stickiness (block records)")
```
<br>

However, the visual convention preferred by publishers and readers is a row-record ("wide") form, as illustrated by Table 2. The `race_sex` key is in the left column and the `program` key is in the column names. The stickiness findings lie at the row-column intersections. Note that in this form, the four NA observations we mentioned earlier are explicitly shown. 

```{r echo = FALSE}
temp[, race_sex := as.character(race_sex)]
temp[, program := as.character(program)]
temp <- dcast(temp, race_sex ~ program, value.var = "stick")
setnames(temp, 
         old = c("race_sex", 
                 "Civil Engineering", 
                 "Electrical Engineering", 
                 "Industrial Engineering", 
                 "Mechanical Engineering"), 
         new = c("Race/ethnicity/sex", 
                 "Civil", 
                 "Electrical", 
                 "Industrial", 
                 "Mechanical"))
kable2html(temp, caption = "Table 2: Stickiness (row records)")
```

Depending on your software background, you may have encountered a block-record/row-record transformation using any of these function pairs---a list adapted from [@Mount+Zumel:2019:fluid-data]. 

- pivot / anti-pivot or crosstab / shred (databases)
- pivot_to_rowrecs / unpivot_to_blocks (cdata)
- reshape "wide" / reshape "long" (R)
- pivot_wider / pivot_longer (tidyr)
- pivot / unpivot (Microsoft Excel)
- dcast / melt (data.table)
- cast / melt (reshape2)



## Creating a table for publication

The first thing to do before tabulating is to limit the significant figures of floating-point numbers. 

```{r}
# create a new memory location  
block_form <- copy(ready_mw)

# limit significant digits
block_form[, stick := round(stick, 2)]
```

Before reshaping, we convert factors to characters so that the rows and columns are in alphabetical order after reshaping. 

```{r}
# create a new memory location 
row_form <- copy(block_form)

# convert factors to characters
row_form[, race_sex := as.character(race_sex)]
row_form[, program := as.character(program)]
```

`dcast()` is used to reshape the data frame from block-record form to row-record form. 

```{r}
# reshape
row_form <- dcast(row_form, race_sex ~ program, value.var = "stick")
```

Lastly, we edit the new column names. 

```{r}
# edit column names
setnames(row_form, 
         old = c("race_sex", 
                 "Civil Engineering", 
                 "Electrical Engineering", 
                 "Industrial Engineering", 
                 "Mechanical Engineering"), 
         new = c("Race/ethnicity/sex", 
                 "Civil", 
                 "Electrical", 
                 "Industrial", 
                 "Mechanical"))

# examine the result
row_form
```


This result is the source for Table 2 above.

Other good tools for reshaping are provided in packages such as cdata  [@Mount+Zumel:2020:cdata], tidyr [@Wickham+Henry:2020:tidyr], and `reshape()` in base R. 

## References

<div id="refs"></div>

## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script. 

```{r eval = FALSE}
# packages used
library(midfieldr)
library(data.table)
library(ggplot2)

# conditioning multiway data 
pre_mw <- rep_stickiness
pre_mw[, race_sex := paste(race, sex)]
columns_we_want <- c("program", "race_sex", "stick")
pre_mw <- pre_mw[, ..columns_we_want]
ready_mw <- prepare_multiway(pre_mw)

# creating a multiway graph 
ggplot(data = ready_mw, aes(x = stick, y = race_sex)) +
  facet_wrap(vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", 
       y = "", 
       title = "Practice data (not for research)", 
       caption = "Source: midfielddata")

# creating the dual multiway graph
ggplot(data = ready_mw, aes(x = stick, y = program)) +
  facet_wrap(vars(race_sex), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", 
       y = "", 
       title = "Practice data (not for research)", 
       caption = "Source: midfielddata")

# creating a table for publication
block_form <- copy(ready_mw)
block_form[, stick := round(stick, 2)]
row_form <- copy(block_form)
row_form[, race_sex := as.character(race_sex)]
row_form[, program := as.character(program)]
row_form <- dcast(row_form, race_sex ~ program, value.var = "stick")
setnames(row_form, 
         old = c("race_sex", 
                 "Civil Engineering", 
                 "Electrical Engineering", 
                 "Industrial Engineering", 
                 "Mechanical Engineering"), 
         new = c("Race/ethnicity/sex", 
                 "Civil", 
                 "Electrical", 
                 "Industrial", 
                 "Mechanical"))
```


