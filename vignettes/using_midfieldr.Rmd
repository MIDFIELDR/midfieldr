---
title: "Using midfieldr"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using midfieldr}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
editor_options: 
  chunk_output_type: console
bibliography: ../inst/REFERENCES.bib
csl: ../inst/chicago-author-date.csl
link-citations: yes
resource_files:
  - ../man/figures/vignette-using-midfieldr-fig1-1.png
---

```{r setup, include = FALSE}
source("vignette-knitr-opts.R")
knitr::opts_chunk$set(fig.path = "../man/figures/vignette-using-midfieldr-")
```

## Introduction

This exercise illustrates a typical workflow for computing a persistence metric, starting with student record data from MIDFIELD [@Ohland+Long:2016] and ending with a multiway graph. 

Our metric in this case is "stickiness", the ratio of the number of students graduating from a program to the number ever enrolled in the program [@Ohland+Orr+others:2012]. We compare the stickiness of three engineering programs with students grouped by program, race/ethnicity, and sex. 

In this introductory example, conveying *what* is more important than *how*. We focus on what the steps are and how they fit together. How the code works is explained in greater detail in the vignettes [(link)](index.html).

## Gather program data 

In this example, we compare the stickiness of three programs---Chemical Engineering, Electrical Engineering, and Industrial Engineering---grouping students by program, race/ethnicity, and sex. 

```{r}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# data.table printing options
options(datatable.print.nrows = 20, datatable.print.topn = 5)
```

We start by searching the `cip` data set for the 6-digit codes of our programs.  Our first search using `get_cip()` is for engineering generally. The search is refined by searching on specific program key words.
 
```{r}
# first pass
sub_cip <- get_cip(data = cip, keep_any = "engineering")

# examine the result
sub_cip
```

We refine the result by operating on the `sub_cip` data frame we just created. 

```{r}
# second pass
sub_cip2 <- get_cip(
  data = sub_cip,
  keep_any = c("chemical", "electrical", "industrial"),
  drop_any = "technolog"
)

# examine the result at the 4-digit level
columns_we_want <- c("cip4", "cip4name")
unique(sub_cip2[, ..columns_we_want])
```

The results show that the 4-digit codes we want are 1407, 1410, and 1435. We use  `get_cip()` again to extract the 6-digit codes for these specific programs. With `label_programs()` we extract the 6-digit columns only and add a program label. 

```{r}
# get chemical engineering
che_cip <- get_cip(data = sub_cip2, keep_any = "^1407")
che <- label_programs(data = che_cip, label = "Chemical Engineering")

# view the result
che
```

Repeat for electrical and industrial engineering. 

```{r}
# get electrical engineering
ece_cip <- get_cip(data = sub_cip2, keep_any = "^1410")
ece <- label_programs(data = ece_cip, label = "Electrical Engineering")

# get industrial engineering
ise_cip <- get_cip(data = sub_cip2, keep_any = "^1435")
ise <- label_programs(data = ise_cip, label = "Industrial Engineering")
```

We combine the three programs into one data frame.

```{r}
# gather the programs in the study
program_group <- rbind(che, ece, ise)

# examine the result
program_group
```

We can see that our custom program names are consistent with the default 6-digit CIP names, so we can dispense with the `cip6names` column. The `program` column is used later for grouping, summarizing, and joining. 

```{r}
# verbose column can be deleted
program_group$cip6name <- NULL

# examine the result
program_group
```

We extract the `cip6` column as a character vector to gather student data. 

```{r}
# extract a vector of 6-digit CIP codes
group_codes <- program_group$cip6

# examine the result
group_codes
```


<br>
<a href="#top">&#9650; top of page</a> 




## Default data arguments

A number of midfieldr functions have the form `get_*()`, for example, 

- `get_cip()`
- `get_enrollees()`
- `get_graduates()`
- `get_race_sex()`

In each function the first argument (`data`) has a default setting to access one of the data sets in midfieldr or midfielddata. For example, the default `data` argument is `cip` for `get_cip()`, `midfieldstudents` for `get_race_sex()`, and `midfielddegrees` for `get_graduates()`. 

One can omit the `data` argument if using the default datasets. Thus the following code chunks produce identical results. 

```r
library(midfieldr)
group_codes <- c("141099", "143501")

# using an implicit data argument
get_enrollees(codes = group_codes)

# using an explicit data argument
library(midfielddata)
get_enrollees(midfieldterms, codes = group_codes)

# using an explicit, named data argument
get_enrollees(data = midfieldterms, codes = group_codes)
```

Note that the midfielddata package must be loaded to assign one of its datasets by name. For clarity, we use the explicit form in the vignette. 




<br>
<a href="#top">&#9650; top of page</a> 




## Gather student data

We use `get_enrollees()` to extract the IDs of all students who ever enrolled in the programs listed in `group_codes`. The default data argument is `midfieldterms`.

```{r}
# students ever enrolled in programs
enrollees <- get_enrollees(midfieldterms, codes = group_codes)

# examine the result
enrollees
```

For some of these students, completing their program may not be feasible given the range of data available. `completion_feasible()` subsets the student IDs, retaining those who matriculate at least six years before the last term in the data. 

```{r}
# apply the feasible completion filter
feasible_ids <- completion_feasible(id = enrollees$id)

# subset the enrollees
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]

# examine the result
enrollees
```

We use `get_race_sex()` to obtain the race/ethnicity of each enrollee. The default data argument is `midfieldstudents`. 

```{r}
# obtain race/ethnicity and sex at matriculation
demographics <- get_race_sex(midfieldstudents, keep_id = feasible_ids)

# examine the result
demographics
```

Now we can join the race/ethnicity and sex data frame to the enrollees data frame. 

```{r}
# left-join demographics to enrollees
enrollees <- merge(enrollees, demographics, by = "id", all.x = TRUE)

# examine the result
enrollees
```

We join the program names from `program_group` to our working data frame so we can count by groups in the next step. 

```{r}
# left-join program_group to enrollees
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)

# examine the result
enrollees
```

To frame our results in terms of program, race/ethnicity, and sex, we group by these variables and count the number of students in each grouping. The count is assigned to the new `ever` column.  

```{r}
# assign variables to aggregate by
grouping_variables <- c("program", "race", "sex")

# aggregation using data.table syntax
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]

# examine the result
grouped_enrollees
```

Note the change in the size of the data frame, from `r nrow(enrollees)` in `enrollees` where every row is a student to 48 in the `grouped_enrollees` below where every row is a group.

A similar process is used to group and summarize our graduates. We start with `get_graduates()` with a default data argument of `midfielddegrees`. For graduates, the question of completion feasibility is moot---graduation itself establishes feasibility. Thus we omit the the feasible completion filter in this step. 

```{r}
# students graduating from programs
graduates <- get_graduates(midfielddegrees, codes = group_codes)
ids_we_want <- graduates$id
demographics <- get_race_sex(midfieldstudents, keep_id = ids_we_want)
graduates <- merge(graduates, demographics, by = "id", all.x = TRUE)
graduates <- merge(graduates, program_group, by = "cip6", all.x = TRUE)
grouped_graduates <- graduates[, .(grad = .N), by = grouping_variables]

# examine the result
grouped_graduates
```

Note that we have `r nrow(grouped_enrollees)` groupings of enrollees but only `r nrow(grouped_graduates)` groupings of graduates. Some enrollee groups have no graduates. 

 


<br>
<a href="#top">&#9650; top of page</a> 




## Compute the metric

We join the two data frames by our framing variables (program, race/ethnicity, and sex), producing a data frame with `ever` and `grad` for each group.  

```{r}
# left-join graduates to enrollees
metric <- merge(grouped_enrollees,
  grouped_graduates,
  by = grouping_variables,
  all.x = TRUE
)

# examine the result, ordered by program
metric[order(program)]
```

There are `r nrow(grouped_enrollees) - nrow(grouped_graduates)` NA entries in the `grad` column where we have enrollees but no graduates. To see them more directly:

```{r}
rows_with_degree_NA <- is.na(metric$grad)
metric[rows_with_degree_NA]
```

We convert the NA values in the `grad` column to zero.

```{r}
# convert grad NA to zero
metric[rows_with_degree_NA, grad := 0]

# examine the result
metric[rows_with_degree_NA]
```

We omit rows with zero students ever enrolled, if any, to avoid dividing by zero, then divide `grad` by `ever` to compute stickiness.  

```{r}
# prevent division by zero
rows_we_want <- metric$ever > 0
metric <- metric[rows_we_want]

# compute stickiness
metric[, stick := round(grad / ever, 3)]

# examine the result
metric
```

This completes the data manipulation for obtaining the persistence metric.  



<br>
<a href="#top">&#9650; top of page</a> 



## Condition the data for display 

To prepare the results for graphing, we construct a "pre-multiway" version of the data frame. We begin by removing ambiguous levels of race/ethnicity. 

```{r}
# initialize the pre-multiway data frame
pre_mw <- metric

# remove ambiguous levels of race/ethnicity
rows_we_want <- !pre_mw$race %in% c("Unknown", "International", "Other")
pre_mw <- pre_mw[rows_we_want]

# examine the result
unique(pre_mw$race)
```

To protect confidentiality, we omit observations with 5 or fewer students ever enrolled.

```{r}
# protect confidentiality of small populations
rows_we_want <- pre_mw$ever > 5
pre_mw <- pre_mw[rows_we_want]

# examine the result
pre_mw
```

We plan to display these data in a multiway graph, characterized by a single quantitative response variable (stickiness) for each combination of levels of the two categorical variables (program and race/ethnicity/sex).

The race/ethnicity/sex category is created by uniting `race` and `sex`. 

```{r}
# complete the transformation to multiway form
data_mw <- pre_mw

# create a new combined framing variable
data_mw[, race_sex := paste(race, sex, sep = " ")]

# examine the result
data_mw
```

To structure the data in multiway form, we select the three multiway variables and use `order_multiway()` to convert the categorical variables to factors and order the levels of the categories by the median stickiness. 

```{r}
# select the three multiway variables
columns_we_want <- c("program", "race_sex", "stick")
data_mw <- pre_mw[, ..columns_we_want]

# initialize the multiway data frame
data_mw <- order_multiway(data_mw)
```

The median stickiness values are attributes of the data frame. We can view them as follows. Note that `program` and `race_sex` are now factors ordered by the median stickiness (recorded under the `scores` attribute). 

```{r}
sapply(data_mw, FUN = attributes)
```

```{r echo = FALSE}
x <- attributes(data_mw$program)
level_medians <- x$scores

low_median <- round(min(level_medians), 2)
high_median <- round(max(level_medians), 2)

low_level <- levels(data_mw$program)[1]
high_level <- levels(data_mw$program)[nlevels(data_mw$program)]
```

The categorical variables are factors. The levels of `program` are ordered by increasing median stickiness from `r low_median` (`r low_level`) to `r high_median` (`r high_level`). 

```{r echo = FALSE}
x <- attributes(data_mw$race_sex)
level_medians <- x$scores

low_median <- round(min(level_medians), 2)
high_median <- round(max(level_medians), 2)

low_level <- levels(data_mw$race_sex)[1]
high_level <- levels(data_mw$race_sex)[nlevels(data_mw$race_sex)]
```

The levels of the `race_sex` are ordered by increasing median stickiness from `r low_median` (`r low_level`) to `r high_median` (`r high_level`). 



<br>
<a href="#top">&#9650; top of page</a> 



## Graph the results

We use conventional ggplot2 functions to graph stickiness in a multiway dot plot. Rows and panels, from top to bottom, are ordered by decreasing median stickiness [@Cleveland:1993].  

```r
# graph results
ggplot(data = data_mw, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```

```{r fig1, fig.asp = 1.8/1.6, echo = FALSE}
# for annotation
rows_we_want <- data_mw$program %in% "Electrical Engineering" &
  data_mw$race_sex %in% "White Female"
pt1 <- data_mw[rows_we_want, , drop = FALSE]
rows_we_want <- data_mw$program %in% "Chemical Engineering" &
  data_mw$race_sex %in% "Asian Male"
pt2 <- data_mw[rows_we_want, , drop = FALSE]
rows_we_want <- data_mw$program %in% "Industrial Engineering" &
  data_mw$race_sex %in% "Hispanic Female"
pt3 <- data_mw[rows_we_want, , drop = FALSE]
df <- rbind(pt1, pt2, pt3)

ggplot(data_mw, aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "") +
  geom_point(
    data = df,
    mapping = aes(x = stick, y = race_sex),
    color = "red",
    shape = 1,
    size = 4
  )
```

A multiway design reveals patterns and anomalies in the results. For example, among these programs for this sample population:  

Visual anomalies, circled in red

- Hispanic women have a higher stickiness in Industrial engineering than would be expected from their overall stickiness 
- White women have a lower stickiness in Electrical engineering than expected
- Asian men have a lower stickiness in Chemical engineering than expected

Patterns, for these students and these programs

- Industrial engineering has the highest stickiness, Chemical engineering the lowest
- Asian men and women have the highest stickiness 
- Native American men and women have the lowest stickiness, though their small numbers may make the finding meaningless 

Such visual anomalies and patterns raise questions that lead to further research, for example, in institutional polices, the cultures of professional disciplines, and student experiences in the undergraduate ecosystem. 






<br>
<a href="#top">&#9650; top of page</a> 




## References

<div id="refs"></div>


## Appendix

### Complete script

The vignette code chunks are collected below in a single, condensed script.

```{r eval=FALSE}
# packages used
library(midfieldr)
library(midfielddata)
library(data.table)
library(ggplot2)

# gather the three programs
che_cip <- get_cip(cip, keep_any = "^1407")
che <- label_programs(che_cip, label = "Chemical Engineering")
ece_cip <- get_cip(cip, keep_any = "^1410")
ece <- label_programs(ece_cip, label = "Electrical Engineering")
ise_cip <- get_cip(cip, keep_any = "^1435")
ise <- label_programs(ise_cip, label = "Industrial Engineering")
program_group <- rbind(che, ece, ise)
program_group$cip6name <- NULL

# extract a vector of 6-digit CIP codes
group_codes <- program_group$cip6

# gather students ever enrolled with feasible program completion
enrollees <- get_enrollees(midfieldterms, codes = group_codes)
feasible_ids <- completion_feasible(id = enrollees$id)
rows_we_want <- enrollees$id %in% feasible_ids
enrollees <- enrollees[rows_we_want]
demographics <- get_race_sex(midfieldstudents, keep_id = feasible_ids)
enrollees <- merge(enrollees, demographics, by = "id", all.x = TRUE)
enrollees <- merge(enrollees, program_group, by = "cip6", all.x = TRUE)

# assign variables to aggregate by
grouping_variables <- c("program", "race", "sex")
grouped_enrollees <- enrollees[, .(ever = .N), by = grouping_variables]

# gather graduates from programs
graduates <- get_graduates(midfielddegrees, codes = group_codes)
ids_we_want <- graduates$id
demographics <- get_race_sex(midfieldstudents, keep_id = ids_we_want)
graduates <- merge(graduates, demographics, by = "id", all.x = TRUE)
graduates <- merge(graduates, program_group, by = "cip6", all.x = TRUE)
grouped_graduates <- graduates[, .(grad = .N), by = grouping_variables]

# compute the metric
metric <- merge(grouped_enrollees,
  grouped_graduates,
  by = grouping_variables,
  all.x = TRUE
)
rows_with_degree_NA <- is.na(metric$grad)
metric[rows_with_degree_NA, grad := 0]
rows_we_want <- metric$ever > 0
metric <- metric[rows_we_want]
metric[, stick := round(grad / ever, 3)]

# condition the data
pre_mw <- metric
rows_we_want <- !pre_mw$race %in% c("Unknown", "International", "Other")
pre_mw <- pre_mw[rows_we_want]
rows_we_want <- pre_mw$ever > 5
pre_mw <- pre_mw[rows_we_want]

# complete the transformation to multiway form
data_mw <- pre_mw
data_mw[, race_sex := paste(race, sex, sep = " ")]
data_mw <- pre_mw[, .(program, race_sex, stick)]
data_mw <- order_multiway(data_mw)

# graph results
ggplot(data = data_mw, mapping = aes(x = stick, y = race_sex)) +
  facet_wrap(facets = vars(program), ncol = 1, as.table = FALSE) +
  geom_point(na.rm = TRUE) +
  labs(x = "Stickiness", y = "")
```

<br>
<a href="#top"         >&#9650;     top of page </a>     
<a href="../index.html">&#9665;       main page </a> 

